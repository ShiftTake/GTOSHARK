<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>GTO Shark • Live Practice (Vanilla)</title>
<style>
  :root{
    --bg:#0b1220;            /* page */
    --ink:#e2e8f0;
    --felt:#0f3d37;          /* realistic felt base */
    --felt-hi:#13574f;       /* highlight for felt vignette */
    --rail:#162239;          /* rail/rim */
    --rail-glow: rgba(79,70,229,.35);
    --indigo:#4f46e5;        /* primary */
    --teal:#14b8a6;          /* accent */
    --good:#22c55e;
    --warn:#fbbf24;
    --bad:#ef4444;

    --table-size: 900px;     /* tuned for 1080p */
    --seat: 84px;
    --card-w: 88px;          /* hero/seat cards */
    --card-h: 124px;
    --board-w: 80px;         /* board cards slightly smaller */
    --board-h: 112px;
    --rail-width: 12px;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; padding:16px; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,"Helvetica Neue",Arial;
    color:var(--ink); background:var(--bg);
  }

  /* ---------- page grid ---------- */
  .app{
    display:grid;
    grid-template-columns: minmax(760px, 1fr) 360px;
    gap:16px;
    align-items:start;
    max-width:1400px;
    margin:0 auto;
  }
  @media (max-width:1200px){
    .app{grid-template-columns:1fr}
    .sidebar{order:3}
  }

  /* ---------- header controls ---------- */
  header{
    max-width:1400px; margin:0 auto 10px auto; display:flex; gap:12px; align-items:end; justify-content:space-between; flex-wrap:wrap;
  }
  h1{margin:0; font-weight:900; letter-spacing:.2px; color:#c7d2fe}
  .sub{margin:4px 0 0 0; color:#94a3b8; font-size:13px}
  .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .lbl{font-size:12px; color:#9fb2cc; margin-right:4px}
  select,button,input[type=number]{
    background:#0f172a; color:#e2e8f0; border:1px solid #334155; border-radius:10px; padding:8px 10px; font-weight:600
  }
  button.primary{background:var(--indigo); border-color:transparent; color:#fff; font-weight:800}
  button.ghost{background:#0f172a; border:1px solid #2b3647; color:#9be2d6}
  button.danger{background:linear-gradient(135deg,#ef4444,#dc2626); color:#fff; border:none}
  button:disabled{opacity:.6; cursor:not-allowed}

  /* ---------- table ---------- */
  .table-wrap{display:flex; justify-content:center}
  .table{
    width:var(--table-size); height:var(--table-size); position:relative; border-radius:50%;
    /* felt with subtle cloth texture */
    background:
      radial-gradient(ellipse at 50% 45%, rgba(18,93,84,.9), rgba(11,61,54,.85) 60%, rgba(6,31,28,.8) 78%, rgba(5,22,20,.8) 88%),
      radial-gradient(circle at 35% 35%, rgba(255,255,255,.06) 0 6%, transparent 7% 100%),
      radial-gradient(circle at 68% 62%, rgba(255,255,255,.05) 0 7%, transparent 8% 100%),
      radial-gradient(circle at 28% 78%, rgba(255,255,255,.05) 0 5%, transparent 6% 100%),
      linear-gradient(145deg, var(--felt-hi), var(--felt));
    outline: var(--rail-width) solid var(--rail);
    box-shadow:
      inset 0 0 48px rgba(0,0,0,.35),
      0 0 0 3px var(--rail-glow),
      0 14px 40px rgba(20,184,166,.15);
  }

  /* center HUD */
  .hud{
    position:absolute; left:50%; top:45%;
    transform:translate(-50%,-50%);
    display:flex; gap:10px; align-items:center;
    border:1px solid #34435b; background:rgba(15,23,42,.65);
    padding:6px 10px; border-radius:10px; font-weight:800; color:#c7d2fe; z-index:40;
    backdrop-filter: blur(2px);
  }
  .hud .sep{opacity:.5}

  /* board row */
  .board{position:absolute; left:50%; top:52%; transform:translate(-50%,-50%); display:flex; gap:8px; z-index:35}

  /* floating effects (bets, reveals) */
  .float-layer{position:absolute; inset:0; pointer-events:none; z-index:50}

  /* seats */
  .seat{
    position:absolute; transform:translate(-50%,-50%);
    width:var(--seat); height:var(--seat); border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    background:#142034; border:2px solid #2a3a52; color:#9fb2cc; font-weight:900; font-size:12px;
    box-shadow:0 6px 18px rgba(0,0,0,.35); transition:.25s;
  }
  .seat.hero{ border-color:#1dbd72; color:#d1ffe2; box-shadow:0 0 22px rgba(29,189,114,.65) }
  .seat.acting{ border-color:var(--warn); color:#fde68a; box-shadow:0 0 26px rgba(251,191,36,.65) }
  .seat.folded{ color:#64748b; border-color:#3a4a63; filter:grayscale(.6) }
  .stack{
    position:absolute; top:calc(100% + 14px); left:50%; transform:translateX(-50%);
    background:#0b1220; border:1px solid rgba(99,102,241,.5); color:#c7d2fe; padding:2px 10px; border-radius:9999px; font-size:12px; white-space:nowrap
  }
  .hero-cards{
    position:absolute; transform:translate(-50%,-50%);
    display:flex; gap:8px; z-index:60
  }

  /* chips plate in front of seat (towards center) */
  .bet-plate{
    position:absolute; transform:translate(-50%,0);
    background:linear-gradient(135deg,#19263c,#0e1729);
    border:1px solid rgba(99,102,241,.55); color:#c7d2fe;
    padding:.3rem .55rem; border-radius:.6rem; font-weight:900; font-size:12px;
    box-shadow:0 8px 18px rgba(0,0,0,.35);
    display:flex; align-items:center; gap:.35rem; opacity:0; animation:chiprise 2.0s ease-out forwards;
    z-index:55;
  }
  .chip-icon{
    width:14px; height:14px; border-radius:9999px;
    background: radial-gradient(circle at 50% 50%, #f59e0b 0 26%, #7c3aed 28% 32%, #f59e0b 35% 60%, #7c3aed 63% 67%, #f59e0b 70%);
    border:1px solid rgba(245,158,11,.85);
    box-shadow:0 0 0 1px rgba(124,58,237,.75) inset;
  }
  @keyframes chiprise{
    0%{opacity:0; transform:translate(-50%,8px)}
    20%{opacity:1; transform:translate(-50%,0)}
    80%{opacity:1; transform:translate(-50%,-8px)}
    100%{opacity:0; transform:translate(-50%,-12px)}
  }

  /* cards */
  .card{
    width:var(--card-w); height:var(--card-h); border-radius:16px;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    background:linear-gradient(160deg,#fff 0%,#f3f5ff 55%,#e5e9ff 100%);
    border:2px solid rgba(79,70,229,.9); box-shadow:0 10px 22px rgba(0,0,0,.35);
  }
  .board .card{ width:var(--board-w); height:var(--board-h); border-radius:14px }
  .rank{font-size:46px; font-weight:900; line-height:1}
  .suit{font-size:36px; line-height:1; margin-top:2px}
  .red{color:#ef4444} .black{color:#0f172a}

  /* action panel (below table) */
  .panel{background:#0b1220; border:1px solid #2b3647; border-radius:16px; padding:14px}
  .panel h3{margin:0 0 8px 0}
  .prompt{color:#94a3b8; font-size:14px}
  .btn-row{display:flex; flex-wrap:wrap; gap:10px; margin-top:10px}
  .btn{
    background:#0f172a; color:#e2e8f0; border:1px solid #334155; border-radius:12px; padding:12px 14px; font-weight:800; transition:.15s;
  }
  .btn.primary{background:var(--indigo); color:#fff; border-color:transparent}
  .btn.ghost{background:#0f172a; color:#9be2d6; border:1px solid #2b3647}
  .btn.danger{background:linear-gradient(135deg,#ef4444,#dc2626); color:#fff; border:none}
  .btn:disabled{opacity:.6; cursor:not-allowed}

  /* sidebar */
  .sidebar .box{background:#0b1220; border:1px solid #2b3647; border-radius:16px; padding:14px}
  .result{background:linear-gradient(135deg,var(--indigo),var(--teal)); color:#fff; border-radius:16px; padding:14px; display:none}
  .big-score{font-size:48px; font-weight:900}
  .log-head{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px}
  .log{display:flex; flex-direction:column; gap:8px; max-height:480px; overflow:auto}
  .item{display:flex; justify-content:space-between; align-items:center; background:#0f172a; border:1px solid #2b3647; border-radius:12px; padding:8px 10px}
  .ok{color:var(--good); font-weight:900}
  .bad{color:var(--bad); font-weight:900}

  /* utility */
  .hidden{display:none}
</style>
</head>
<body>
  <header>
    <div>
      <h1>GTO Shark • Live Practice</h1>
      <p class="sub">Indigo/Teal cinematic felt • Correct blinds & raises • Chip plates • Showdown-only reveals</p>
    </div>
    <div class="controls">
      <span class="lbl">Scenario</span>
      <select id="scenario">
        <option value="none" selected>None (Standard)</option>
        <option value="bvb">Blind vs Blind (SB opens)</option>
        <option value="btn_vs_bb">BTN vs BB</option>
        <option value="co_vs_bb">CO vs BB</option>
        <option value="utg_vs_bb">UTG vs BB</option>
        <option value="sb_vs_bb">SB vs BB (limp/raise mixes)</option>
        <option value="hj_vs_co">HJ vs CO</option>
      </select>

      <span class="lbl">Sequence</span>
      <select id="sequence">
        <option value="preflop">Preflop only</option>
        <option value="turn">Play to Turn</option>
        <option value="river" selected>Play to River</option>
      </select>

      <span class="lbl">Hero</span>
      <select id="hero">
        <option>UTG</option><option>UTG+1</option><option>UTG+2</option><option>LJ</option>
        <option>HJ</option><option>CO</option><option selected>BTN</option><option>SB</option><option>BB</option>
      </select>

      <button id="newHand" class="primary">♻ New Hand</button>
    </div>
  </header>

  <div class="app">
    <!-- MAIN -->
    <main>
      <section class="table-wrap">
        <div id="table" class="table">
          <!-- HUD -->
          <div id="hud" class="hud">
            <span id="hudStreet">—</span><span class="sep">|</span>
            <span id="hudPot">Pot: —</span><span class="sep">|</span>
            <span id="hudSPR">SPR: —</span>
          </div>

          <!-- BOARD -->
          <div id="board" class="board"></div>

          <!-- SEATS LAYER -->
          <div id="seatsLayer"></div>

          <!-- FLOATING (bets, reveals) -->
          <div id="floatLayer" class="float-layer"></div>
        </div>
      </section>

      <!-- ACTIONS BELOW TABLE -->
      <section class="panel" style="margin-top:12px">
        <h3>Your move</h3>
        <div id="prompt" class="prompt">Loading…</div>
        <div id="actions" class="btn-row"></div>
      </section>
    </main>

    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div id="result" class="result">
        <div class="big-score" id="scorePct"></div>
        <div id="scoreVerdict" style="font-weight:800;margin-top:4px"></div>
      </div>

      <div class="box" style="margin-top:12px">
        <div class="log-head">
          <div style="font-weight:900;color:#c7d2fe">Hand Log</div>
          <button id="clearLog" class="ghost" style="padding:6px 8px">Clear</button>
        </div>
        <div style="font-size:12px;color:#9fb2cc;margin-bottom:6px">✅ ≥ 50% · ❌ &lt; 50%</div>
        <div id="log" class="log"></div>
      </div>
    </aside>
  </div>
<script>
/* ============================================================
   VANILLA ENGINE — NLH mechanics + simplified GTO policy
   ============================================================ */

const seatsOrder = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"]; // static ring
const streetNames = {preflop:"Preflop", flop:"Flop", turn:"Turn", river:"River"};

/* ----- DOM refs ----- */
const tableEl      = document.getElementById("table");
const seatsLayer   = document.getElementById("seatsLayer");
const floatLayer   = document.getElementById("floatLayer");
const boardEl      = document.getElementById("board");
const hudStreet    = document.getElementById("hudStreet");
const hudPot       = document.getElementById("hudPot");
const hudSPR       = document.getElementById("hudSPR");
const promptEl     = document.getElementById("prompt");
const actionsEl    = document.getElementById("actions");
const resultBox    = document.getElementById("result");
const scorePctEl   = document.getElementById("scorePct");
const scoreVerdEl  = document.getElementById("scoreVerdict");

const scenarioSel  = document.getElementById("scenario");
const sequenceSel  = document.getElementById("sequence");
const heroSel      = document.getElementById("hero");
const newBtn       = document.getElementById("newHand");
const clearLogBtn  = document.getElementById("clearLog");
const logEl        = document.getElementById("log");

/* ----- RNG (simple xorshift) ----- */
let _seed = Date.now()|0;
function seed(n){ _seed = n>>>0; }
function rnd(){ _seed^=_seed<<13; _seed^=_seed>>>17; _seed^=_seed<<5; return ((_seed>>>0)%1e5)/1e5; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

/* ----- Cards ----- */
const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const SUITS = ["♠","♥","♦","♣"];
function suitClass(s){ return (s==="♥"||s==="♦") ? "red" : "black"; }
function makeCardEl(card, isBoard){
  const el = document.createElement("div");
  el.className = "card" + (isBoard?"":"");
  if (isBoard) { el.style.width="var(--board-w)"; el.style.height="var(--board-h)"; }
  el.innerHTML = `<div class="rank ${suitClass(card[1])}">${card[0]}</div><div class="suit ${suitClass(card[1])}">${card[1]}</div>`;
  return el;
}
function dealUnique(n, taken){
  const out=[];
  while(out.length<n){
    const c = RANKS[Math.floor(rnd()*13)] + SUITS[Math.floor(rnd()*4)];
    if(!taken.has(c)){ taken.add(c); out.push(c); }
  }
  return out;
}

/* ----- State ----- */
const S = {
  scenario: "none",
  sequence: "river",
  hero: "BTN",

  street: "preflop",
  hands: {},            // seat -> [c1,c2]
  board: [],
  stacks: {},           // seat -> bb
  committed: {},        // current street
  folded: {},
  allin: {},
  pot: 0,

  currentBetTotal: 0,   // CB
  lastRaiseSize: 1,     // LRS (start at 1 bb preflop once someone raises; special handling)
  actedThisStreet: new Set(),
  showdownSet: new Set(),   // who must reveal at showdown vs hero
  interacted: new Set(),    // who engaged vs hero

  nodes: {},            // seat -> {seat, stack, pos}
  heroCardsHolder: null,

  evLoss: 0,
  snapshot: null
};

/* ===== Layout seats on ring ===== */
function layoutSeats(){
  seatsLayer.innerHTML="";
  S.nodes = {};
  const N = seatsOrder.length;
  const R = (tableEl.clientWidth/2) - 110;
  const off = -90; // rotate ring

  for(let i=0;i<N;i++){
    const name = seatsOrder[i];
    const a = (off + (360/N)*i) * Math.PI/180;
    const x = 50 + (R*Math.cos(a)) / (tableEl.clientWidth/100);
    const y = 50 + (R*Math.sin(a)) / (tableEl.clientHeight/100);

    const seat = document.createElement("div");
    seat.className = "seat" + (name===S.hero ? " hero" : "");
    seat.style.left = x+"%";
    seat.style.top  = y+"%";
    seat.textContent = name;

    const st = document.createElement("div");
    st.className = "stack";
    st.id = `stack-${name}`;
    st.textContent = "—";
    seat.appendChild(st);

    seatsLayer.appendChild(seat);
    S.nodes[name] = { seat, stack: st, pos:{x,y}, label:name };
  }
}
function setHeroHighlight(){
  seatsOrder.forEach(seat=>{
    S.nodes[seat]?.seat.classList.toggle("hero", seat===S.hero);
  });
}
function setActing(seat, on){
  const n=S.nodes[seat]; if(!n) return;
  n.seat.classList.toggle("acting", !!on);
  if(on){ setTimeout(()=>n.seat.classList.remove("acting"), 1500); }
}
function markFold(seat){
  const n=S.nodes[seat]; if(!n) return;
  n.seat.classList.add("folded");
  const backup = n.seat.textContent;
  n.seat.textContent = "FOLD";
  setTimeout(()=>{ if(S.folded[seat]) { n.seat.textContent = "FOLD"; } else { n.seat.textContent = backup; } }, 1200);
}

/* ===== Board / HUD / stacks ===== */
function renderBoard(){
  boardEl.innerHTML="";
  S.board.forEach(c=> boardEl.appendChild(makeCardEl(c,true)));
}
function renderHeroCards(){
  // remove previous
  if(S.heroCardsHolder){ S.heroCardsHolder.remove(); S.heroCardsHolder=null; }

  const n=S.nodes[S.hero]; if(!n) return;
  const holder = document.createElement("div");
  holder.className = "hero-cards";
  holder.style.left = `${n.pos.x}%`;
  holder.style.top  = `calc(${n.pos.y}% - 16px)`;
  (S.hands[S.hero]||[]).forEach(c => holder.appendChild(makeCardEl(c,false)));
  tableEl.appendChild(holder);
  S.heroCardsHolder = holder;
}
function updateStacksUI(){
  seatsOrder.forEach(s=>{
    const node=S.nodes[s]; if(!node) return;
    node.stack.textContent = `${S.stacks[s].toFixed(1)} BB`;
  });
}
function renderHUD(){
  hudStreet.textContent = streetNames[S.street];
  hudPot.textContent    = `Pot: ${S.pot.toFixed(1)} BB`;
  const live = seatsOrder.filter(s=> !S.folded[s]);
  const eff  = live.length ? Math.min(...live.map(s=>Math.max(0.1,S.stacks[s]))) : 100;
  const spr  = (eff/Math.max(1,S.pot)).toFixed(1);
  hudSPR.textContent     = `SPR: ${spr}`;
}
function setPrompt(txt){
  promptEl.textContent = txt || `${streetNames[S.street]}: ${S.hero}, your action.`;
}

/* ===== Plates (bets/calls) in front of player ===== */
function plate(seat, label){
  const n=S.nodes[seat]; if(!n) return;
  const el = document.createElement("div");
  el.className = "bet-plate";
  el.style.left = n.seat.style.left;
  const y = parseFloat(n.seat.style.top);
  el.style.top = `calc(${y}% - 54px)`;
  el.innerHTML = `<span class="chip-icon"></span><span>${label}</span>`;
  floatLayer.appendChild(el);
  setTimeout(()=>el.remove(), 1800);
}

/* ===== Accounting (blinds, calls, min-raise rules) ===== */
function resetCommitted(){
  seatsOrder.forEach(s=> S.committed[s]=0);
  S.currentBetTotal = 0;
  S.lastRaiseSize   = 0; // becomes 1st increment when someone raises above BB
}
function streetInit(){
  resetCommitted();
  if(S.street==="preflop"){
    // post blinds
    payTo("SB", 0.5);
    payTo("BB", 1.0);
    S.currentBetTotal = 1.0;    // CB starts at 1 (big blind)
    S.lastRaiseSize   = 1.0;    // LRS base for first legal raise (min to 2BB total)
  }
  renderHUD();
}
function toCall(seat){ return Math.max(0, S.currentBetTotal - S.committed[seat]); }
function payTo(seat, target){
  const need = Math.max(0, target - S.committed[seat]);
  if(need<=0) return 0;
  const can = S.stacks[seat];
  const pay = Math.min(need, can);
  S.stacks[seat]     = +(S.stacks[seat]-pay).toFixed(1);
  S.committed[seat]  = +(S.committed[seat]+pay).toFixed(1);
  S.pot              = +(S.pot+pay).toFixed(1);
  updateStacksUI(); renderHUD();
  return pay;
}
function canRaiseTo(newTotal){
  // legal if newTotal >= currentBet + lastRaiseSize (or > currentBet if first bet postflop)
  const min = (S.currentBetTotal===0 && S.street!=="preflop") ? 1 : (S.currentBetTotal + Math.max(S.lastRaiseSize, (S.street==="preflop"?1:1)));
  return newTotal >= min - 1e-9;
}
function registerRaise(newTotal, raiser){
  const prevCB = S.currentBetTotal;
  const delta  = newTotal - prevCB;

  // All-in exception: if the raiser couldn't reach min raise, it counts as a call/short raise that DOES NOT reset LRS
  if(newTotal <= prevCB || delta < Math.max(S.lastRaiseSize, (S.street==="preflop"?1:1))){
    // treated as a call (or short all-in), no LRS update
    return;
  }
  S.lastRaiseSize = delta;
  S.currentBetTotal = newTotal;
}

/* ===== Streets ===== */
async function dealFlop(){
  const taken = new Set(Object.values(S.hands).flat().concat(S.board));
  S.board = dealUnique(3, taken);
  S.street="flop";
  streetInit(); renderBoard(); renderHUD();
  await sleep(400);
}
async function dealTurn(){
  const taken = new Set(Object.values(S.hands).flat().concat(S.board));
  S.board.push(...dealUnique(1, taken));
  S.street="turn";
  streetInit(); renderBoard(); renderHUD();
  await sleep(400);
}
async function dealRiver(){
  const taken = new Set(Object.values(S.hands).flat().concat(S.board));
  S.board.push(...dealUnique(1, taken));
  S.street="river";
  streetInit(); renderBoard(); renderHUD();
  await sleep(400);
}

/* ===== Simplified GTO-ish policy (frequency mixes) ===== */
function pfStrength(cards){
  const [a,b]=cards;
  const rA=RANKS.indexOf(a[0]), rB=RANKS.indexOf(b[0]);
  const pair = a[0]===b[0]; const suited = a[1]===b[1]; const gap=Math.abs(rA-rB);
  let s = pair ? (100 - rA*3) : (100 - Math.min(rA,rB)*4) + (suited?6:0) + (gap<=1?6:0);
  return s + rnd()*1.5;
}
function postStrength(cards, board){
  const ranks = board.map(c=>c[0]);
  const hi = ranks.filter(r=>["A","K","Q","J","T"].includes(r)).length*2;
  const pair = ranks.some(r=> r===cards[0][0] || r===cards[1][0]) ? 8 : 0;
  const suit = (cards[0][1]===cards[1][1]) ? 3 : 0;
  return hi + pair + suit + rnd()*2;
}
function npcPolicy(seat){
  // returns action family key and (if bet/raise) a target total
  if(S.folded[seat] || S.allin[seat]) return {key:"check"};
  const eff = S.stacks[seat] + S.committed[seat];
  if (eff<=0) return {key:"check"};

  const need = toCall(seat);
  if(S.street==="preflop"){
    const s = pfStrength(S.hands[seat]);
    if(need>0){
      if(s<68 && rnd()<0.75) return {key:"fold"};
      if(s>90 && rnd()<0.5){
        // 3-bet to ~ 2.8x current
        const target = Math.max(S.currentBetTotal + S.lastRaiseSize, S.currentBetTotal*2.8);
        return {key:"raise", to: clampToStack(seat,target)};
      }
      return {key:"call"};
    }else{
      // unopened pot
      if(s>86) return {key:"raise", to: clampToStack(seat, Math.max(2.5, 3.0))};
      if(s>74 && rnd()<0.45) return {key:"raise", to: clampToStack(seat, 2.5)};
      if(rnd()<0.12) return {key:"raise", to: clampToStack(seat, 2.2)};
      return {key:"check"};
    }
  } else {
    const s = postStrength(S.hands[seat], S.board);
    if(need>0){
      if(s<9 && rnd()<0.35) return {key:"fold"};
      if(s>16 && rnd()<0.35){
        const raiseTo = S.currentBetTotal + Math.max(2, Math.round(S.pot*0.4));
        return {key:"raise", to: clampToStack(seat, raiseTo)};
      }
      return {key:"call"};
    }else{
      // open
      if(s>16) return {key:"bet", to: clampToStack(seat, Math.max(2, Math.round(S.pot*0.66)))};
      if(s>12 && rnd()<0.6) return {key:"bet", to: clampToStack(seat, Math.max(2, Math.round(S.pot*0.5)))};
      if(s>8 && rnd()<0.35) return {key:"bet", to: clampToStack(seat, Math.max(2, Math.round(S.pot*0.33)))};
      return {key:"check"};
    }
  }
}
function clampToStack(seat, targetTotal){
  // target is TOTAL to reach; cannot exceed committed+stack
  const maxTotal = S.committed[seat] + S.stacks[seat];
  return Math.min(targetTotal, maxTotal);
}

/* ===== Scoring (EV penalties → % score) ===== */
function evPenalty(street, heroActionKey, optimalKey){
  if(heroActionKey===optimalKey) return 0;
  const fam = (k)=> k==="raise"||k==="bet"||k==="jam" ? k : (k==="call"||k==="check"||k==="fold"?k:"other");
  const base = {
    preflop: {fold:.9, call:.55, raise:.65, bet:.65, jam:1.25, check:.2},
    flop:    {check:.22, bet:.38, call:.35, raise:.6, jam:.75, fold:.4},
    turn:    {check:.27, bet:.5,  call:.45, raise:.75, jam:.9,  fold:.45},
    river:   {check:.33, bet:.62, call:.55, raise:.9,  jam:1.05, fold:.5}
  };
  let w = base[street][fam(heroActionKey)] ?? .5;

  // better junk-fold recognition preflop
  if(street==="preflop" && heroActionKey==="fold"){
    const s = pfStrength(S.hands[S.hero]);
    if(s<66) return 0;               // folding 9/2o type → perfect
    if(s<74) w *= .35;               // reasonable fold
  }

  // dumb jam penalty
  if(heroActionKey==="jam"){
    if(street==="preflop"){
      const s = pfStrength(S.hands[S.hero]);
      if(s<78) w += 1.0;
      else if(s<86) w += .6;
    } else {
      const s = postStrength(S.hands[S.hero], S.board);
      if(s<14) w += .8;
    }
  }

  // family mismatch adds a bit
  if(fam(heroActionKey) !== fam(optimalKey)) w += .25;

  return +(w + rnd()*0.1).toFixed(2);
}
function liveScore(){ return Math.max(0, Math.min(100, Math.round(100 - S.evLoss*25))); }
function verdict(p){ return p>=85?"Excellent":p>=70?"Strong":p>=50?"Okay":"Needs Work"; }

/* ===== Helpers ===== */
function clearActions(){ actionsEl.innerHTML=""; }
function addBtn(txt, cls, cb, dis=false){
  const b=document.createElement("button");
  b.className="btn "+cls; b.textContent=txt; b.onclick=cb; b.disabled=!!dis;
  actionsEl.appendChild(b); return b;
}

/* ===== Hero options ===== */
function betCandidates(){
  if(S.street==="preflop"){
    // suggest standard opens/3bets
    const isFacing = S.currentBetTotal> (S.street==="preflop"?1.0:0);
    if(!isFacing) return [2.2, 2.5, 3.0];
    // facing: propose to some multiple of current
    return [S.currentBetTotal + S.lastRaiseSize, S.currentBetTotal*2.2, S.currentBetTotal*2.8].map(x=>+x.toFixed(1));
  }else{
    const p = Math.max(2, S.pot);
    return [Math.round(p*0.33), Math.round(p*0.5), Math.round(p*0.66)];
  }
}
function offerHero(){
  clearActions();
  const need = toCall(S.hero);
  const eff  = S.stacks[S.hero];
  const sizes = betCandidates();

  // Always allow Fold
  addBtn("Fold","ghost",()=>heroActs({key:"fold"}));

  if(S.street!=="preflop" && S.currentBetTotal===0){
    addBtn("Check","ghost",()=>heroActs({key:"check"}));
  } else if (S.street==="preflop" && S.currentBetTotal <= 1.0 && S.committed[S.hero] >= 1.0) {
    // BB may check when unopened
    addBtn("Check","ghost",()=>heroActs({key:"check"}));
  }

  if(need>0 && eff>0){
    addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`, "primary", ()=>heroActs({key:"call"}));
  }

  sizes.forEach(to=>{
    const total = clampToStack(S.hero, Math.max(to, (S.street==="preflop" && S.currentBetTotal<1? 2.0 : to)));
    const isRaiseFamily = (S.street==="preflop" ? true : (S.currentBetTotal>0));
    const label = isRaiseFamily ? `Raise to ${total.toFixed(1)} BB` : `Bet ${total.toFixed(1)} BB`;
    const legal = isRaiseFamily ? canRaiseTo(total) : (total>=1);
    const dis = (eff<=0) || !legal;
    addBtn(label, "primary", ()=>heroActs({key:(isRaiseFamily?"raise":"bet"), to: total}), dis);
  });

  if(eff>0){
    addBtn("All-in","danger",()=>heroActs({key:"jam"}));
  }
}

/* ===== Optimal alias (for grading) ===== */
function heroOptimal(){
  const need = toCall(S.hero);
  if(S.street==="preflop"){
    const s = pfStrength(S.hands[S.hero]);
    if(need>0){
      if(s<68) return "fold";
      if(s>90) return "raise";
      return "call";
    } else {
      if(s>86) return "raise";
      if(s>74 && rnd()<0.5) return "raise";
      return "check";
    }
  } else {
    const s = postStrength(S.hands[S.hero], S.board);
    if(need>0){
      if(s<9) return "fold";
      if(s>16) return "raise";
      return "call";
    } else {
      if(s>16) return "bet";
      if(s>12 && rnd()<0.5) return "bet";
      return "check";
    }
  }
}

/* ===== Resolve an action (generic) ===== */
function doFold(seat){
  S.folded[seat]=true;
  markFold(seat);
}
function doCall(seat){
  const need = toCall(seat);
  const paid = payTo(seat, S.currentBetTotal);
  if(paid>0) plate(seat, (paid>=S.stacks[seat]+paid?"Call all-in":`Call ${paid.toFixed(1)} BB`));
}
function doBetOrRaise(seat, toTotal){
  const minOk = canRaiseTo(toTotal) || (S.currentBetTotal===0 && S.street!=="preflop");
  const prev = S.currentBetTotal;

  // treat as bet if no previous bet postflop
  const family = (S.street!=="preflop" && prev===0) ? "bet" : "raise";

  const total = Math.max(toTotal, (family==="raise"? S.currentBetTotal + S.lastRaiseSize : toTotal));
  const clamped = clampToStack(seat, total);

  S.currentBetTotal = Math.max(S.currentBetTotal, clamped);
  payTo(seat, S.currentBetTotal);

  // update LRS if a legitimate raise (not short all-in)
  if(family==="raise") registerRaise(S.currentBetTotal, seat);

  const add = Math.max(0, S.currentBetTotal - prev);
  plate(seat, (S.committed[seat] >= S.stacks[seat]+S.committed[seat] ? "All-in" : `${family==="bet"?"Bet":"Raise"} ${Math.max(1, add).toFixed(1)} BB`));
}

/* ===== NPC sequencing (table always acts in the correct order) ===== */
async function preflopSequenceUntilHeroTurn(){
  // Preflop order: UTG -> ... -> BTN -> SB -> BB  (hero may be anywhere; we always progress from UTG)
  for(const seat of seatsOrder){
    if(seat===S.hero) return; // stop before hero action
    if(S.folded[seat]) continue;
    setActing(seat,true);
    await sleep(300);
    const a = npcPolicy(seat);
    if(a.key==="fold"){ doFold(seat); }
    else if(a.key==="check"){ /* unopened only */ }
    else if(a.key==="call"){ doCall(seat); S.interacted.add(seat); }
    else if(a.key==="raise"){ doBetOrRaise(seat, a.to); S.interacted.add(seat); }
    else if(a.key==="bet"){   doBetOrRaise(seat, a.to); S.interacted.add(seat); }
    setActing(seat,false);
    await sleep(250);
  }
}
async function postflopSequenceUntilHeroTurn(){
  // Postflop order: SB first (or next live clockwise) … BTN last
  const startIdx = seatsOrder.indexOf("SB");
  for(let k=0;k<seatsOrder.length;k++){
    const i = (startIdx + k) % seatsOrder.length;
    const seat = seatsOrder[i];
    if(seat===S.hero) return; // pause for hero
    if(S.folded[seat]) continue;
    setActing(seat,true);
    await sleep(300);
    const a = npcPolicy(seat);
    if(a.key==="fold"){ doFold(seat); }
    else if(a.key==="check"){ /* ok */ }
    else if(a.key==="call"){ doCall(seat); S.interacted.add(seat); }
    else if(a.key==="raise"){ doBetOrRaise(seat, a.to); S.interacted.add(seat); }
    else if(a.key==="bet"){   doBetOrRaise(seat, a.to); S.interacted.add(seat); }
    setActing(seat,false);
    await sleep(250);
  }
}

/* ===== End-of-street logic ===== */
function everyoneMatchedOrFolded(){
  const live = seatsOrder.filter(s=>!S.folded[s] && !S.allin[s]);
  if(live.length===0) return true;
  // All active either matched the currentBetTotal, or there was no bet and everyone checked
  const allEqual = seatsOrder.every(s => S.folded[s] || S.committed[s]===S.currentBetTotal || S.allin[s]);
  return allEqual;
}

/* ===== Finish hand (score + sidebar + log + reset buttons) ===== */
function showdownReveal(){
  S.showdownSet = new Set(
    seatsOrder.filter(s => s!==S.hero && !S.folded[s] && S.interacted.has(s))
  );
  revealSeat(S.hero);
  S.showdownSet.forEach(s=> revealSeat(s));
}
function revealSeat(seat){
  if(S.folded[seat]) return;
  if(seat!==S.hero && !S.showdownSet.has(seat)) return;
  const n=S.nodes[seat]; if(!n) return;
  const holder = document.createElement("div");
  holder.style.position="absolute";
  holder.style.left = n.seat.style.left;
  holder.style.top  = n.seat.style.top;
  holder.style.transform="translate(-50%,-115%)";
  holder.style.display="flex"; holder.style.gap="8px"; holder.style.zIndex=70;
  S.hands[seat].forEach(c=> holder.appendChild(makeCardEl(c,false)));
  floatLayer.appendChild(holder);
}
function endNow(){
  // score
  const pct = Math.max(0, Math.min(100, Math.round(100 - S.evLoss*25)));
  resultBox.style.display="block";
  scorePctEl.textContent = `${pct}%`;
  scoreVerdEl.textContent = verdict(pct);
  scorePctEl.style.color = pct>=50? "var(--good)" : "var(--bad)";

  // log
  const row=document.createElement("div");
  row.className="item";
  row.innerHTML = `<div><b>${S.hero}</b> • ${streetNames[S.street]}</div>
                   <div class="${pct>=50?"ok":"bad"}">${pct}% ${pct>=50?"✅":"❌"}</div>`;
  logEl.prepend(row);

  // show “Next Hand” only (and replay icon would go here if you store a snapshot)
  clearActions();
  addBtn("Next Hand","primary", startNewHand);
}

/* ===== Hero acts (hand can end immediately after hero path) ===== */
async function heroActs(action){
  // grade vs optimal family
  const opt = heroOptimal();
  const fam = action.key;
  S.evLoss += evPenalty(S.street, fam, opt);
  if(S.evLoss < 0) S.evLoss = 0;

  if(fam==="fold"){
    doFold(S.hero);
    // if hero folds at any sequence depth → hand ends right now
    endNow();
    return;
  }
  if(fam==="check"){
    plate(S.hero,"Check");
  }
  if(fam==="call"){
    doCall(S.hero);
  }
  if(fam==="raise" || fam==="bet"){
    const to = action.to ?? (S.currentBetTotal + S.lastRaiseSize);
    doBetOrRaise(S.hero, to);
    S.interacted.add(S.hero);
  }
  if(fam==="jam"){
    const to = S.committed[S.hero] + S.stacks[S.hero];
    doBetOrRaise(S.hero, to);
    S.allin[S.hero] = true;
    S.interacted.add(S.hero);
  }

  // After hero acts:
  // If hero is all-in or sequence says stop after this street and all calls are in → we can end.
  // Otherwise let the table react, then if end-of-street reached, advance a street unless sequence end or hero is done.
  await tableReactAfterHero();

  // If hero cannot act anymore (folded or sequence limit reached), finish
  if(S.folded[S.hero]) return; // already ended via endNow()
}
async function tableReactAfterHero(){
  // Let remaining players act to close the action
  const order = (S.street==="preflop")
    ? seatsOrder.slice(seatsOrder.indexOf(S.hero)+1).concat(seatsOrder.slice(0,seatsOrder.indexOf(S.hero)))
    : seatsOrder.slice(seatsOrder.indexOf("SB")).concat(seatsOrder.slice(0,seatsOrder.indexOf("SB")));

  for(const seat of order){
    if(seat===S.hero) continue;
    if(S.folded[seat]) continue;
    // If already everyone matched, stop
    if(everyoneMatchedOrFolded()) break;

    setActing(seat,true);
    await sleep(250);
    const a = npcPolicy(seat);
    if(a.key==="fold"){ doFold(seat); }
    else if(a.key==="check"){ plate(seat,"Check"); }
    else if(a.key==="call"){ doCall(seat); S.interacted.add(seat); }
    else if(a.key==="raise"){ doBetOrRaise(seat, a.to); S.interacted.add(seat); }
    else if(a.key==="bet"){   doBetOrRaise(seat, a.to); S.interacted.add(seat); }
    setActing(seat,false);
    await sleep(200);
  }

  // If not everyone matched yet, it's back to hero (offer buttons again)
  if(!everybodyDoneThisStreet()){
    offerHero(); return;
  }

  // Street is closed — advance or finish based on sequence
  if(S.sequence==="preflop" && S.street==="preflop"){
    // We stop here (but if multiple in & not folded hero — reveal showdown for preflop sequence only if all-in; otherwise grade immediately)
    endNow(); return;
  }

  if(S.street==="preflop"){
    await dealFlop();
    // Preflop → Flop: table acts until hero then offer hero
    await postflopSequenceUntilHeroTurn();
    offerHero(); return;
  }

  if(S.sequence==="turn" && S.street==="turn"){
    endNow(); return;
  }

  if(S.street==="flop"){
    await dealTurn();
    await postflopSequenceUntilHeroTurn();
    offerHero(); return;
  }

  if(S.street==="turn"){
    await dealRiver();
    // On river we still need hero to act at least once if action reaches them
    await postflopSequenceUntilHeroTurn();
    offerHero(); return;
  }

  if(S.street==="river"){
    // River ended with hero action path completed → showdown only if needed
    showdownReveal();
    endNow(); return;
  }
}
function everybodyDoneThisStreet(){
  // Consider calling the street closed when all active (not folded) players have matched CBT or are all-in,
  // OR when no one has bet and action has checked through once around (handled by calling order + equality check).
  return seatsOrder.every(s => S.folded[s] || S.committed[s]===S.currentBetTotal || S.allin[s]);
}

/* ===== Scenario presets (who opens / who folds) ===== */
function applyScenario(){
  if(S.scenario==="none") return;

  // Convenience: auto folds to create HU-ish entries per scenario
  const foldExcept = new Set();
  if(S.scenario==="bvb"){ foldExcept.add("SB"); foldExcept.add("BB"); }
  if(S.scenario==="btn_vs_bb"){ foldExcept.add("BTN"); foldExcept.add("BB"); }
  if(S.scenario==="co_vs_bb"){ foldExcept.add("CO"); foldExcept.add("BB"); }
  if(S.scenario==="utg_vs_bb"){ foldExcept.add("UTG"); foldExcept.add("BB"); }
  if(S.scenario==="sb_vs_bb"){ foldExcept.add("SB"); foldExcept.add("BB"); }
  if(S.scenario==="hj_vs_co"){ foldExcept.add("HJ"); foldExcept.add("CO"); }

  seatsOrder.forEach(s=>{
    if(!foldExcept.has(s) && s!=="SB" && s!=="BB") S.folded[s]=true;
  });

  // If SB/BB are the only ones, keep them live; action sequencing will handle opens
}

/* ===== New hand ===== */
async function startNewHand(){
  // reset UI
  resultBox.style.display="none";
  scorePctEl.textContent=""; scoreVerdEl.textContent="";
  floatLayer.innerHTML=""; boardEl.innerHTML=""; actionsEl.innerHTML="";

  // read controls
  S.scenario = scenarioSel.value;
  S.sequence = sequenceSel.value;
  S.hero     = heroSel.value;

  // init stacks/flags
  S.street="preflop";
  S.hands={}; S.board=[]; S.pot=0; S.evLoss=0;
  S.folded={}; S.allin={}; S.interacted=new Set(); S.showdownSet=new Set();
  seatsOrder.forEach(s=>{ S.stacks[s]=100; S.folded[s]=false; S.allin[s]=false; });

  // layout/repaint
  layoutSeats(); setHeroHighlight(); renderHUD(); updateStacksUI();

  // deal hands
  const taken = new Set();
  seatsOrder.forEach(s=> S.hands[s] = dealUnique(2, taken));
  renderHeroCards(); renderBoard();

  // blinds and preflop state
  streetInit();

  // scenario constraints
  applyScenario();

  // If scenario made many folds, reflect labels
  seatsOrder.forEach(s=> { if(S.folded[s]) markFold(s); });

  // Preflop sequence up to hero
  await preflopSequenceUntilHeroTurn();

  // Offer hero choices
  setPrompt();
  offerHero();
}

/* ===== Utilities: reveal on showdown for hero & interacted villains only ===== */
function clearLog(){ logEl.innerHTML=""; localStorage.removeItem("gto_log_v1"); }

/* ===== Wire controls + autoboot ===== */
newBtn.onclick = startNewHand;
clearLogBtn.onclick = clearLog;

(async function boot(){
  seed(Date.now() ^ 0x9e3779b9);
  layoutSeats(); setHeroHighlight(); renderHUD(); updateStacksUI();
  await startNewHand(); // auto-start on load
})();
</script>
</body>
</html>



















