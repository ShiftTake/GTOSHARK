<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>

<title>GTO Shark • Live Practice (GTO Engine)</title>

<style>
:root{
  --bg:#0b1220;
  --ink:#e2e8f0;
  --felt:#0f3d37;
  --felt-hi:#13574f;
  --rail:#162239;
  --rail-glow: rgba(79,70,229,.35);

  --indigo:#4f46e5;
  --teal:#14b8a6;
  --good:#22c55e;
  --warn:#fbbf24;
  --bad:#ef4444;

  --table-size: 900px;
  --seat: 84px;
  --card-w: 88px;
  --card-h: 124px;
  --board-w: 80px;
  --board-h: 112px;
  --rail-width: 12px;
}

*{
  box-sizing:border-box;
  user-select:none;
  -webkit-user-select:none;
}

body{
  margin:0;
  padding:0;
  background:var(--bg);
  font-family:Arial,Helvetica,sans-serif;
  color:var(--ink);
  overflow:hidden;
}

/* ============================================================
   TABLE CONTAINER
============================================================ */
#tableWrap{
  width:100vw;
  height:100vh;
  display:flex;
  justify-content:center;
  align-items:center;
}

#table{
  width:var(--table-size);
  height:var(--table-size);
  background:var(--felt);
  border-radius:50%;
  position:relative;
  box-shadow:0 0 60px rgba(0,0,0,0.6), inset 0 0 40px rgba(0,0,0,0.5);
  border:var(--rail-width) solid var(--rail);
}

/* ============================================================
   SEAT POSITIONS
============================================================ */
.seat{
  width:var(--seat);
  height:var(--seat);
  position:absolute;
  background:var(--rail);
  border-radius:50%;
  display:flex;
  justify-content:center;
  align-items:center;
  box-shadow:0 0 12px var(--rail-glow);
  font-size:14px;
  color:white;
}

#seat-UTG  { top:5%;   left:50%;  transform:translate(-50%,-50%); }
#seat-UTG1 { top:15%;  left:75%;  transform:translate(-50%,-50%); }
#seat-UTG2 { top:35%;  left:90%;  transform:translate(-50%,-50%); }
#seat-LJ   { top:65%;  left:90%;  transform:translate(-50%,-50%); }
#seat-HJ   { top:85%;  left:75%;  transform:translate(-50%,-50%); }
#seat-CO   { top:95%;  left:50%;  transform:translate(-50%,-50%); }
#seat-BTN  { top:85%;  left:25%;  transform:translate(-50%,-50%); }
#seat-SB   { top:65%;  left:10%;  transform:translate(-50%,-50%); }
#seat-BB   { top:35%;  left:10%;  transform:translate(-50%,-50%); }

/* ============================================================
   BOARD + CARDS
============================================================ */
#board{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  display:flex;
  gap:12px;
}

.card{
  width:var(--board-w);
  height:var(--board-h);
  background:#1a2333;
  border-radius:10px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  padding:6px;
  border:2px solid #333;
}

.red{ color:#ff4b5c; }
.black{ color:#e2e8f0; }

.rank{
  font-size:26px;
  font-weight:bold;
}

.suit{
  font-size:22px;
  margin-top:-4px;
}

/* ============================================================
   HERO CARDS
============================================================ */
.heroBox{
  position:absolute;
  bottom:2%;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  gap:20px;
}

.heroCard{
  width:var(--card-w);
  height:var(--card-h);
  background:#1f2b44;
  border-radius:12px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  border:2px solid #465775;
}

/* ============================================================
   BUTTONS / ACTIONS
============================================================ */
#actions{
  position:absolute;
  bottom:2%;
  right:2%;
  display:flex;
  flex-direction:column;
  gap:12px;
}

.actionBtn{
  padding:12px 20px;
  background:var(--indigo);
  color:white;
  border:none;
  border-radius:8px;
  font-size:18px;
  cursor:pointer;
}

.actionBtn:hover{
  background:#6366f1;
}

/* ============================================================
   HUD + RANGE DISPLAY
============================================================ */
#hud{
  position:absolute;
  top:2%;
  left:2%;
  background:#162239;
  padding:14px 20px;
  border-radius:12px;
  box-shadow:0 0 12px rgba(0,0,0,0.4);
  min-width:240px;
}

#rangeBox{
  margin-top:18px;
  padding:12px;
  background:#0f172a;
  border:1px solid #334155;
  border-radius:8px;
  max-height:300px;
  overflow-y:auto;
}

/* ============================================================
   LOG WINDOW
============================================================ */
#log{
  position:absolute;
  right:2%;
  top:2%;
  width:320px;
  height:380px;
  overflow-y:auto;
  background:#111827;
  padding:12px;
  border-radius:12px;
  border:1px solid #374151;
}

.log-row{
  padding:6px 0;
  border-bottom:1px solid #334155;
  display:flex;
  justify-content:space-between;
}

.good{ color:var(--good); }
.bad{ color:var(--bad); }

/* ============================================================
   RESULT / FEEDBACK
============================================================ */
#results{
  display:none;
  position:absolute;
  top:45%;
  left:50%;
  transform:translate(-50%,-50%);
  background:#111827;
  padding:20px 30px;
  border-radius:12px;
  border:1px solid #374151;
  text-align:center;
}

.correct{ color:var(--good); font-size:32px; font-weight:bold; }
.incorrect{ color:var(--bad); font-size:32px; font-weight:bold; }
</style>
</head>

<body>
<div id="tableWrap">
  <div id="table">

    <!-- SEATS -->
    <div id="seat-UTG"  class="seat">UTG</div>
    <div id="seat-UTG1" class="seat">UTG1</div>
    <div id="seat-UTG2" class="seat">UTG2</div>
    <div id="seat-LJ"   class="seat">LJ</div>
    <div id="seat-HJ"   class="seat">HJ</div>
    <div id="seat-CO"   class="seat">CO</div>
    <div id="seat-BTN"  class="seat">BTN</div>
    <div id="seat-SB"   class="seat">SB</div>
    <div id="seat-BB"   class="seat">BB</div>

    <!-- BOARD -->
    <div id="board"></div>

    <!-- HERO CARDS -->
    <div class="heroBox">
      <div id="heroCard1" class="heroCard"></div>
      <div id="heroCard2" class="heroCard"></div>
    </div>

    <!-- ACTION BUTTONS -->
    <div id="actions">
      <button class="actionBtn" onclick="heroAction('fold')">Fold</button>
      <button class="actionBtn" onclick="heroAction('call')">Call</button>
      <button class="actionBtn" onclick="heroAction('raise')">Raise</button>
    </div>

    <!-- HUD -->
    <div id="hud">
      <div><strong>Street:</strong> <span id="hudStreet">Preflop</span></div>
      <div><strong>Pot:</strong> <span id="hudPot">0</span></div>
      <div><strong>Stack:</strong> <span id="hudStack"></span></div>

      <!-- STACK BB SELECTOR -->
      <div style="margin-top:14px;">
        <label><strong>Stack (BB):</strong></label><br/>
        <input id="stackInput" type="range" min="5" max="100" value="40" 
               oninput="updateStackSlider(this.value)"
               style="width:180px;">
        <span id="stackVal">40</span> BB
      </div>

      <div id="rangeBox">
        <strong>GTO Range:</strong>
        <div id="rangeText" style="margin-top:10px; white-space:pre-line;"></div>
      </div>
    </div>

    <!-- LOG -->
    <div id="log"></div>

    <!-- RESULT -->
    <div id="results">
      <div id="resultText"></div>
      <button class="actionBtn" onclick="startHand()" style="margin-top:20px;">Next Hand</button>
    </div>

  </div>
</div>

<script>
/* ============================================================
   GLOBAL STATE
============================================================ */
let deck = [];
let seats = [];
let heroSeat = 0;
let heroPos = "BTN";
let players = 6;

let board = [];
let pot = 0;
let street = "preflop";

let stackSize = 40; // updated by slider
let currentRange = null;

/* ============================================================
   STACK SELECTOR
============================================================ */
function updateStackSlider(v){
  stackSize = Number(v);
  document.getElementById("stackVal").textContent = v;
  document.getElementById("hudStack").textContent = v + " BB";
}
document.getElementById("hudStack").textContent = stackSize+" BB";

/* ============================================================
   CARD + DECK LOGIC
============================================================ */
const ranks = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const suits = ["♠","♥","♦","♣"];

function freshDeck(){
  let d=[];
  for(let r of ranks){
    for(let s of suits){
      d.push({rank:r,suit:s});
    }
  }
  return shuffle(d);
}

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function draw(n){
  return deck.splice(0,n);
}

/* ============================================================
   MAIN GAME FLOW
============================================================ */
function startHand(){
  clearLog();
  hideResult();

  street="preflop";
  pot=0;
  deck=freshDeck();
  board=[];

  seats=[];
  let pos = ["UTG","UTG1","UTG2","LJ","HJ","CO","BTN","SB","BB"];
  pos = pos.slice(9-players);

  pos.forEach(p=>{
    seats.push({
      pos:p,
      hole:draw(2),
      folded:false,
      active:true,
      stack:stackSize
    });
  });

  heroSeat = seats.findIndex(s=>s.pos===heroPos);
  if(heroSeat<0) heroSeat = seats.length-1;

  renderBoard();
  renderHeroCards();
  updateHUD();
  dealFlopLater();
}

function dealFlopLater(){
  setTimeout(()=>{
    board.push(...draw(3));
    street="flop";
    updateHUD();
    renderBoard();
    npcAct();
  },600);
}
/* ============================================================
   DEAL TURN + RIVER
============================================================ */
function dealTurn(){
  board.push(...draw(1));
  street="turn";
  updateHUD();
  renderBoard();
  npcAct();
}

function dealRiver(){
  board.push(...draw(1));
  street="river";
  updateHUD();
  renderBoard();
  npcAct();
}

/* ============================================================
   HUD / DISPLAY
============================================================ */
function updateHUD(){
  document.getElementById("hudStreet").textContent = street.toUpperCase();
  document.getElementById("hudPot").textContent = pot;
  document.getElementById("hudStack").textContent = stackSize + " BB";
}

/* ============================================================
   HERO ACTIONS
============================================================ */
function heroAction(action){
  if(action==="fold"){
    addLog("Hero folds",false);
    showResult(false);
    return;
  }
  if(action==="call"){
    addLog("Hero calls",true);
  }
  if(action==="raise"){
    addLog("Hero raises",true);
  }

  if(street==="flop"){
    dealTurn();
  } else if(street==="turn"){
    dealRiver();
  } else if(street==="river"){
    showdown();
  }
}

/* ============================================================
   SHOWDOWN (Simplified)
============================================================ */
function showdown(){
  addLog("Showdown – (Solver result not needed)",true);
  showResult(true);
}

/* ============================================================
   NPC ACTIONS — GTO SOLVER DRIVEN
============================================================ */
async function npcAct(){
  const pos = seats[0].pos; // For now, first non-hero seat
  const range = await loadSolverRange(pos);
  currentRange = range;

  displayRange(range);

  // NPC logic handled inside solver output
  if(street==="flop"){
    // flop → turn
    dealTurn();
  } else if(street==="turn"){
    // turn → river
    dealRiver();
  } else if(street==="river"){
    showdown();
  }
}

/* ============================================================
   SOLVER RANGE LOADING
============================================================ */
async function loadSolverRange(position){
  if(street==="preflop"){
    return loadPreflopRange(position);
  }
  if(street==="flop"){
    const cls = classifyFlop();
    return loadFlopRange(position,cls);
  }
  if(street==="turn"){
    const cls = classifyTurn();
    return loadTurnRange(position,cls);
  }
  if(street==="river"){
    const cls = classifyRiver();
    return loadRiverRange(position,cls);
  }
}

/* ============================================================
   PRE-FLOP RANGES
============================================================ */
async function loadPreflopRange(position){
  let heroP = heroPos;
  let key = `${position}_vs_${heroP}`;

  const url =
    `https://raw.githubusercontent.com/ShiftTake/GTOSHARK/main/ranges/preflop/${key}.json`;

  try{
    const res = await fetch(url);
    if(!res.ok) return null;
    return await res.json();
  }catch(e){
    console.error("Preflop fetch error",e);
    return null;
  }
}

/* ============================================================
   FLOP RANGES — 7 CATEGORIES
============================================================ */
async function loadFlopRange(position,category){
  const url =
    `https://raw.githubusercontent.com/ShiftTake/GTOSHARK/main/ranges/flop/${position}/${category}.json`;

  try{
    const res = await fetch(url);
    if(!res.ok) return null;
    return await res.json();
  }catch(e){
    console.error("Flop fetch error",e);
    return null;
  }
}

/* ============================================================
   TURN RANGES — 5 CATEGORIES
============================================================ */
async function loadTurnRange(position,category){
  const url =
    `https://raw.githubusercontent.com/ShiftTake/GTOSHARK/main/ranges/turn/${position}/${category}.json`;

  try{
    const res = await fetch(url);
    if(!res.ok) return null;
    return await res.json();
  }catch(e){
    console.error("Turn fetch error",e);
    return null;
  }
}

/* ============================================================
   RIVER RANGES — 4 CATEGORIES
============================================================ */
async function loadRiverRange(position,category){
  const url =
    `https://raw.githubusercontent.com/ShiftTake/GTOSHARK/main/ranges/river/${position}/${category}.json`;

  try{
    const res = await fetch(url);
    if(!res.ok) return null;
    return await res.json();
  }catch(e){
    console.error("River fetch error",e);
    return null;
  }
}

/* ============================================================
   RANGE DISPLAY
============================================================ */
function displayRange(r){
  const box = document.getElementById("rangeText");
  if(!r){
    box.textContent = "(no range data)";
    return;
  }
  box.textContent = JSON.stringify(r,null,2);
}
/* ============================================================
   FLOP CLASSIFICATION — 7 TYPES
   ace_high / high / high_connected / low / low_connected / mono / paired
============================================================ */
function classifyFlop(){
  const c = board.slice(0,3);
  const ranks = c.map(card => rankVal(card.rank)).sort((a,b)=>b-a);
  const suits = c.map(card => card.suit);
  const top = ranks[0];

  const isMono = (suits[0]===suits[1] && suits[1]===suits[2]);

  const isPaired =
    (ranks[0]===ranks[1] || ranks[1]===ranks[2] || ranks[0]===ranks[2]);

  const highConnected =
     (ranks[0]>=11 && ranks[1]>=10);

  const heroHC = heroHighCard();
  const heroHasPair = madeHand();

  if(heroHC===14 && !heroHasPair) return "ace_high";
  if(top>=12 && !heroHasPair) return "high";
  if(highConnected && !heroHasPair) return "high_connected";
  if(isMono) return "mono";
  if(isPaired) return "paired";

  const lowLine = (top <= 11);
  const connected = (Math.max(...ranks) - Math.min(...ranks) <= 4);
  if(lowLine && connected) return "low_connected";

  return "low";
}

/* ============================================================
   TURN CLASSIFICATION — 5 TYPES
   blank / flush_completes / high / pairing / straightening
============================================================ */
function classifyTurn(){
  const t = board[3];

  const ranks = board.map(c=>rankVal(c.rank));
  const suits = board.map(c=>c.suit);

  const flushPossible =
    suitCount(board) >= 3 &&
    suits.filter(s => s === t.suit).length >= 1;

  const paired =
    ranks[3]===ranks[0] ||
    ranks[3]===ranks[1] ||
    ranks[3]===ranks[2];

  const straightening = createsStraight(board);

  if(paired) return "pairing";
  if(flushPossible) return "flush_completes";
  if(rankVal(t.rank)>=11) return "high";
  if(straightening) return "straightening";
  return "blank";
}

/* ============================================================
   RIVER CLASSIFICATION — 4 TYPES
   blank / flush / pairing / straight
============================================================ */
function classifyRiver(){
  const r = board[4];
  const ranks = board.map(c=>rankVal(c.rank));
  const suits = board.map(c=>c.suit);

  const flush =
    suitCount(board)>=3 &&
    suits.filter(s=>s===r.suit).length>=1;

  const paired =
    ranks.includes(rankVal(r.rank)) &&
    board.slice(0,4).some(c=>c.rank===r.rank);

  const straight = completesStraight(board);

  if(flush) return "flush";
  if(paired) return "pairing";
  if(straight) return "straight";
  return "blank";
}

/* ============================================================
   CARD + SUIT HELPERS
============================================================ */
function rankVal(r){
  return {A:14,K:13,Q:12,J:11,T:10}[r] || Number(r);
}

function heroHighCard(){
  const h = seats[heroSeat].hole;
  const r1 = rankVal(h[0].rank);
  const r2 = rankVal(h[1].rank);
  return Math.max(r1,r2);
}

function madeHand(){
  const h = seats[heroSeat].hole;
  const ranks = board.map(c=>c.rank);
  return ranks.includes(h[0].rank) || ranks.includes(h[1].rank);
}

function suitCount(cards){
  const map = {};
  cards.forEach(c => map[c.suit] = (map[c.suit] || 0)+1);
  return Math.max(...Object.values(map));
}

function createsStraight(b){
  const r = [...new Set(b.map(c=>rankVal(c.rank)))].sort((a,b)=>a-b);
  for(let i=0;i<r.length-2;i++){
    if(r[i+2]-r[i]===2) return true;
  }
  return false;
}

function completesStraight(b){
  const r = [...new Set(b.map(c=>rankVal(c.rank)))].sort((a,b)=>a-b);
  for(let i=0;i<r.length-4;i++){
    if(r[i+4]-r[i]===4) return true;
  }
  return false;
}

/* ============================================================
   RENDER BOARD + CARDS
============================================================ */
function renderBoard(){
  const box = document.getElementById("board");
  box.innerHTML = "";
  board.forEach(c=>{
    const el=document.createElement("div");
    el.className="card board-card";
    el.innerHTML = formatCard(c);
    box.appendChild(el);
  });
}

function formatCard(c){
  const red = (c.suit==="♥" || c.suit==="♦");
  return `
    <div class="rank ${red?'red':'black'}">${c.rank}</div>
    <div class="suit ${red?'red':'black'}">${c.suit}</div>
  `;
}

/* ============================================================
   RENDER HERO CARDS
============================================================ */
function renderHeroCards(){
  const h = seats[heroSeat].hole;
  document.getElementById("heroCard1").innerHTML = formatCard(h[0]);
  document.getElementById("heroCard2").innerHTML = formatCard(h[1]);
}

/* ============================================================
   LOGGING + FEEDBACK
============================================================ */
function addLog(msg,isGood){
  const row=document.createElement("div");
  row.className="log-row";
  row.innerHTML = `
    <span>${msg}</span>
    <span class="${isGood?'good':'bad'}">●</span>
  `;
  document.getElementById("log").prepend(row);
}

function clearLog(){
  document.getElementById("log").innerHTML="";
}

function showResult(isCorrect){
  const box=document.getElementById("results");
  const text=document.getElementById("resultText");
  if(isCorrect){
    text.innerHTML = `<div class="correct">Correct!</div>`;
  } else {
    text.innerHTML = `<div class="incorrect">Incorrect</div>`;
  }
  box.style.display="block";
}

function hideResult(){
  const box=document.getElementById("results");
  box.style.display="none";
}
/* ============================================================
   COMPLETE ACTION ENGINE (TURN → RIVER → SHOWDOWN)
============================================================ */

// Already handled in previous parts (npcAct(), heroAction(), etc.)
// Now we add any final sanity helpers or stubs if needed.


/* ============================================================
   START A NEW HAND (Final Override Ensuring All Systems Sync)
============================================================ */
function fullResetAndStart() {
  clearLog();
  hideResult();

  street = "preflop";
  pot = 0;

  deck = freshDeck();
  board = [];

  seats = [];
  let posOrder = ["UTG","UTG1","UTG2","LJ","HJ","CO","BTN","SB","BB"];
  let activeOrder = posOrder.slice(9 - players);

  activeOrder.forEach(p => {
    seats.push({
      pos: p,
      hole: draw(2),
      folded: false,
      active: true,
      stack: stackSize
    });
  });

  heroSeat = seats.findIndex(s => s.pos === heroPos);
  if (heroSeat < 0) heroSeat = seats.length - 1;

  renderBoard();
  renderHeroCards();
  updateHUD();

  // Delay flop so animation feels natural
  setTimeout(() => {
    board.push(...draw(3));
    street = "flop";
    updateHUD();
    renderBoard();
    npcAct();
  }, 500);
}

/* ============================================================
   OPTIONAL: Replace old startHand() calls
============================================================ */
function startHand() {
  fullResetAndStart();
}

/* ============================================================
   TABLE INITIALIZATION
============================================================ */
window.onload = () => {
  startHand();
};
</script>

</body>
</html>


