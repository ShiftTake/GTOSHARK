<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GTO Shark • Live Practice — Vanilla</title>
<style>
  :root{
    --bg:#0b1220;
    --ink:#e2e8f0;
    --indigo:#4f46e5;
    --teal:#14b8a6;
    --hero:#22c55e;
    --act:#fbbf24;
    --felt-deep:#0c2b21;
    --felt-mid:#0f3a2c;
    --felt-hi:#15543f;
    --rail:#1d2b44;
    --rail-glow:#7c83ff40;
    --plate:#0d1424;
  }
  html,body{height:100%}
  body{
    margin:0;
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
    color:var(--ink);
    background:
      radial-gradient(1200px 800px at 50% 30%, var(--rail-glow), transparent 60%),
      radial-gradient(1200px 900px at 50% 100%, #0a0f1c, #05070d 70%);
    overflow-x:hidden;
  }

  /* --- Layout --- */
  .app{
    display:grid;
    grid-template-columns:minmax(760px,1fr) 360px;
    gap:14px;
    padding:14px;
  }
  @media (max-width:1100px){
    .app{grid-template-columns:1fr}
    aside{order:3}
  }

  header{
    display:flex;flex-wrap:wrap;gap:10px;
    align-items:flex-end;justify-content:space-between;
    padding:12px 14px;margin:6px 14px 0;
    background:#0b1220cc;border:1px solid #22304a;border-radius:12px;
    backdrop-filter: blur(4px);
  }
  .h-left h1{margin:0;font-size:22px;font-weight:900;color:#c7ceff}
  .h-left p{margin:4px 0 0;color:#9fb2cc;font-size:12px}

  .ctrls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .ctrls label{font-size:11px;color:#9fb2cc;margin-right:4px}
  .sel, .btn{
    background:#101a30;border:1px solid #32415f;color:#dee5ff;
    padding:8px 10px;border-radius:10px;font-weight:700
  }
  .btn-primary{background:var(--indigo);border-color:#5a66f0}
  .btn-ghost{background:#0f2d2a;border-color:#1f5c56;color:#8ee9da}
  .btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);border-color:#dc2626;color:#fff}

  /* --- Table / Felt --- */
  .table-wrap{display:flex;justify-content:center}
  .table{
    position:relative;
    width:820px;height:820px;border-radius:50%;
    background:
      radial-gradient(420px 380px at 50% 50%, var(--felt-hi), var(--felt-mid) 52%, var(--felt-deep) 100%),
      repeating-radial-gradient(circle at 50% 50%, #ffffff09 0 2px, #00000000 2px 4px);
    box-shadow:
      inset 0 0 0 10px #152038,
      0 0 0 16px #0e1526,
      0 0 80px #0a1020 inset,
      0 40px 160px #0007;
    border:8px solid #2b3a5a;
  }
  .rail-glow{
    position:absolute;inset:0;border-radius:50%;
    box-shadow:0 0 48px 8px #5b63ff33 inset;
    pointer-events:none;
  }

  /* --- HUD --- */
  .hud{
    position:absolute;left:50%;top:44%;transform:translate(-50%,-50%);
    display:flex;gap:10px;align-items:center;
    background:#0b1220b0;border:1px solid #2a3b59;color:#c8d0ff;
    padding:8px 12px;border-radius:10px;font-weight:900;z-index:40
  }
  .hud .sep{opacity:.55}

  /* --- Board / Cards --- */
  .board{position:absolute;left:50%;top:51%;transform:translate(-50%,-50%);display:flex;gap:8px;z-index:38}
  .card{
    width:88px;height:124px;border-radius:14px;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:linear-gradient(155deg,#fff 0%,#f4f6ff 58%,#e6e9ff 100%);
    border:2px solid #6d73ff;
    box-shadow:0 12px 26px rgba(0,0,0,.35);
  }
  .board .card{width:78px;height:110px}
  .rank{font-size:42px;font-weight:900;line-height:1}
  .suit{font-size:30px;margin-top:2px}
  .red{color:#ef4444}.black{color:#0f172a}

  /* --- Seats --- */
  .seats{position:absolute;inset:0}
  .seat{
    position:absolute;transform:translate(-50%,-50%);
    width:86px;height:86px;border-radius:50%;
    display:flex;align-items:center;justify-content:center;
    background:#132039;border:2px solid #2c3c58;color:#9fb2cc;font-size:12px;font-weight:900;text-transform:uppercase;
    box-shadow:0 6px 16px rgba(0,0,0,.35);
    transition:.2s;
  }
  .seat.hero{border-color:#27d164;color:#cbffd7;box-shadow:0 0 22px #21d16466}
  .seat.acting{border-color:#fbbf24;color:#fde68a;box-shadow:0 0 24px #fbbf2488}
  .seat.folded{filter:grayscale(.7);opacity:.75;border-color:#394a6b;color:#6e7f99}
  .stack{
    position:absolute;left:50%;top:calc(100% + 16px);transform:translateX(-50%);
    background:#0b1220;border:1px solid #5e6fcc;color:#cbd5ff;padding:2px 8px;border-radius:999px;font-size:12px;white-space:nowrap;
  }
  .hero-cards{
    position:absolute;z-index:60;display:flex;gap:10px;
    transform:translate(-50%,-58%);
  }

  /* --- Persistent Bet Plates --- */
  .plate{
    position:absolute;transform:translate(-50%,-38px);
    min-width:50px;display:flex;gap:6px;align-items:center;justify-content:center;
    background:linear-gradient(135deg,#17243c,#0e1729);
    border:1px solid #5e6fcc;color:#dbe3ff;padding:4px 8px;border-radius:10px;font-weight:900;font-size:12px;
    box-shadow:0 8px 18px rgba(0,0,0,.35);
    pointer-events:none;
  }
  .chip{
    width:14px;height:14px;border-radius:9999px;display:inline-block;
    background:
      radial-gradient(circle at 50% 50%, #f59e0b 0 28%, #7c3aed 30% 34%, #f59e0b 37% 62%, #7c3aed 64% 68%, #f59e0b 70%);
    border:1px solid #f59e0b;
    box-shadow:0 0 0 1px #6c38e0 inset;
  }

  /* --- Panels --- */
  .panel{background:#0b1220;border:1px solid #22304a;border-radius:12px;padding:12px}
  .muted{color:#9fb2cc}
  .actions{display:flex;flex-wrap:wrap;gap:8px}
  .btn{cursor:pointer}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .result{background:linear-gradient(135deg,var(--indigo),var(--teal));border-radius:12px;color:#fff;padding:14px;box-shadow:0 0 30px #14b8a633}
  .bigscore{font-size:44px;font-weight:900}
  .log-item{display:flex;justify-content:space-between;align-items:center;background:#0b1220;border:1px solid #263654;border-radius:10px;padding:8px 10px;margin:6px 0}
  .good{color:#22c55e}.bad{color:#ef4444}

  /* Small helper */
  .hidden{display:none}
</style>
</head>
<body>

<header>
  <div class="h-left">
    <h1>GTO Shark • Live Practice (Vanilla)</h1>
    <p>Standard flow • Correct Check/Call/Raise logic • Persistent bet plates • Realistic felt</p>
  </div>
  <div class="ctrls">
    <label>Players</label>
    <select id="players" class="sel">
      <option>9</option><option>8</option><option>7</option><option selected>6</option><option>5</option>
    </select>
    <label>Sequence</label>
    <select id="seq" class="sel">
      <option value="preflop">Preflop only</option>
      <option value="turn">Play to Turn</option>
      <option value="river" selected>Play to River</option>
    </select>
    <label>Hero</label>
    <select id="heroSel" class="sel"></select>
    <label>Scenario</label>
    <select id="scenario" class="sel">
      <option value="none" selected>None (Standard)</option>
      <option value="bvb">Blind vs Blind</option>
      <option value="btnbb">BTN vs BB</option>
      <option value="utgbb">UTG vs BB</option>
      <option value="cobb">CO vs BB</option>
      <option value="sbbtn">SB vs BTN</option>
    </select>
    <button id="newHand" class="btn btn-primary">♻ New Hand</button>
  </div>
</header>

<div class="app">
  <main>
    <section class="table-wrap">
      <div id="table" class="table">
        <div class="rail-glow"></div>

        <div id="hud" class="hud">
          <span id="hudStreet">—</span>
          <span class="sep">|</span>
          <span id="hudPot">Pot —</span>
          <span class="sep">|</span>
          <span id="hudSPR">SPR —</span>
        </div>

        <div id="board" class="board"></div>
        <div id="seats" class="seats"></div>
        <div id="float" class="seats"></div><!-- bet plates / reveals live here -->
      </div>
    </section>

    <section class="panel">
      <h3 style="margin:0 0 6px;font-size:16px">Your move</h3>
      <div id="prompt" class="muted" style="margin-bottom:8px">Loading…</div>
      <div id="actions" class="actions"></div>
    </section>
  </main>

  <aside>
    <div id="result" class="result hidden">
      <div class="bigscore" id="scoreNum"></div>
      <div id="scoreVerd"></div>
    </div>
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <h3 style="margin:0;color:#c7ceff">Hand Log</h3>
        <button id="clearLog" class="btn">Clear</button>
      </div>
      <p class="muted" style="margin:6px 0 8px">✅ ≥ 50% ❌ &lt; 50%</p>
      <div id="log"></div>
    </div>
  </aside>
</div>

<script>
/* =========================
   Entropy / RNG seeding
   ========================= */
const API_KEY = "AIzaSyBZh4GD0KX691kfF3eU45a71o1IHf5iL4U";
let _seed = Date.now()>>>0;
function xsSeed(n){ _seed = (n>>>0) || 2463534242; }
function xsRand(){ _seed^=_seed<<13; _seed^=_seed>>>17; _seed^=_seed<<5; return ((_seed>>>0)%1e5)/1e5; }
async function seedFromAPI(){
  try{
    const r = await fetch(`https://www.googleapis.com/books/v1/volumes?q=poker&maxResults=5&key=${API_KEY}`, {cache:"no-store"});
    const j = await r.json(); xsSeed(JSON.stringify(j).length ^ Date.now());
  }catch{
    xsSeed(Date.now() ^ 0x9e3779b9);
  }
}
const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

/* =========================
   DOM refs
   ========================= */
const table   = document.getElementById('table');
const boardEl = document.getElementById('board');
const seatsEl = document.getElementById('seats');
const floatEl = document.getElementById('float');

const hudStreet = document.getElementById('hudStreet');
const hudPot    = document.getElementById('hudPot');
const hudSPR    = document.getElementById('hudSPR');

const promptEl  = document.getElementById('prompt');
const actionsEl = document.getElementById('actions');

const resultBox = document.getElementById('result');
const scoreNum  = document.getElementById('scoreNum');
const scoreVerd = document.getElementById('scoreVerd');
const logEl     = document.getElementById('log');

const playersSel= document.getElementById('players');
const seqSel    = document.getElementById('seq');
const heroSel   = document.getElementById('heroSel');
const scenSel   = document.getElementById('scenario');
const newBtn    = document.getElementById('newHand');
const clearLog  = document.getElementById('clearLog');

/* =========================
   Cards / helpers
   ========================= */
const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const SUITS = ["♠","♥","♦","♣"];
const suitClass = s => (s==="♥"||s==="♦") ? "red" : "black";

function cardEl(card, board=false){
  const r = document.createElement('div');
  r.className = 'card';
  if(board) r.style.width = '78px', r.style.height='110px';
  const a = document.createElement('div'); a.className = 'rank '+suitClass(card[1]); a.textContent = card[0];
  const b = document.createElement('div'); b.className = 'suit '+suitClass(card[1]); b.textContent = card[1];
  r.appendChild(a); r.appendChild(b);
  return r;
}
function deal(n, taken=new Set()){
  const out=[];
  while(out.length<n){
    const c = RANKS[Math.floor(xsRand()*13)] + SUITS[Math.floor(xsRand()*4)];
    if(!taken.has(c)){ taken.add(c); out.push(c); }
  }
  return out;
}

/* =========================
   Seat templates / positions
   ========================= */
const TEMPLATES={
  9:["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"],
  8:["UTG","UTG+1","UTG+2","HJ","CO","BTN","SB","BB"],
  7:["UTG","UTG+1","HJ","CO","BTN","SB","BB"],
  6:["UTG","HJ","CO","BTN","SB","BB"],
  5:["UTG","CO","BTN","SB","BB"],
};
const STREET_LABEL = {preflop:"Preflop", flop:"Flop", turn:"Turn", river:"River"};

/* =========================
   State
   ========================= */
const S = {
  players: 6,
  seats: [],
  hero: "BTN",
  street: "preflop",      // preflop, flop, turn, river
  sequence: "river",      // preflop | turn | river (max street hero needs to reach)
  scenario: "none",

  hands: {},              // seat -> [c1,c2]
  stacks: {},             // seat -> bb
  committed: {},          // per street committed
  plates: {},             // persistent plate DOM nodes
  folded: {},
  allin: {},
  interacted: new Set(),  // villains who put chips in vs hero
  board: [],
  pot: 0,

  CB: 0,                  // CurrentBetTotal
  LRS: 1,                 // LastRaiseSize
  BB: 1,                  // Big blind
  SB: 0.5,
  lastBettor: null,       // for showdown order

  evLoss: 0,              // accumulate penalties
  lastSnap: null
};

/* =========================
   Layout & rendering
   ========================= */
function layoutSeats(){
  seatsEl.innerHTML=""; floatEl.innerHTML="";
  S.nodes = {};
  const N=S.players, R=(table.clientWidth/2)-110, off=-90;
  for(let i=0;i<N;i++){
    const name=S.seats[i], a=(off+(360/N)*i)*Math.PI/180;
    const x=50+(R*Math.cos(a))/(table.clientWidth/100);
    const y=50+(R*Math.sin(a))/(table.clientHeight/100);

    const seat=document.createElement('div');
    seat.className='seat'+(name===S.hero?' hero':'');
    seat.style.left=x+'%'; seat.style.top=y+'%';
    seat.textContent=name;

    const stack=document.createElement('div');
    stack.className='stack';
    stack.id='stack-'+name;
    stack.textContent='—';
    seat.appendChild(stack);
    seatsEl.appendChild(seat);

    // persistent plate mount (in float layer)
    const plate=document.createElement('div');
    plate.className='plate'; plate.style.left=seat.style.left; plate.style.top=seat.style.top;
    plate.style.transform='translate(-50%,-44px)';
    plate.style.visibility='hidden';
    plate.innerHTML='<span class="chip"></span><span class="amt">0</span>';
    floatEl.appendChild(plate);

    S.nodes[name]={ seat, stack, pos:{x,y}, plate };
    S.plates[name]=plate;
  }
}
function setHeroHighlight(){
  S.seats.forEach(s=>{
    S.nodes[s]?.seat.classList.toggle('hero', s===S.hero);
  });
}
function setActing(seat, on){
  const n=S.nodes[seat]; if(!n) return;
  n.seat.classList.toggle('acting', !!on);
  if(on) setTimeout(()=>n.seat.classList.remove('acting'), 1000);
}
function markFolded(seat){
  const n=S.nodes[seat]; if(!n) return;
  n.seat.classList.add('folded'); n.seat.textContent='FOLD';
  n.stack.style.opacity=.65;
  // hide plate
  const p=S.plates[seat]; if(p){ p.style.visibility='hidden'; p.querySelector('.amt').textContent='0'; }
}

function renderBoard(){
  boardEl.innerHTML="";
  S.board.forEach(c=>boardEl.appendChild(cardEl(c,true)));
}
function renderHeroCards(){
  // remove prior
  document.querySelectorAll('.hero-cards').forEach(x=>x.remove());
  const node=S.nodes[S.hero]; if(!node) return;
  if(!S.hands[S.hero]) return;
  const hc=document.createElement('div'); hc.className='hero-cards';
  hc.style.left=node.seat.style.left; hc.style.top=node.seat.style.top;
  S.hands[S.hero].forEach(c=>hc.appendChild(cardEl(c,false)));
  table.appendChild(hc);
}
function updateStacksUI(){
  S.seats.forEach(s=>{
    const n=S.nodes[s]; if(!n) return;
    n.stack.textContent = `${S.stacks[s].toFixed(1)} BB`;
  });
}
function renderHUD(){
  hudStreet.textContent = STREET_LABEL[S.street] || "—";
  hudPot.textContent    = `Pot ${S.pot.toFixed(1)} BB`;
  const live=S.seats.filter(s=>!S.folded[s]);
  const eff = live.length? Math.min(...live.map(s=>Math.max(0.1,S.stacks[s]))): 100;
  const spr=(eff/Math.max(1,S.pot)).toFixed(1);
  hudSPR.textContent    = `SPR ${spr}`;
}
function setPrompt(msg){
  if(msg){ promptEl.textContent=msg; return; }
  const btxt = S.board.length? ` • Board: ${S.board.join(" ")}` : "";
  promptEl.textContent = `${STREET_LABEL[S.street]} — Your action as ${S.hero}${btxt}`;
}

/* =========================
   Bet plates (persistent)
   ========================= */
function plateSet(seat, amount){
  const p=S.plates[seat]; if(!p) return;
  if(amount>0){
    p.style.visibility='visible';
    p.querySelector('.amt').textContent = `${amount.toFixed(1)} BB`;
  }else{
    p.style.visibility='hidden';
    p.querySelector('.amt').textContent = '0';
  }
}

/* =========================
   Accounting / betting math
   ========================= */
function resetCommitted(){
  S.committed={}; S.seats.forEach(s=> S.committed[s]=0);
  S.seats.forEach(s=> plateSet(s, 0));
}
function initStreet(){
  S.CB = (S.street==="preflop") ? S.BB : 0;
  S.LRS= (S.street==="preflop") ? S.BB : S.BB; // LRS starts at BB; updates on first raise/bet
  resetCommitted();
  if(S.street==="preflop"){
    // blinds
    if(S.seats.includes("SB")) payTo("SB", S.SB);
    if(S.seats.includes("BB")) payTo("BB", S.BB);
  }
  renderHUD();
}
function toCall(seat){ return Math.max(0, S.CB - S.committed[seat]); }
function minRaiseTo(){ return S.CB + S.LRS; }

function payTo(seat, targetTo){
  const need=Math.max(0, targetTo - S.committed[seat]);
  if(need<=0) return 0;
  const can=S.stacks[seat];
  const pay=Math.min(need, can);
  S.stacks[seat]    = +(S.stacks[seat]-pay).toFixed(1);
  S.committed[seat] = +(S.committed[seat]+pay).toFixed(1);
  S.pot             = +(S.pot+pay).toFixed(1);
  updateStacksUI(); renderHUD();
  plateSet(seat, S.committed[seat]); // persist plate for this street
  return pay;
}
function equalizedAmongActives(){
  const act=S.seats.filter(s=>!S.folded[s] && !S.allin[s]);
  if(act.length===0) return true;
  return act.every(s=> S.committed[s]===S.CB );
}

/* =========================
   Strength & GTO-ish policy
   ========================= */
function pfStrength(cards){
  const [a,b]=cards;
  const r1=RANKS.indexOf(a[0]), r2=RANKS.indexOf(b[0]);
  const pair=a[0]===b[0], suited=a[1]===b[1], gap=Math.abs(r1-r2);
  let s = pair ? (100 - r1*3)
               : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?6:0);
  return s + xsRand()*2;
}
function postStrength(cards,board){
  const ranks=board.map(c=>c[0]);
  const high=ranks.filter(r=>["A","K","Q","J","T"].includes(r)).length*2;
  const pair=ranks.some(r=>r===cards[0][0]||r===cards[1][0])?8:0;
  const suit=(cards[0][1]===cards[1][1])?3:0;
  return high+pair+suit + xsRand()*2;
}
function policyKey(street, seat){
  if(street==="preflop"){
    const s=pfStrength(S.hands[seat]);
    if(s>92) return "raise_big";
    if(s>82) return "raise_med";
    if(s>70) return "call";
    return "fold";
  }
  const s=postStrength(S.hands[seat], S.board);
  if(s>16) return "bet_big";
  if(s>12) return "bet_med";
  if(s>8)  return "bet_small";
  return "check";
}

/* =========================
   EV penalty & scoring
   ========================= */
function famKey(k){ return k.includes("raise")?"Raise" : k.includes("bet")?"Bet" : (k==="allin"?"All-in":k[0].toUpperCase()+k.slice(1)); }
function heroStrengthNow(){
  return (S.street==="preflop") ? pfStrength(S.hands[S.hero]) : postStrength(S.hands[S.hero], S.board);
}
function evPenalty(street, heroActionKey, optimalKey){
  // Higher penalty if action family diverges, plus strength-aware cost for egregious jams
  if(heroActionKey===optimalKey) return 0;
  const baseW={preflop:{Fold:.9,Call:.55,Raise:.65,"All-in":1.25},
               flop:{Check:.22,Bet:.38,"All-in":.75},
               turn:{Check:.27,Bet:.5,"All-in":.9},
               river:{Check:.33,Bet:.62,"All-in":1.05}};
  let w=(baseW[street][famKey(heroActionKey)] ?? .5);
  const H = heroStrengthNow();

  if(street==="preflop"){
    if(heroActionKey==="allin"){
      if(H<70) w+=1.25;
      else if(H<80) w+=0.8;
      else if(H<88) w+=0.45;
      else w+=0.15;
    }
    if(heroActionKey==="fold" && H<66) return 0; // junk fold = perfect
  }else{
    if(heroActionKey==="allin" && H<14) w+=.9;
    if(famKey(heroActionKey)==="Bet" && H<8) w+=.5;
  }
  if(famKey(heroActionKey)!==famKey(optimalKey)) w+=0.35;
  return +(w + xsRand()*0.12).toFixed(2);
}
function scoreFromEV(){ return Math.max(0, Math.min(100, Math.round(100 - S.evLoss*25))); }
function verdict(p){ return p>=85?"Excellent":p>=70?"Strong":p>=50?"Okay":"Needs Work"; }

/* =========================
   Actions UI (hero)
   ========================= */
function clearActions(){ actionsEl.innerHTML=""; }
function addBtn(label, cls, cb, disabled=false){
  const b=document.createElement('button'); b.className='btn '+cls; b.textContent=label; b.onclick=cb; b.disabled=!!disabled;
  actionsEl.appendChild(b); return b;
}
function addRaiseOptions(toValues, facing){
  toValues.forEach(to=>{
    const isJam = (S.committed[S.hero] + S.stacks[S.hero]) <= to + 1e-9;
    const label = isJam ? "All-in" : (facing?`Raise to ${to.toFixed(1)} BB`:`Bet ${to.toFixed(1)} BB`);
    addBtn(label, isJam?'btn-danger':'btn-primary', ()=> heroAct(isJam?'allin':(facing?`raise_to:${to}`:`bet:${to}`)));
  });
}
function betSizeMenu(facing){
  // propose sizes based on CB/pot
  if(S.street==="preflop"){
    // min-raise logic
    const minTo = Math.max(minRaiseTo(), S.CB+(S.CB===S.BB?S.BB:S.LRS));
    const sizes = [minTo, minTo+2, Math.max(minTo, S.CB*3)].map(x=> +x.toFixed(1));
    return sizes;
  }
  const base = Math.max(2, Math.round(S.pot*0.33));
  return [base, Math.round(S.pot*0.5), Math.round(S.pot*0.66)];
}
function offerHero(){
  clearActions();
  const need = toCall(S.hero);
  const eff  = S.stacks[S.hero];

  // Fold always allowed
  addBtn("Fold", "btn-ghost", ()=>heroAct("fold"));

  if(need===0){
    addBtn("Check","btn-ghost", ()=>heroAct("check"));
  }else{
    addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`,"btn-primary", ()=>heroAct("call"), eff<=0);
  }

  if(eff>0){
    const sizes = betSizeMenu(need>0);
    addRaiseOptions(sizes, need>0);
    addBtn("All-in","btn-danger", ()=>heroAct("allin"));
  }
}

/* =========================
   Villain action flow
   ========================= */
async function vPre(seat){
  if(S.folded[seat] || S.allin[seat]) return;
  setActing(seat,true);
  await sleep(450 + Math.floor(xsRand()*500));

  const need = toCall(seat);
  const pol  = policyKey("preflop", seat);

  if(need>0){
    // facing action
    if(pol.startsWith("raise") && xsRand()<0.35 && S.stacks[seat]>need){
      // compute min raise to
      const minTo = minRaiseTo();
      let target = pol==="raise_big" ? Math.max(minTo, S.CB*3.2) : Math.max(minTo, S.CB*2.2);
      target = Math.min(target, S.committed[seat]+S.stacks[seat]); // cap by stack
      if(target <= S.CB + 1e-9){
        // not enough to raise → call/jam
        const to = Math.min(S.CB, S.committed[seat]+S.stacks[seat]);
        payTo(seat, to);
        plateSet(seat, S.committed[seat]);
      }else{
        const prevCB = S.CB;
        S.LRS = target - S.CB; S.CB = +target.toFixed(1);
        payTo(seat, S.CB);
        S.lastBettor = seat;
      }
    }else{
      // call or fold
      if(xsRand()<0.78 || S.stacks[seat]<=need){
        const to = Math.min(S.CB, S.committed[seat]+S.stacks[seat]);
        const paid = payTo(seat, to);
        if(paid>0 && !S.folded[S.hero]) S.interacted.add(seat);
      }else{
        S.folded[seat]=true; markFolded(seat);
      }
    }
  }else{
    // unopened → fold/check/open
    if(pol==="fold" && xsRand()<0.28){
      S.folded[seat]=true; markFolded(seat);
    }else if(pol.startsWith("bet") || pol.startsWith("raise")){
      // open to a pot fraction
      let open = Math.max(S.BB, Math.round(S.pot*0.5));
      if(open<=0) open=S.BB*2;
      const target = Math.min(S.committed[seat]+S.stacks[seat], open);
      S.LRS = Math.max(S.BB, target); S.CB = +target.toFixed(1);
      payTo(seat, S.CB);
      S.lastBettor=seat;
    }else{
      // check
      // nothing to pay, leave plate hidden
    }
  }
  setActing(seat,false);
}
async function vPost(seat){
  if(S.folded[seat] || S.allin[seat]) return;
  setActing(seat,true);
  await sleep(450 + Math.floor(xsRand()*500));

  const need = toCall(seat);
  const pol  = policyKey(S.street, seat);

  if(need>0){
    // facing a bet
    if(pol.startsWith("bet") && xsRand()<0.28 && S.stacks[seat]>need){
      // raise
      const minTo = minRaiseTo();
      const raiseMore = Math.max(S.BB*2, Math.round(S.pot*0.4));
      let target = Math.max(minTo, S.CB + raiseMore);
      target = Math.min(target, S.committed[seat]+S.stacks[seat]);
      if(target <= S.CB + 1e-9){
        // call
        const to = Math.min(S.CB, S.committed[seat]+S.stacks[seat]);
        const paid = payTo(seat, to);
        if(paid>0 && !S.folded[S.hero]) S.interacted.add(seat);
      }else{
        S.LRS = target - S.CB; S.CB = +target.toFixed(1);
        payTo(seat, S.CB);
        S.lastBettor=seat;
        if(!S.folded[S.hero]) S.interacted.add(seat);
      }
    }else{
      // call or fold
      if(xsRand()<0.74 || S.stacks[seat]<=need){
        const to = Math.min(S.CB, S.committed[seat]+S.stacks[seat]);
        const paid = payTo(seat, to);
        if(paid>0 && !S.folded[S.hero]) S.interacted.add(seat);
      }else{
        S.folded[seat]=true; markFolded(seat);
      }
    }
  }else{
    // unopened → check or bet
    if(pol.startsWith("bet") && xsRand()<0.36 && S.stacks[seat]>0){
      let size = Math.max(S.BB, Math.round(S.pot*0.33));
      let target = Math.min(S.committed[seat]+S.stacks[seat], size);
      S.LRS = Math.max(S.BB, target); S.CB = +target.toFixed(1);
      payTo(seat, S.CB);
      S.lastBettor=seat;
      if(!S.folded[S.hero]) S.interacted.add(seat);
    }else{
      // check
    }
  }

  setActing(seat,false);
}

/* =========================
   Hero act
   ========================= */
async function heroAct(action){
  // calculate EV penalty against policy Key
  const opt = policyKey(S.street, S.hero);
  const key = action.startsWith("raise_to")||action.startsWith("bet")
                ? (action.startsWith("bet")?"bet_med":"raise_med")
                : action;
  S.evLoss += evPenalty(S.street, key, opt);

  // apply
  if(action==="fold"){
    S.folded[S.hero]=true; markFolded(S.hero);
    return afterHeroResolve();
  }
  if(action==="check"){
    // do nothing (plates unchanged)
  }
  if(action==="call"){
    const to = Math.min(S.CB, S.committed[S.hero]+S.stacks[S.hero]);
    payTo(S.hero, to);
  }
  if(action.startsWith("raise_to:")){
    const to=parseFloat(action.split(":")[1]);
    const minTo=minRaiseTo();
    const cap=S.committed[S.hero]+S.stacks[S.hero];
    const target=Math.min(Math.max(to, minTo), cap);
    S.LRS = Math.max(S.BB, target - S.CB);
    S.CB  = +target.toFixed(1);
    payTo(S.hero, S.CB);
    S.lastBettor=S.hero;
    if(S.stacks[S.hero]<=0) S.allin[S.hero]=true;
  }
  if(action.startsWith("bet:")){
    const to=parseFloat(action.split(":")[1]);
    const cap=S.committed[S.hero]+S.stacks[S.hero];
    const open=Math.min(Math.max(to, S.BB), cap);
    S.LRS = Math.max(S.BB, open); S.CB = +open.toFixed(1);
    payTo(S.hero, S.CB);
    S.lastBettor=S.hero;
    if(S.stacks[S.hero]<=0) S.allin[S.hero]=true;
  }
  if(action==="allin"){
    const maxTo=S.committed[S.hero]+S.stacks[S.hero];
    if(S.CB===0){ S.LRS = Math.max(S.BB,maxTo); }
    else        { S.LRS = Math.max(S.BB, maxTo - S.CB); }
    S.CB = +maxTo.toFixed(1);
    payTo(S.hero, S.CB);
    S.allin[S.hero]=true;
    S.lastBettor=S.hero;
  }

  // villains react (facing hero)
  const order = orderAfter(S.hero);
  for(const v of order){
    if(S.street==="preflop") { await vPre(v); } else { await vPost(v); }
  }

  return afterHeroResolve();
}

/* =========================
   Order helpers
   ========================= */
function orderPreflop(){ // UTG first, up to BTN, SB, BB last
  const idx = S.seats.indexOf("UTG");
  const seq = [...S.seats.slice(idx), ...S.seats.slice(0,idx)];
  return seq.filter(s=>!S.folded[s]);
}
function orderPostflop(){ // first live player left of BTN (typically SB)
  let start = (S.seats.indexOf("BTN")+1) % S.seats.length;
  const seq=[];
  for(let k=0;k<S.seats.length;k++){
    const s = S.seats[(start+k)%S.seats.length];
    if(!S.folded[s]) seq.push(s);
  }
  return seq;
}
function orderBefore(hero){
  const seq = (S.street==="preflop") ? orderPreflop() : orderPostflop();
  const hidx=seq.indexOf(hero);
  return seq.slice(0, hidx);
}
function orderAfter(hero){
  const seq = (S.street==="preflop") ? orderPreflop() : orderPostflop();
  const hidx=seq.indexOf(hero);
  return seq.slice(hidx+1);
}

/* =========================
   Streets advance / Finish
   ========================= */
async function afterHeroResolve(){
  // If hero folded OR hero reached required sequence → finish immediately
  if(S.folded[S.hero]) return finish();

  // If not equalized, give hero another chance (facing raises)
  if(!equalizedAmongActives()){
    offerHero();
    return;
  }

  // Equalized → if sequence demands stop now, finish
  if(S.sequence==="preflop" && S.street==="preflop") return finish();

  // Move to next street or finish river
  if(S.street==="preflop"){ await dealFlop(); await villainsLeadThenHero(); return; }
  if(S.street==="flop"){
    if(S.sequence==="turn") return finish();
    await dealTurn(); await villainsLeadThenHero(); return;
  }
  if(S.street==="turn"){
    await dealRiver(); // sequence river implies ending after hero completes river action, but equalized now → finish
    return finish();
  }
  if(S.street==="river"){ return finish(); }
}

async function villainsLeadThenHero(){
  // New street starts unopened → villains before hero act until action reaches hero seat
  const before = orderBefore(S.hero);
  for(const v of before){
    if(S.street==="preflop"){ await vPre(v); } else { await vPost(v); }
  }
  // Now hero acts at start of their node
  offerHero();
}

async function dealFlop(){
  const taken=new Set(Object.values(S.hands).flat().concat(S.board));
  S.board = deal(3, taken);
  S.street="flop"; initStreet();
  renderBoard(); renderHUD(); setPrompt();
  await sleep(350);
}
async function dealTurn(){
  const taken=new Set(Object.values(S.hands).flat().concat(S.board));
  S.board = [...S.board, ...deal(1, taken)];
  S.street="turn"; initStreet();
  renderBoard(); renderHUD(); setPrompt();
  await sleep(350);
}
async function dealRiver(){
  const taken=new Set(Object.values(S.hands).flat().concat(S.board));
  S.board = [...S.board, ...deal(1, taken)];
  S.street="river"; initStreet();
  renderBoard(); renderHUD(); setPrompt();
  await sleep(350);
}

function showdownReveal(){
  // reveal hero + villains who interacted and did not fold
  const sd = S.seats.filter(s => (s===S.hero) || (!S.folded[s] && S.interacted.has(s)));
  sd.forEach(seat=>{
    const node=S.nodes[seat]; if(!node) return;
    const hold=document.createElement('div');
    hold.style.position='absolute';
    hold.style.left=node.seat.style.left; hold.style.top=node.seat.style.top;
    hold.style.transform='translate(-50%,-120%)';
    hold.style.display='flex'; hold.style.gap='8px'; hold.style.zIndex=80;
    S.hands[seat].forEach(c=>hold.appendChild(cardEl(c,false)));
    floatEl.appendChild(hold);
  });
}
function finish(){
  // Final score only for hero sequence result
  // If hero folded junk preflop, reward 100%
  let pct;
  if(S.street==="preflop" && S.folded[S.hero] && pfStrength(S.hands[S.hero])<66) pct=100;
  else pct=scoreFromEV();

  // Right panel only (not center)
  resultBox.classList.remove('hidden');
  scoreNum.textContent = `${pct}%`;
  scoreNum.classList.toggle('good', pct>=50);
  scoreNum.classList.toggle('bad', pct<50);
  scoreVerd.textContent = (pct>=85?"Excellent":pct>=70?"Strong":pct>=50?"Okay":"Needs Work");

  // Reveal only showdown-relevant hands
  showdownReveal();

  // Log
  const row=document.createElement('div'); row.className='log-item';
  row.innerHTML = `<div><b>${S.hero}</b> • ${S.players}-max • ${S.sequence.toUpperCase()}</div>
                   <div class="${pct>=50?'good':'bad'}"><b>${pct}%</b> ${pct>=50?'✅':'❌'}</div>`;
  logEl.prepend(row);

  // Next hand button
  clearActions();
  addBtn("Next Hand","btn-primary", startNewHand);
}

/* =========================
   Scenarios
   ========================= */
function applyScenario(){
  const sc=scenSel.value;
  // Reset folds; then fold others based on scenario to route action properly.
  S.seats.forEach(s=> S.folded[s]=false);

  if(sc==="none") return; // standard

  if(sc==="bvb"){
    // Everyone folds to SB; hero auto-set if needed
    S.seats.forEach(s=>{ if(s!=="SB" && s!=="BB"){ S.folded[s]=true; markFolded(s); }});
    if(S.hero!=="SB" && S.hero!=="BB"){ S.hero="BB"; heroSel.value="BB"; setHeroHighlight(); renderHeroCards(); }
  }
  if(sc==="btnbb"){
    S.seats.forEach(s=>{ if(s!=="BTN" && s!=="BB"){ S.folded[s]=true; markFolded(s);} });
    if(S.hero!=="BTN" && S.hero!=="BB"){ S.hero="BTN"; heroSel.value="BTN"; setHeroHighlight(); renderHeroCards(); }
  }
  if(sc==="utgbb"){
    S.seats.forEach(s=>{ if(s!=="UTG" && s!=="BB"){ S.folded[s]=true; markFolded(s);} });
    if(S.hero!=="UTG" && S.hero!=="BB"){ S.hero="UTG"; heroSel.value="UTG"; setHeroHighlight(); renderHeroCards(); }
  }
  if(sc==="cobb"){
    S.seats.forEach(s=>{ if(s!=="CO" && s!=="BB"){ S.folded[s]=true; markFolded(s);} });
    if(S.hero!=="CO" && S.hero!=="BB"){ S.hero="CO"; heroSel.value="CO"; setHeroHighlight(); renderHeroCards(); }
  }
  if(sc==="sbbtn"){
    S.seats.forEach(s=>{ if(s!=="SB" && s!=="BTN"){ S.folded[s]=true; markFolded(s);} });
    if(S.hero!=="SB" && S.hero!=="BTN"){ S.hero="SB"; heroSel.value="SB"; setHeroHighlight(); renderHeroCards(); }
  }
}

/* =========================
   Start / Reset
   ========================= */
async function startNewHand(){
  resultBox.classList.add('hidden');
  scoreNum.textContent=""; scoreVerd.textContent="";
  // Clear reveals/plates/board
  floatEl.innerHTML="";
  S.seats.forEach(s=>{
    const n=S.nodes[s];
    if(n){ n.seat.classList.remove("folded","acting"); n.seat.textContent=s; n.stack.style.opacity=1; }
  });
  // Rebuild plates
  S.seats.forEach(s=>{
    const plate=document.createElement('div');
    plate.className='plate'; plate.style.left=S.nodes[s].seat.style.left; plate.style.top=S.nodes[s].seat.style.top;
    plate.style.transform='translate(-50%,-44px)';
    plate.style.visibility='hidden';
    plate.innerHTML='<span class="chip"></span><span class="amt">0</span>';
    floatEl.appendChild(plate);
    S.plates[s]=plate;
  });

  await seedFromAPI();

  // Base seating
  S.players = parseInt(playersSel.value,10);
  S.seats   = TEMPLATES[S.players].slice();
  layoutSeats();

  // hero
  if(!S.seats.includes(heroSel.value)) heroSel.value="BTN";
  S.hero = heroSel.value;
  setHeroHighlight();

  // sequence & scenario
  S.sequence = seqSel.value;
  S.scenario = scenSel.value;

  // stacks & state
  S.hands={}; S.stacks={}; S.committed={}; S.folded={}; S.allin={}; S.interacted=new Set();
  S.pot=0; S.board=[]; S.evLoss=0; S.lastBettor=null;
  S.seats.forEach(s=>{ S.stacks[s]=100; S.folded[s]=false; S.allin[s]=false; });

  // deal hole cards
  const taken=new Set();
  S.seats.forEach(s=> S.hands[s]=deal(2,taken));
  renderHeroCards(); renderBoard(); updateStacksUI();

  // street boot
  S.street="preflop"; initStreet(); renderHUD(); setPrompt();

  // scenarios may pre-fold some seats
  applyScenario();

  // If scenario folded some, ensure blinds still posted
  if(S.street==="preflop"){
    // re-show plates for blinds (already paid)
    plateSet("SB", S.committed["SB"]||0);
    plateSet("BB", S.committed["BB"]||S.BB);
  }

  // Villains before hero
  const before = orderBefore(S.hero);
  for(const v of before){
    await (S.street==="preflop"? vPre(v) : vPost(v));
  }

  // Offer hero
  offerHero();
}

/* =========================
   Wiring
   ========================= */
playersSel.onchange = ()=>startNewHand();
seqSel.onchange     = ()=>startNewHand();
scenSel.onchange    = ()=>startNewHand();
heroSel.onchange    = ()=>{ S.hero=heroSel.value; setHeroHighlight(); renderHeroCards(); setPrompt(); };

newBtn.onclick      = startNewHand;
clearLog.onclick    = ()=>{ logEl.innerHTML=""; };

function populateHeroOptions(){
  heroSel.innerHTML = S.seats.map(s=>`<option${s==="BTN"?' selected':''}>${s}</option>`).join('');
}

/* =========================
   Boot
   ========================= */
(async function boot(){
  await seedFromAPI();
  S.players = parseInt(playersSel.value,10);
  S.seats   = TEMPLATES[S.players].slice();
  layoutSeats();
  populateHeroOptions();
  S.hero = heroSel.value; setHeroHighlight();
  await startNewHand(); // auto-start
})();
</script>
</body>
</html>













