<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GTO Shark • Live Practice (GTO Engine)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>

<style>
/* ROOT COLORS AND UI VARIABLES */
:root {
  --bg:#0b1220;
  --ink:#e2e8f0;
  --felt:#0f3d37;
  --felt-hi:#13574f;
  --rail:#162239;
  --rail-glow: rgba(79,70,229,.35);

  --indigo:#4f46e5;
  --teal:#14b8a6;
  --good:#22c55e;
  --warn:#fbbf24;
  --bad:#ef4444;

  --table-size: 900px;
  --seat: 84px;
  --card-w: 88px;
  --card-h: 124px;
  --board-w: 80px;
  --board-h: 112px;
  --rail-width: 12px;

  --btn-bg:#1e293b;
  --btn-bg-hi:#334155;
  --btn-border:#475569;
  --btn-text:#f1f5f9;
}

/* GLOBAL PAGE RESET */
* {
  box-sizing:border-box;
  margin:0;
  padding:0;
  user-select:none;
}

html, body {
  width:100%;
  height:100%;
  background:var(--bg);
  color:var(--ink);
  overflow:hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

/* MAIN WRAPPER */
#app {
  position:relative;
  width:100%;
  height:100%;
  display:flex;
  justify-content:center;
  align-items:center;
}

/* TABLE AREA */
.table-container {
  position:relative;
  width:var(--table-size);
  height:var(--table-size);
  background:var(--felt);
  border-radius:50%;
  box-shadow:0 0 40px var(--rail-glow);
  border:var(--rail-width) solid var(--rail);
  overflow:visible;
}

/* PLAYER SEAT STYLES */
.seat {
  position:absolute;
  width:var(--seat);
  height:var(--seat);
  border-radius:50%;
  background:#1e293b;
  border:2px solid #475569;
  display:flex;
  justify-content:center;
  align-items:center;
  color:white;
  font-size:14px;
  font-weight:600;
  text-align:center;
  padding:4px;
}

.seat.active {
  border-color:var(--teal);
  box-shadow:0 0 12px var(--teal);
}

.seat.hero {
  border-color:var(--indigo);
  box-shadow:0 0 12px var(--indigo);
}

/* HOLE CARDS */
.hole-card {
  width:var(--card-w);
  height:var(--card-h);
  border-radius:8px;
  background:#1e293b;
  border:2px solid #475569;
  box-shadow:0 0 6px rgba(0,0,0,0.4);
  position:absolute;
}

/* BOARD CARDS */
.board-card {
  width:var(--board-w);
  height:var(--board-h);
  border-radius:8px;
  background:#1e293b;
  border:2px solid #475569;
  position:absolute;
  top:40%;
  left:50%;
}

/* ACTION BUTTONS */
.action-bar {
  position:absolute;
  bottom:40px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  gap:16px;
  z-index:50;
}

.action-btn {
  padding:12px 20px;
  background:var(--btn-bg);
  border:2px solid var(--btn-border);
  border-radius:10px;
  color:var(--btn-text);
  font-size:18px;
  font-weight:600;
  cursor:pointer;
  transition:0.15s;
}

.action-btn:hover {
  background:var(--btn-bg-hi);
}

/* NODE INSPECTOR PANEL */
#nodeInspector {
  position:absolute;
  top:20px;
  right:20px;
  width:360px;
  height:480px;
  background:#1e293b;
  border:2px solid #475569;
  border-radius:12px;
  padding:20px;
  overflow-y:auto;
  color:#f8fafc;
  font-size:14px;
  z-index:60;
}

/* SCROLLBAR STYLING */
#nodeInspector::-webkit-scrollbar {
  width:8px;
}
#nodeInspector::-webkit-scrollbar-thumb {
  background:#475569;
  border-radius:4px;
}

/* RANGE JSON VIEW */
.range-section {
  margin-bottom:20px;
}
.range-section h3 {
  margin-bottom:8px;
  font-size:18px;
  color:var(--indigo);
}
.range-section ul {
  margin-left:18px;
  margin-top:4px;
}
.range-section li {
  margin-bottom:4px;
}

/* STATUS / LOG AREA */
#statusLog {
  position:absolute;
  left:20px;
  bottom:20px;
  padding:12px 20px;
  background:#1e293b;
  border-radius:12px;
  border:2px solid #475569;
  color:#f1f5f9;
  font-size:16px;
  max-width:400px;
  max-height:200px;
  overflow-y:auto;
  z-index:60;
}

/* CARDS */
.card.red { color:#ef4444; }
.card.black { color:#f8fafc; }
</style>

</head>
<body>
<div id="app">

<!-- TABLE -->
<div class="table-container" id="pokerTable">

  <!-- Seats dynamically injected by JS -->

  <!-- Board Area dynamically injected -->

</div>

<!-- ACTION BAR -->
<div class="action-bar" id="actionButtons">
  <!-- Buttons injected by JS -->
</div>

<!-- NODE INSPECTOR -->
<div id="nodeInspector">
  <h2>GTO Strategy</h2>
  <p>Actions, ranges, frequencies will load here.</p>
</div>

<!-- STATUS LOG -->
<div id="statusLog"></div>

</div>

<script>
/* ============================================================
   PART 1: GLOBAL CONSTANTS + RANGE ENGINE BOOTSTRAP
   ============================================================ */

const RANGE_BASE = "ranges";   // your confirmed folder structure

/* Global namespace */
const GTOS = {
  state: {},
  solver: {},
  ranges: {},
  util: {},
  detect: {},
  npc: {},
  hero: {},
  ui: {}
};

</script>
<script>
/* ============================================================
   PART 2: CORE ENGINE — DECK, DEALING, SEATS, STATE MACHINE
   ============================================================ */

/* ------------------------------------------------------------
   CARD UTILITIES
------------------------------------------------------------ */

GTOS.util.ranks = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
GTOS.util.suits = ["c","d","h","s"]; // clubs/diamonds/hearts/spades

GTOS.util.createDeck = function() {
  const deck = [];
  for (let r of GTOS.util.ranks) {
    for (let s of GTOS.util.suits) {
      deck.push(r + s);
    }
  }
  return deck;
};

GTOS.util.shuffle = function(deck) {
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
  return deck;
};

GTOS.util.cardToDisplay = function(card) {
  if (!card) return "";
  const suitSymbol = { "c":"♣", "d":"♦", "h":"♥", "s":"♠" };
  const rank = card[0];
  const suit = suitSymbol[card[1]];
  const red = (card[1] === "d" || card[1] === "h");
  return `<span class="card ${red ? 'red' : 'black'}">${rank}${suit}</span>`;
};


/* ------------------------------------------------------------
   SEAT CONFIGURATION
------------------------------------------------------------ */

GTOS.state.seatPositions = {
  1: { x: 450, y: 80 },
  2: { x: 680, y: 160 },
  3: { x: 760, y: 340 },
  4: { x: 680, y: 520 },
  5: { x: 450, y: 600 },
  6: { x: 220, y: 520 },
  7: { x: 140, y: 340 },
  8: { x: 220, y: 160 },
  9: { x: 450, y: 40 }
};

/* Hero always seat 1 */
GTOS.state.heroSeat = 1;

/* 9 seats: UTG → BTN → SB → BB */
GTOS.state.seats = [
  { seat:1, name:"Hero", role:"BTN", hole:[], active:true },
  { seat:2, name:"UTG", role:"UTG", hole:[], active:true },
  { seat:3, name:"UTG1", role:"UTG1", hole:[], active:true },
  { seat:4, name:"UTG2", role:"UTG2", hole:[], active:true },
  { seat:5, name:"LJ", role:"LJ", hole:[], active:true },
  { seat:6, name:"HJ", role:"HJ", hole:[], active:true },
  { seat:7, name:"CO", role:"CO", hole:[], active:true },
  { seat:8, name:"BTN", role:"BTN", hole:[], active:true },
  { seat:9, name:"SB", role:"SB", hole:[], active:true },
];

GTOS.state.board = [];
GTOS.state.pot = 0;
GTOS.state.deck = [];


/* ------------------------------------------------------------
   TABLE + SEATS RENDERING
------------------------------------------------------------ */

GTOS.ui.renderSeats = function() {
  const table = document.getElementById("pokerTable");

  // Clear seats first
  document.querySelectorAll(".seat").forEach(s => s.remove());

  GTOS.state.seats.forEach((player) => {
    const pos = GTOS.state.seatPositions[player.seat];

    const div = document.createElement("div");
    div.className = "seat";
    if (player.seat === GTOS.state.heroSeat) div.classList.add("hero");

    div.style.left = (pos.x - 40) + "px";
    div.style.top  = (pos.y - 40) + "px";
    div.innerHTML = player.role;

    table.appendChild(div);
  });
};

GTOS.ui.renderBoard = function() {
  const table = document.getElementById("pokerTable");
  document.querySelectorAll(".board-card").forEach(c => c.remove());

  const startX = 450 - (1.5 * 90); // center offset
  const y = 290;

  GTOS.state.board.forEach((card, i) => {
    const div = document.createElement("div");
    div.className = "board-card";
    div.style.left = (startX + (i * 90)) + "px";
    div.style.top  = y + "px";
    div.innerHTML = GTOS.util.cardToDisplay(card);
    table.appendChild(div);
  });
};

GTOS.ui.renderHoleCards = function() {
  // Clear old cards
  document.querySelectorAll(".hole-card").forEach(c => c.remove());

  // Hero only for now
  const hero = GTOS.state.seats.find(s => s.seat === GTOS.state.heroSeat);
  const table = document.getElementById("pokerTable");

  const startX = 450 - 100;
  const y = 520;

  hero.hole.forEach((card, i) => {
    const div = document.createElement("div");
    div.className = "hole-card";
    div.style.left = (startX + (i * 100)) + "px";
    div.style.top  = y + "px";
    div.innerHTML = GTOS.util.cardToDisplay(card);
    table.appendChild(div);
  });
};


/* ------------------------------------------------------------
   STATE MACHINE / GAME FLOW
------------------------------------------------------------ */

GTOS.engine = {
  street: "preflop",   // preflop → flop → turn → river → showdown
  actingSeat: 2,       // UTG opens first
  actionHistory: []
};

GTOS.engine.resetHand = function() {
  GTOS.state.deck = GTOS.util.shuffle(GTOS.util.createDeck());
  GTOS.state.board = [];
  GTOS.state.pot = 0;
  GTOS.engine.street = "preflop";
  GTOS.engine.actingSeat = 2;
  GTOS.engine.actionHistory = [];

  // deal hole cards
  GTOS.state.seats.forEach(p => p.hole = [
    GTOS.state.deck.pop(),
    GTOS.state.deck.pop()
  ]);

  GTOS.ui.renderSeats();
  GTOS.ui.renderHoleCards();
  GTOS.ui.renderBoard();

  GTOS.ui.log("New hand started.");
};

GTOS.ui.log = function(msg) {
  const log = document.getElementById("statusLog");
  log.innerHTML += msg + "<br>";
  log.scrollTop = log.scrollHeight;
};


/* ------------------------------------------------------------
   STREET PROGRESSION
------------------------------------------------------------ */

GTOS.engine.advanceStreet = function() {
  if (GTOS.engine.street === "preflop") {
    GTOS.state.board = [
      GTOS.state.deck.pop(),
      GTOS.state.deck.pop(),
      GTOS.state.deck.pop()
    ];
    GTOS.engine.street = "flop";
    GTOS.ui.log("Dealing the Flop...");
  }
  else if (GTOS.engine.street === "flop") {
    GTOS.state.board.push(GTOS.state.deck.pop());
    GTOS.engine.street = "turn";
    GTOS.ui.log("Dealing the Turn...");
  }
  else if (GTOS.engine.street === "turn") {
    GTOS.state.board.push(GTOS.state.deck.pop());
    GTOS.engine.street = "river";
    GTOS.ui.log("Dealing the River...");
  }
  else if (GTOS.engine.street === "river") {
    GTOS.engine.street = "showdown";
    GTOS.ui.log("Showdown...");
  }

  GTOS.ui.renderBoard();
};


/* ------------------------------------------------------------
   ACTION BUTTON SETUP (placeholder—solver actions in next part)
------------------------------------------------------------ */

GTOS.ui.renderActionButtons = function() {
  const bar = document.getElementById("actionButtons");
  bar.innerHTML = `
    <button class="action-btn" onclick="GTOS.hero.fold()">Fold</button>
    <button class="action-btn" onclick="GTOS.hero.call()">Call</button>
    <button class="action-btn" onclick="GTOS.hero.betSmall()">Bet 33%</button>
    <button class="action-btn" onclick="GTOS.hero.betBig()">Bet 100%</button>
  `;
};


/* INITIALIZE UI ON LOAD */
window.addEventListener("load", () => {
  GTOS.ui.renderSeats();
  GTOS.engine.resetHand();
  GTOS.ui.renderActionButtons();
});
</script>
<script>
/* ============================================================
   PART 3 — TEXTURE ENGINE + JSON RANGE LOADER
   ============================================================ */

/* ------------------------------------------------------------
   TEXTURE CLASSIFICATION
------------------------------------------------------------ */

GTOS.texture = {};

GTOS.texture.classifyFlop = function(board3) {
  if (board3.length !== 3) return "unknown";

  const ranks = board3.map(c => c[0]);
  const suits = board3.map(c => c[1]);

  const rankValue = { "2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"T":10,"J":11,"Q":12,"K":13,"A":14 };
  const numeric = ranks.map(r => rankValue[r]).sort((a,b)=>a-b);

  const uniqueRanks = new Set(ranks).size;
  const uniqueSuits = new Set(suits).size;

  const high = numeric[2] >= 11;
  const paired = (uniqueRanks < 3);
  const coordinated = (
    (numeric[2]-numeric[0] <= 4) ||  // connected
    (numeric[1]-numeric[0] <= 2) ||  // wheel-ish
    (numeric[2]-numeric[1] <= 2)
  );

  const twoTone = (uniqueSuits === 2);
  const mono    = (uniqueSuits === 1);
  const rainbow = (uniqueSuits === 3);

  let tag = [];

  if (mono) tag.push("monotone");
  else if (twoTone) tag.push("twotone");
  else tag.push("rainbow");

  if (paired) tag.push("paired");
  else tag.push("unpaired");

  if (high) tag.push("high");
  else if (numeric[2] >= 8) tag.push("mid");
  else tag.push("low");

  if (coordinated) tag.push("wet");
  else tag.push("dry");

  return tag.join("_");
};

/* ------------------------------------------------------------
   HAND CLASSIFIER (BUCKETS)
------------------------------------------------------------ */

GTOS.range = {};

GTOS.range.classifyHand = function(hole) {
  const r1 = hole[0][0], s1 = hole[0][1];
  const r2 = hole[1][0], s2 = hole[1][1];

  const suited = (s1 === s2);
  const pair   = (r1 === r2);

  const high = ["A","K","Q","J"];
  const mid  = ["T","9","8","7"];

  if (pair) {
    return `pair_${r1}${r2}`;       // pair_AA, pair_77, etc.
  }
  if (suited) {
    if (high.includes(r1) && high.includes(r2)) return "suited_broadway";
    if (mid.includes(r1) && mid.includes(r2))   return "suited_connectors";
    return "suited_misc";
  } else {
    if (high.includes(r1) && high.includes(r2)) return "offsuit_broadway";
    if (mid.includes(r1) && mid.includes(r2))   return "offsuit_connectors";
    return "offsuit_trash";
  }
};

/* ------------------------------------------------------------
   JSON RANGE LOADER
------------------------------------------------------------ */

GTOS.range.cache = {};  // loaded files

GTOS.range.load = async function(filename) {
  if (GTOS.range.cache[filename]) return GTOS.range.cache[filename];

  try {
    const res = await fetch(`ranges/${filename}.json`);
    if (!res.ok) throw new Error("Missing JSON file: " + filename);

    const data = await res.json();
    GTOS.range.cache[filename] = data;
    return data;

  } catch (err) {
    console.error("RANGE LOAD ERROR:", err);
    return null;
  }
};

/* ------------------------------------------------------------
   STRATEGY LOOKUP
------------------------------------------------------------ */

GTOS.range.getStrategy = async function(street, position, board, facing) {
  let texture = "unknown";

  if (street === "flop") {
    texture = GTOS.texture.classifyFlop(board);
  }
  if (street === "turn" || street === "river") {
    // Part 4 will add full 5-card texture engine
    texture = "postflop_generic";
  }

  const filename = `${street}_${position}_${texture}`;
  const data = await GTOS.range.load(filename);

  if (!data) return null;

  return data.strategy?.[facing] || null;
};

/* ------------------------------------------------------------
   NPC DECISION INTERFACE (uses solved ranges)
------------------------------------------------------------ */

GTOS.npc = {};

GTOS.npc.decide = async function(player, board, facingAction) {
  const street = GTOS.engine.street;
  const pos = player.role;
  const hole = player.hole;

  const handClass = GTOS.range.classifyHand(hole);

  const strat = await GTOS.range.getStrategy(street, pos, board, facingAction);
  if (!strat) return { action:"check" };

  const freqTable = strat.frequencies || {};
  const bucket = freqTable[handClass] || freqTable["default"];

  if (!bucket) return { action:"check" };

  // frequency roll
  const roll = Math.random();
  let cumulative = 0;

  for (const action in bucket) {
    cumulative += bucket[action];
    if (roll <= cumulative) {
      return { action };
    }
  }
  return { action:"check" };
};

/* ------------------------------------------------------------
   HERO SOLVER LOOKUP (for grading)
------------------------------------------------------------ */

GTOS.heroSolver = {};

GTOS.heroSolver.getRecommended = async function(board, facing) {
  const street = GTOS.engine.street;
  const pos = "BTN"; // Hero default
  const hole = GTOS.state.seats.find(s => s.seat===1).hole;
  const handClass = GTOS.range.classifyHand(hole);

  const strat = await GTOS.range.getStrategy(street, pos, board, facing);
  if (!strat) return null;

  const bucket = strat.frequencies?.[handClass] 
              || strat.frequencies?.["default"];

  return bucket || null;
};
</script>
<script>
/* ============================================================
   PART 4 — SOLVER-DRIVEN ACTION ENGINE
   ============================================================ */

/* ------------------------------------------------------------
   Determine “facing action” label for JSON lookup
------------------------------------------------------------ */

GTOS.solverFacing = function(state, seatIndex) {
  const toCall = state.currentBet - state.players[seatIndex].committed;

  if (toCall > 0) {
    if (toCall <= 3) return "facing_small_bet";
    if (toCall <= 8) return "facing_medium_bet";
    return "facing_large_bet";
  }

  return "facing_check";
};

/* ------------------------------------------------------------
   NPC ACTION SELECTION USING SOLVER JSON
------------------------------------------------------------ */

GTOS.Engine.npcChooseAction = async function(state, idx) {
  const p = state.players[idx];
  if (p.folded || p.allIn) return { type: "check" };

  const street = ["preflop","flop","turn","river"][state.street];
  const pos = p.position;
  const board = state.board.map(c => c.rank + c.suit);

  const facing = GTOS.solverFacing(state, idx);

  // classify the NPC’s hole cards
  const holeShort = p.hole.map(c => c.rank + c.suit);
  const handClass = GTOS.range.classifyHand(holeShort);

  // pull solver strategy
  const strat = await GTOS.range.getStrategy(street, pos, board, facing);
  if (!strat) return { type:"check" }; // fallback

  const freqTable = strat.frequencies || {};
  const bucket = freqTable[handClass] || freqTable["default"];

  if (!bucket) return { type:"check" };

  // roll frequency
  const r = Math.random();
  let acc = 0;

  for (const action in bucket) {
    acc += bucket[action];
    if (r <= acc) {
      return GTOS.Engine.actionFromSolverKeyword(action, state, idx);
    }
  }

  return { type:"check" };
};

/* ------------------------------------------------------------
   Convert JSON solver label → real engine action
------------------------------------------------------------ */

GTOS.Engine.actionFromSolverKeyword = function(keyword, st, idx) {
  switch(keyword) {
    case "check": return { type:"check" };
    case "call":  return { type:"call" };
    case "fold":  return { type:"fold" };
    case "jam":   return { type:"jam" };

    case "bet_small":
      return { type:"bet", size: Math.max(1, st.pot * 0.33) };

    case "bet_big":
      return { type:"bet", size: Math.max(1, st.pot * 0.66) };

    case "raise_small":
      return { type:"raise", size: st.currentBet + st.lastRaise };
    
    case "raise_big":
      return { type:"raise", size: st.currentBet * 2.5 };

    default:
      console.warn("Unknown solver keyword:", keyword);
      return { type:"check" };
  }
};

/* ------------------------------------------------------------
   HERO OPTIMAL-ACTION LOOKUP (used for score)
------------------------------------------------------------ */

GTOS.hero.getOptimalMix = async function(state) {
  const street = ["preflop","flop","turn","river"][state.street];
  const hero = state.players[state.heroIndex];
  const pos = hero.position;
  const board = state.board.map(c => c.rank + c.suit);
  const facing = GTOS.solverFacing(state, state.heroIndex);

  const holeShort = hero.hole.map(c=>c.rank + c.suit);
  const handClass = GTOS.range.classifyHand(holeShort);

  const strat = await GTOS.range.getStrategy(street, pos, board, facing);
  if (!strat) return null;

  const freqTable = strat.frequencies || {};
  return freqTable[handClass] || freqTable["default"] || null;
};

/* ------------------------------------------------------------
   HERO SCORING BASED ON SOLVER MIX
------------------------------------------------------------ */

GTOS.hero.computeActionScore = async function(state, heroAction) {
  const mix = await GTOS.hero.getOptimalMix(state);
  if (!mix) return 50;  // unknown → neutral

  // Convert hero actual action → solver key
  const key = GTOS.hero.mapHeroActionToSolverKey(heroAction, state);

  if (!key) return 40;

  const freq = mix[key] ?? 0;

  // Score:
  // - 100 if solver mostly prefers it
  // - 50 if solver neutral
  // - 0 if solver never prefers it
  const score = Math.round(freq * 100);
  return score;
};

GTOS.hero.mapHeroActionToSolverKey = function(action, state) {
  switch(action.type) {
    case "check": return "check";
    case "call":  return "call";
    case "fold":  return "fold";
    case "jam":   return "jam";

    case "bet":
      if (action.size <= state.pot * 0.4) return "bet_small";
      return "bet_big";

    case "raise":
      if (action.size <= state.currentBet * 2) return "raise_small";
      return "raise_big";
  }
  return null;
};

/* ------------------------------------------------------------
   HERO-ACTION OVERRIDE (injects solver scoring)
------------------------------------------------------------ */

const _oldHeroAct = GTOS.Engine.heroAct;

GTOS.Engine.heroAct = async function(state, action) {
  // Compute solver score FIRST
  const score = await GTOS.hero.computeActionScore(state, action);

  // Store for final result panel
  if (!state.evLoss) state.evLoss = 0;
  state.evLoss += (100 - score) / 33;  // penalty scaling

  return _oldHeroAct.call(GTOS.Engine, state, action);
};
</script>
<script>
/* ============================================================
   PART 5 — FINAL STREET FLOW, SHOWDOWN, AND BOOTSTRAP
   ============================================================ */

/* ------------------------------------------------------------
   STREET ADVANCEMENT + SOLVER RANGE LOADING
------------------------------------------------------------ */

GTOS.Engine.advanceStreet = async function(state) {
  // If we reached the target training street → showdown now
  if (state.street >= state.config.targetStreet) {
    GTOS.Engine.goToShowdown(state);
    return;
  }

  let next = state.street;

  switch(state.street) {
    case GTOS.STREET.PREFLOP:
      GTOS.Engine.dealFlop(state);
      next = GTOS.STREET.FLOP;
      break;
    case GTOS.STREET.FLOP:
      GTOS.Engine.dealTurn(state);
      next = GTOS.STREET.TURN;
      break;
    case GTOS.STREET.TURN:
      GTOS.Engine.dealRiver(state);
      next = GTOS.STREET.RIVER;
      break;
    case GTOS.STREET.RIVER:
      GTOS.Engine.goToShowdown(state);
      return;
  }

  state.resetForNewStreet(next);

  GTOS.Render.renderHUD(state);

  // Continue betting with solver logic
  GTOS.Engine.continueActionFlow(state);
};

/* ------------------------------------------------------------
   BETTING ROUND FLOW — MAIN ACTION LOOP
------------------------------------------------------------ */

GTOS.Engine.continueActionFlow = async function(state) {
  while (true) {
    // If only one player remains → showdown
    if (state.aliveCount() <= 1) {
      GTOS.Engine.goToShowdown(state);
      return;
    }

    // If everyone has matched → move street
    if (state.everyoneMatched()) {
      await GTOS.Engine.advanceStreet(state);
      return;
    }

    const idx = state.actionIndex;
    const p = state.players[idx];

    // HERO TURN
    if (idx === state.heroIndex && !p.folded && !p.allIn) {
      GTOS.Engine.offerHeroActions(state);
      return;
    }

    // NPC SKIP IF FOLDED/ALL-IN
    if (p.folded || p.allIn) {
      state.actionIndex = state.nextActive(idx);
      continue;
    }

    // NPC ACTS USING SOLVER JSON
    await GTOS.Engine.npcActWithDelay(state, idx);

    // Move to next actor
    state.actionIndex = state.nextActive(idx);
  }
};

/* ------------------------------------------------------------
   NPC ACTION WITH ANIMATION DELAY
------------------------------------------------------------ */

GTOS.Engine.npcActWithDelay = function(state, idx) {
  return new Promise(resolve => {
    setTimeout(async () => {
      await GTOS.Engine.npcAct(state, idx);
      resolve();
    }, 600);
  });
};

/* ------------------------------------------------------------
   NPC ACT EXECUTION (connects solver → table)
------------------------------------------------------------ */

GTOS.Engine.npcAct = async function(state, idx) {
  const p = state.players[idx];
  if (p.folded || p.allIn) return;

  const action = await GTOS.Engine.npcChooseAction(state, idx);

  const seatNode = state.seatNodes[idx];
  if (seatNode) {
    seatNode.classList.add("acting");
    setTimeout(()=> seatNode.classList.remove("acting"), 500);
  }

  switch(action.type) {
    case "fold":
      GTOS.Engine.applyFold(state, idx);
      break;
    case "check":
      GTOS.Render.betPlate(seatNode, "CHECK");
      GTOS.Render.setSeatLabel(state, idx, "CHECK");
      break;
    case "call":
      GTOS.Engine.applyCall(state, idx);
      break;
    case "bet":
    case "raise":
      GTOS.Engine.applyBetOrRaise(state, idx, action.size);
      break;
    case "jam":
      GTOS.Engine.applyJam(state, idx);
      break;
  }

  state.actedThisStreet.add(idx);
  state.interacted.add(idx);

  GTOS.Render.updateStacks(state);
  GTOS.Render.renderHUD(state);
};

/* ------------------------------------------------------------
   SHOWDOWN + REVEAL
------------------------------------------------------------ */

GTOS.Engine.goToShowdown = function(state) {
  // Complete the board to 5 cards
  while (state.board.length < 5) {
    state.board.push(...GTOS.Engine.drawUnique(state, 1));
  }
  GTOS.Render.renderBoard(state);

  state.street = GTOS.STREET.SHOWDOWN;

  const result = GTOS.Engine.resolveShowdown(state);

  // Reveal all non-hero hands
  GTOS.Render.showdownReveal(state, result.winners);

  // Compute final hero score
  const evPenalty = state.evLoss || 0;
  const pct = Math.max(0, Math.min(100, Math.round(100 - evPenalty * 20)));

  let verdict = "Needs Work";
  if (pct >= 85) verdict = "Excellent";
  else if (pct >= 70) verdict = "Strong";
  else if (pct >= 50) verdict = "OK";

  const detail = `EV Penalty: ${evPenalty.toFixed(2)} (lower is better)`;

  GTOS.Render.showResult(pct, verdict, detail);

  GTOS.Render.clearActions();
  GTOS.Render.addActionButton("Next Hand","primary",() => {
    GTOS.Engine.startNewHand();
  });
};

/* ------------------------------------------------------------
   START NEW HAND (connects deck, ranges, hero cards)
------------------------------------------------------------ */

GTOS.Engine.startNewHand = function() {
  GTOS.Render.hideResult();
  GTOS.Render.clearActions();
  GTOS.Render.setPrompt("Dealing a new GTO practice hand…");

  if (GTOS.state && GTOS.state.heroCardsHolder) {
    GTOS.state.heroCardsHolder.remove();
    GTOS.state.heroCardsHolder = null;
  }

  GTOS.dom.floatLayer.innerHTML = "";
  GTOS.dom.board.innerHTML = "";

  const st = GTOS.Engine.createGameState();
  GTOS.Engine.attachGameStateMethods(st);
  GTOS.state = st;

  st.deck = GTOS.Engine.buildDeck();

  st.players.forEach(p => {
    p.hole = GTOS.Engine.drawUnique(st, 2);
    p.stack = 100;
    p.folded = false;
    p.allIn = false;
    p.committed = 0;
  });

  st.street = GTOS.STREET.PREFLOP;
  st.pot = 0;
  st.currentBet = 0;
  st.lastRaise = 0;
  st.evLoss = 0;
  st.heroFolded = false;
  st.actedThisStreet.clear();
  st.interacted.clear();

  // Layout seats + hero highlight
  GTOS.Render.layoutSeats(st);
  GTOS.Render.updateHeroHighlight(st);

  // Hero cards
  GTOS.Render.renderHeroHoleCards(st);
  GTOS.Render.renderHUD(st);

  // Post blinds
  const sb = st.players.findIndex(p => p.position==="SB");
  const bb = st.players.findIndex(p => p.position==="BB");
  if (sb >= 0) GTOS.Engine.payTo(st, sb, 0.5);
  if (bb >= 0) GTOS.Engine.payTo(st, bb, 1.0);

  st.currentBet = 1.0;
  st.lastRaise = 1.0;

  GTOS.Render.updateStacks(st);
  GTOS.Render.renderHUD(st);

  // Apply scenario (BTN vs BB, etc.)
  GTOS.Engine.applyScenarioPresets(st);

  // First actor
  let idx = st.players.findIndex(p => p.position==="UTG");
  if (idx < 0) idx = 0;
  st.actionIndex = idx;

  // Skip folded/all-in until hero or valid actor
  while (st.players[st.actionIndex].folded || st.players[st.actionIndex].allIn) {
    st.actionIndex = st.nextActive(st.actionIndex);
    if (st.actionIndex === st.heroIndex) break;
  }

  GTOS.Engine.continueActionFlow(st);

  // Update node inspector
  GTOS.Debug.updateNodeInspector();
};

/* ------------------------------------------------------------
   EVENT HANDLERS
------------------------------------------------------------ */

GTOS.dom.newHandBtn.addEventListener("click", () => {
  GTOS.Engine.startNewHand();
});

GTOS.dom.playersSel.addEventListener("change", () => {
  GTOS.Engine.onPlayersChanged();
});

window.addEventListener("resize", () => {
  GTOS.Render.relayoutAll();
});

/* ------------------------------------------------------------
   INITIAL BOOTSTRAP
------------------------------------------------------------ */

window.addEventListener("load", () => {
  GTOS.Engine.updateHeroOptionsForPlayers();
  GTOS.Engine.startNewHand();
});
</script>


