<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>GTO Shark • Live Practice v7</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0f172a; --ink:#e2e8f0;
      --indigo:#4f46e5; --teal:#14b8a6;
      --ringA:rgba(79,70,229,.35); --ringB:rgba(20,184,166,.14);
      --table:820px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{font-family:"Inter",sans-serif;background:var(--bg);color:var(--ink);overflow-x:hidden}

    /* layout */
    .app{display:grid;grid-template-columns:minmax(700px,1fr) 360px;gap:18px;align-items:start}
    @media (max-width:1200px){.app{grid-template-columns:1fr}.sidebar{order:3}}

    /* table */
    .table-wrap{display:flex;justify-content:center}
    .table-ring{
      width:var(--table);height:var(--table);border-radius:9999px;position:relative;
      background:
        radial-gradient(1200px 600px at 50% 60%, rgba(20,184,166,.12), transparent 60%),
        radial-gradient(circle at center,#0b1220 0%,#0c162b 60%,#0f172a 100%);
      border:9px solid var(--ringA);
      box-shadow:inset 0 0 46px var(--ringA), 0 0 36px var(--ringB);
    }

    /* HUD (kept above all seats) */
    .hud{
      position:absolute;top:45.5%;left:50%;transform:translate(-50%,-50%);
      display:flex;gap:.6rem;align-items:center;
      padding:.55rem .95rem;border-radius:.95rem;
      background:rgba(2,6,23,.92);border:1px solid rgba(99,102,241,.35);
      backdrop-filter:blur(6px);
      font-weight:800;font-size:14px;color:#c7d2fe;z-index:80;text-shadow:0 1px 2px rgba(0,0,0,.45)
    }
    .hud .sep{opacity:.65}

    /* seats */
    .seat{
      position:absolute;transform:translate(-50%,-50%);
      width:78px;height:78px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      font-size:12px;font-weight:800;text-transform:uppercase;
      background:#142034; border:1px solid #2a3a52;
      box-shadow:0 6px 18px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.08);
      color:#9fb2cc; z-index:30;
    }
    .seat.hero{border-color:#f59e0b;color:#facc15;box-shadow:0 0 22px rgba(245,158,11,.35),0 6px 18px rgba(0,0,0,.35)}
    .seat .badge-mini{
      position:absolute;top:-8px;right:-8px;background:#ef4444;color:#fff;border-radius:9999px;
      font-size:10px;padding:2px 6px;display:none;border:1px solid rgba(255,255,255,.7)
    }
    .seat.allin .badge-mini{display:block}
    .stack{
      position:absolute;top:calc(100% + 16px);left:50%;transform:translateX(-50%);
      background:#0b1220;color:#c7d2fe;border:1px solid rgba(99,102,241,.5);
      padding:2px 10px;border-radius:9999px;font-size:12px;white-space:nowrap;z-index:35
    }

    /* cards */
    .card{
      width:82px;height:118px;border-radius:16px;display:flex;flex-direction:column;align-items:center;justify-content:center;
      background:linear-gradient(160deg,#fff 0%,#f3f5ff 55%,#e5e9ff 100%);
      border:2px solid rgba(79,70,229,.95);
      box-shadow:0 12px 28px rgba(0,0,0,.38),inset 0 1px 0 rgba(255,255,255,.65);
      margin:0 4px
    }
    .rank{font-size:38px;font-weight:900;line-height:1}
    .suit{font-size:34px;line-height:1;margin-top:1px}
    .red{color:#ef4444}.black{color:#0f172a}
    .board-card{width:74px;height:104px;border-radius:14px}
    .hero-cards{position:absolute;display:flex;gap:8px;z-index:75;transform:translate(-50%,-50%)}

    /* floating action chips (announcements) */
    .float-layer{position:absolute;inset:0;pointer-events:none;z-index:90}
    .float-chip{
      position:absolute;padding:.42rem .7rem;border-radius:.7rem;font-size:12px;font-weight:800;
      background:#0b1220;border:1px solid rgba(99,102,241,.6);color:#c7d2fe;white-space:nowrap;
      opacity:0;transform:translate(-50%,-8px);animation:bubble 2.3s ease-out forwards
    }
    @keyframes bubble{
      0%{opacity:0;transform:translate(-50%,8px)}
      20%{opacity:1;transform:translate(-50%,0)}
      80%{opacity:1;transform:translate(-50%,-10px)}
      100%{opacity:0;transform:translate(-50%,-18px)}
    }
    .pulse{animation:pulse 1.15s ease-in-out 2}
    @keyframes pulse{
      0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,.65)}
      50%{box-shadow:0 0 0 14px rgba(239,68,68,0)}
    }

    /* panels + buttons */
    .panel{background:#0b1220;border:1px solid #2c3a4f;border-radius:1rem;padding:1rem}
    .panel h3{font-weight:800}
    .btn{font-weight:800;padding:.9rem 1.15rem;border-radius:.8rem;transition:.15s}
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .btn-primary{background:var(--indigo);color:#fff}
    .btn-ghost{background:rgba(20,184,166,.1);color:#5eead4;border:1px solid rgba(45,212,191,.35)}
    .btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);color:#fff}
    .badge{font-size:11px;font-weight:800;padding:2px 8px;border-radius:9999px;border:1px solid rgba(99,102,241,.45);background:#0d1322;color:#c7d2fe}
    .score-good{color:#22c55e}.score-bad{color:#ef4444}
    .check{color:#22c55e;margin-left:4px}.xmark{color:#ef4444;margin-left:4px}

    /* big overlay score (end of hand only) */
    .overlay-score{
      position:absolute;top:44%;left:50%;transform:translate(-50%,-50%);
      font-size:76px;font-weight:900;opacity:0;transition:opacity .8s ease;text-shadow:0 0 20px rgba(0,0,0,.6);z-index:120
    }
    .overlay-score.show{opacity:1}
    .overlay-good{color:#22c55e}.overlay-bad{color:#ef4444}

    /* list items */
    .log-item{display:flex;justify-content:space-between;align-items:center;background:#0b1220;border:1px solid #2b3647;border-radius:.9rem;padding:.65rem .8rem;margin-bottom:.5rem;cursor:pointer;transition:.15s}
    .log-item:hover{border-color:#455372;background:#0c1425}

    /* helpers */
    .muted{color:#9fb2cc}
  </style>
</head>
<body class="p-4 md:p-6">
  <header class="flex flex-col gap-4 md:flex-row md:items-end md:justify-between mb-4">
    <div>
      <h1 class="text-3xl font-extrabold text-indigo-400">GTO Shark • Live Practice v7</h1>
      <p class="text-slate-400 text-sm">Cinematic drills • Real stacks • Seat-based cards • Sequence scoring</p>
    </div>
    <div class="flex flex-wrap items-center gap-3">
      <label class="text-xs muted">Table</label>
      <select id="numPlayers" class="bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm">
        <option value="9" selected>9-max</option><option value="8">8-max</option><option value="7">7-max</option>
        <option value="6">6-max</option><option value="5">5-max</option><option value="4">4-max</option>
      </select>

      <label class="text-xs muted ml-2">Sequence</label>
      <select id="sequenceMode" class="bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm">
        <option value="preflop">Play through Preflop</option>
        <option value="turn">Play through Turn</option>
        <option value="river">Play through River</option>
      </select>

      <label class="text-xs muted ml-2">Hero</label>
      <select id="heroPos" class="bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm"></select>

      <button id="newHand" class="btn btn-primary">♻️ New Scenario</button>
    </div>
  </header>

  <div class="app">
    <main>
      <section class="table-wrap">
        <div id="table" class="table-ring">
          <div id="hud" class="hud">
            <span id="hudStreet">—</span><span class="sep">|</span>
            <span id="hudPot">Pot —</span><span class="sep">|</span>
            <span id="hudSPR">SPR —</span>
          </div>

          <div id="board" class="absolute top-[48%] left-1/2 -translate-x-1/2 flex gap-2 z-70"></div>
          <div id="seatsLayer" class="absolute inset-0 z-40"></div>
          <div id="floatLayer" class="float-layer"></div>
          <div id="overlayScore" class="overlay-score"></div>
        </div>
      </section>

      <!-- Action panel -->
      <section class="mt-5 panel">
        <h3 class="text-lg text-white mb-1">Your move</h3>
        <p id="prompt" class="muted text-sm">Click “New Scenario” to begin.</p>
        <div id="actions" class="flex flex-wrap gap-3 mt-3"></div>
      </section>

      <!-- Summary -->
      <section id="summary" class="hidden mt-5 panel">
        <h3 class="text-2xl font-bold text-teal-400">Drill Summary</h3>
        <div id="summaryBody" class="space-y-2 text-slate-200 text-sm mt-2"></div>
        <div class="flex flex-wrap items-center gap-3 mt-3">
          <div id="evLine" class="text-lg font-bold"></div>
          <div id="gtoScore" class="badge"></div>
        </div>
        <p id="tutor" class="text-slate-300 text-sm"></p>
        <div class="pt-2 flex gap-3">
          <button id="again" class="btn btn-primary">Next Hand</button>
          <button id="replay" class="btn btn-ghost">Replay Hand</button>
        </div>
      </section>
    </main>

    <!-- Sidebar: persistent log -->
    <aside class="sidebar">
      <div class="panel">
        <div class="flex justify-between items-center">
          <h3 class="text-lg font-bold text-indigo-300">Hand Log</h3>
          <button id="clearLog" class="badge">Clear</button>
        </div>
        <p class="text-xs muted mt-1">✅ ≥ 50% ❌ &lt; 50% — click a row to replay</p>
        <div id="logList" class="mt-3"></div>
      </div>
    </aside>
  </div>

  <!-- ===== SCRIPT (starts here; continues in Parts 2 & 3) ===== -->
  <script>
  /* ========= RNG w/ Google entropy ========= */
  const API_KEY="AIzaSyBZh4GD0KX691kfF3eU45a71o1IHf5iL4U";
  let _seed=Date.now()|0;
  function xsSeed(n){_seed=n>>>0;}
  function xsRand(){_seed^=_seed<<13;_seed^=_seed>>>17;_seed^=_seed<<5;return((_seed>>>0)%1e5)/1e5;}
  async function seedFromAPI(){
    try{
      const r=await fetch(`https://www.googleapis.com/books/v1/volumes?q=poker&maxResults=5&key=${API_KEY}`,{cache:"no-store"});
      const j=await r.json(); xsSeed(JSON.stringify(j).length ^ Date.now());
    }catch{ xsSeed(Date.now() ^ 0x9e3779b9); }
  }
  const sleep=(ms)=>new Promise(res=>setTimeout(res,ms));

  /* ========= DOM refs ========= */
  const table=document.getElementById("table"),
        seatsLayer=document.getElementById("seatsLayer"),
        floatLayer=document.getElementById("floatLayer"),
        boardEl=document.getElementById("board"),
        overlayScore=document.getElementById("overlayScore"),
        hudStreet=document.getElementById("hudStreet"),
        hudPot=document.getElementById("hudPot"),
        hudSPR=document.getElementById("hudSPR"),
        promptEl=document.getElementById("prompt"),
        actionsEl=document.getElementById("actions"),
        summarySec=document.getElementById("summary"),
        sumBody=document.getElementById("summaryBody"),
        evLine=document.getElementById("evLine"),
        gtoScore=document.getElementById("gtoScore"),
        tutor=document.getElementById("tutor"),
        logList=document.getElementById("logList");

  const newBtn=document.getElementById("newHand"),
        againBtn=document.getElementById("again"),
        replayBtn=document.getElementById("replay"),
        clearLog=document.getElementById("clearLog"),
        numSel=document.getElementById("numPlayers"),
        seqSel=document.getElementById("sequenceMode"),
        heroSel=document.getElementById("heroPos");

  /* ========= Cards ========= */
  const RANKS=["A","K","Q","J","T","9","8","7","6","5","4","3","2"],
        SUITS=["♠","♥","♦","♣"];
  const SUITCLASS=(s)=>s==="♥"||s==="♦"?"red":"black";

  function cardEl(c,isBoard=false){
    const r=c[0],s=c[1];
    const e=document.createElement("div");
    e.className=isBoard?"card board-card":"card";
    e.innerHTML=`<div class="rank ${SUITCLASS(s)}">${r}</div><div class="suit ${SUITCLASS(s)}">${s}</div>`;
    return e;
  }
  function deal(n,taken=new Set()){
    const out=[]; while(out.length<n){
      const c=RANKS[Math.floor(xsRand()*13)]+SUITS[Math.floor(xsRand()*4)];
      if(!taken.has(c)){taken.add(c); out.push(c);}
    } return out;
  }

  /* ========= Seat templates by table size ========= */
  const TEMPLATES={
    9:["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"],
    8:["UTG","UTG+1","UTG+2","HJ","CO","BTN","SB","BB"],
    7:["UTG","UTG+1","HJ","CO","BTN","SB","BB"],
    6:["UTG","HJ","CO","BTN","SB","BB"],
    5:["UTG","CO","BTN","SB","BB"],
    4:["UTG","BTN","SB","BB"]
  };

  /* ========= State ========= */
  const state={
    players:9, seats:[], hero:"BTN",
    startStreet:"preflop", sequence:"preflop",
    hands:{}, stacks:{}, committed:{}, folded:{}, allin:{},
    currentBet:0, pot:0, board:[], street:"preflop",
    stackBB:100, handId:0,
    evLoss:0, lastSnapshot:null
  };

  /* ========= Layout seats & hero cards ========= */
  function layoutSeats(){
    seatsLayer.innerHTML=""; state.nodes={};
    const N=state.players, R=(table.clientWidth/2)-100, off=-90; // distribute around ring
    for(let i=0;i<N;i++){
      const name=state.seats[i], a=(off+(360/N)*i)*Math.PI/180;
      const x=50+(R*Math.cos(a))/(table.clientWidth/100),
            y=50+(R*Math.sin(a))/(table.clientHeight/100);
      const seat=document.createElement("div");
      seat.className="seat"+(name===state.hero?" hero":"");
      seat.style.left=x+"%"; seat.style.top=y+"%"; seat.textContent=name;
      const st=document.createElement("span"); st.className="stack"; st.id=`stack-${name}`; st.textContent="—"; seat.appendChild(st);
      const badge=document.createElement("span"); badge.className="badge-mini"; badge.textContent="ALL-IN"; seat.appendChild(badge);
      seatsLayer.appendChild(seat);
      state.nodes[name]={seat,stack:st,badge,pos:{x,y}};
    }
  }
  function renderHeroCards(){
    document.querySelectorAll(".hero-cards").forEach(n=>n.remove());
    const hero=state.hero, spot=state.nodes[hero]; if(!spot) return;
    const hc=document.createElement("div");
    hc.className="hero-cards";
    hc.style.left=spot.pos.x+"%"; hc.style.top=`calc(${spot.pos.y}% - 14px)`;
    state.hands[hero]?.forEach(c=>hc.appendChild(cardEl(c,false)));
    table.appendChild(hc);
  }
  function renderBoard(){
    boardEl.innerHTML=""; state.board.forEach(c=>boardEl.appendChild(cardEl(c,true)));
  }
  function updateStacksUI(){
    state.seats.forEach(s=>{state.nodes[s].stack.textContent=`${state.stacks[s].toFixed(1)} BB`});
  }
  function liveAccuracy(){return Math.max(0,Math.min(100,Math.round(100-state.evLoss*25)))}
  function renderHUD(){
    hudStreet.textContent=state.street[0].toUpperCase()+state.street.slice(1);
    hudPot.textContent=`Pot ${state.pot.toFixed(1)} BB`;
    const live=state.seats.filter(s=>!state.folded[s]);
    const eff = live.length? Math.min(...live.map(s=>Math.max(0.1,state.stacks[s]))): state.stackBB;
    const spr=(eff/Math.max(1,state.pot)).toFixed(1);
    hudSPR.textContent=`SPR ${spr}`;
  }
  function setPrompt(txt){ promptEl.textContent = txt || `${state.street[0].toUpperCase()+state.street.slice(1)}: Your action as ${state.hero}.`; }

  /* ========= Helpers ========= */
  function pushHistory(msg){ const p=document.createElement("p"); p.textContent=msg; sumBody.appendChild(p); }
  function chipAt(seat,text,ms=2200){
    const node=state.nodes[seat]; if(!node) return;
    const chip=document.createElement("div"); chip.className="float-chip";
    chip.style.left=node.seat.style.left; chip.style.top=node.seat.style.top; chip.textContent=`${seat}: ${text}`;
    floatLayer.appendChild(chip); setTimeout(()=>chip.remove(),ms);
    pushHistory(`${seat}: ${text}`);
  }
  function markAllIn(seat,on=true){ state.allin[seat]=on; const n=state.nodes[seat]; if(!n)return; n.seat.classList.toggle("allin",on); n.seat.classList.toggle("pulse",on); }

  /* ========= Accounting ========= */
  function resetCommitted(){ state.committed={}; state.seats.forEach(s=>state.committed[s]=0); }
  function initStreetAccounting(){
    state.currentBet=0; resetCommitted();
    if(state.street==="preflop"){
      if(state.seats.includes("SB")) { payTo("SB",0.5); }
      if(state.seats.includes("BB")) { payTo("BB",1.0); state.currentBet=1.0; }
    }
    updateStacksUI(); renderHUD();
  }
  function toCall(seat){ return Math.max(0, state.currentBet - state.committed[seat]); }
  function payTo(seat, targetTo){
    const need=Math.max(0, targetTo - state.committed[seat]);
    if(need<=0) return 0;
    const pay=Math.min(need, state.stacks[seat]);
    state.stacks[seat]=+(state.stacks[seat]-pay).toFixed(1);
    state.committed[seat]=+(state.committed[seat]+pay).toFixed(1);
    state.pot=+(state.pot+pay).toFixed(1);
    if(state.stacks[seat]<=0.0001){ state.stacks[seat]=0; markAllIn(seat,true); }
    updateStacksUI(); renderHUD(); return pay;
  }
  function equalized(){
    const canAct=state.seats.filter(s=>!state.folded[s] && !state.allin[s]);
    return canAct.every(s=> state.committed[s]===state.currentBet );
  }

  /* ========= Strength & policies ========= */
  function pfStrength([a,b]){
    const r1=RANKS.indexOf(a[0]), r2=RANKS.indexOf(b[0]);
    const pair=a[0]===b[0], suited=a[1]===b[1], gap=Math.abs(r1-r2);
    let s = pair ? (100 - r1*3) : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?6:0);
    return s + xsRand()*1.5;
  }
  function postStrength(cards,board){
    const ranks=board.map(c=>c[0]); // coarse
    const high=ranks.filter(r=>["A","K","Q","J","T"].includes(r)).length*2;
    const pair=ranks.some(r=>r===cards[0][0]||r===cards[1][0])?8:0;
    const suit=(cards[0][1]===cards[1][1])?3:0;
    return high+pair+suit+xsRand()*2;
  }
  function policy(street,seat){
    if(street==="preflop"){ const s=pfStrength(state.hands[seat]); if(s>92) return "raise_big"; if(s>82) return "raise_med"; if(s>70) return "call"; return "fold"; }
    const s=postStrength(state.hands[seat],state.board);
    if(s>16) return "bet_big"; if(s>12) return "bet_med"; if(s>8) return "bet_small"; return "check";
  }
  function evPenalty(street,actionKey,optimalKey){
    if(actionKey===optimalKey) return 0;
    const fam=a=>a.includes("raise")?"Raise":a.includes("bet")?"Bet":(a[0].toUpperCase()+a.slice(1));
    const W={preflop:{Fold:.9,Call:.5,Raise:.6,"All-in":1.1}, flop:{Check:.2,Bet:.35,"All-in":.6}, turn:{Check:.25,Bet:.45,"All-in":.8}, river:{Check:.3,Bet:.55,"All-in":1.0}};
    const k=fam(actionKey); return +((W[street][k]??.4)+xsRand()*0.15).toFixed(2);
  }

  /* ========= Buttons ========= */
  function clearActions(){ actionsEl.innerHTML=""; }
  function addBtn(label,cls,cb,disabled=false){
    const b=document.createElement("button"); b.className=`btn ${cls}`; b.textContent=label; b.onclick=cb;
    if(disabled){ b.disabled=true; }
    actionsEl.appendChild(b); return b;
  }
  /* ========= Offer hero actions (stack-aware, cinematic pacing) ========= */
  function proposeBetSizes(){
    const eff=state.stacks[state.hero];
    if(state.street==="preflop"){
      const base=Math.max(2, state.currentBet*1.6);
      const toVals=[base, Math.max(base+1, state.currentBet*2.2), Math.max(base+3, state.currentBet*3)];
      return toVals.map(v=>Math.min(state.committed[state.hero]+eff, +v.toFixed(1)));
    }
    const p=Math.max(2, state.pot);
    const vals=[Math.round(p*0.33), Math.round(p*0.5), Math.round(p*0.66)];
    return vals.map(v=>Math.min(state.committed[state.hero]+eff, v));
  }

  function offerHero(){
    clearActions();
    // busted/all-in → no betting options
    if(state.allin[state.hero] || state.stacks[state.hero]<=0){ addBtn("All-in (locked)","btn-danger",()=>{},true); return; }

    const need=toCall(state.hero), eff=state.stacks[state.hero];
    const sizes=proposeBetSizes();

    if(state.street==="preflop"){
      if(need===0) addBtn("Check","btn-ghost",()=>heroActs("check"));
      if(need>0)   addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`,"btn-primary",()=>heroActs("call"), eff<=0);
      sizes.forEach(to=>{
        const isJam = to >= state.committed[state.hero]+eff;
        const label = isJam ? "All-in" : `Raise to ${to.toFixed(1)} BB`;
        addBtn(label, isJam?"btn-danger":"btn-primary", ()=>heroActs(isJam?"allin":`raise_to:${to}`), eff<=0);
      });
      addBtn("Fold","btn-ghost",()=>heroActs("fold"), need===0); // allow fold only facing action
      if(eff>0) addBtn("All-in","btn-danger",()=>heroActs("allin"));
    } else {
      if(need===0) addBtn("Check","btn-ghost",()=>heroActs("check"));
      if(need>0)   addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`,"btn-primary",()=>heroActs("call"), eff<=0);
      sizes.forEach(to=>{
        const myTo=Math.max(state.currentBet,to);
        const isJam = myTo >= state.committed[state.hero]+eff;
        const label = isJam ? "All-in" : (need>0?`Raise to ${myTo} BB`:`Bet ${myTo} BB`);
        addBtn(label, isJam?"btn-danger":"btn-primary", ()=>heroActs(isJam?"allin":(need>0?`raise_to:${myTo}`:`bet:${myTo}`)), eff<=0);
      });
      if(eff>0) addBtn("All-in","btn-danger",()=>heroActs("allin"));
    }
  }

  /* ========= Villain actions (cinematic, stack aware) ========= */
  async function vPre(seat){
    if(state.folded[seat]||state.allin[seat]) return;
    await sleep(950 + Math.floor(xsRand()*400)); // cinematic
    const rs=state.stacks[seat], need=toCall(seat), pol=policy("preflop",seat);

    if(pol==="fold" && need>0 && xsRand()<0.72){ state.folded[seat]=true; chipAt(seat,"folds"); return; }

    if((pol==="raise_big"||pol==="raise_med") && rs>0 && xsRand()<0.58){
      const mult= pol==="raise_big" ? 3.1 : 2.4;
      let to=Math.max(state.currentBet*mult, state.currentBet+2);
      const maxTo=state.committed[seat]+rs;
      if(to>=maxTo){ state.currentBet=maxTo; payTo(seat,state.currentBet); markAllIn(seat,true); chipAt(seat,"jams"); return "jam"; }
      state.currentBet=+to.toFixed(1); payTo(seat,state.currentBet); chipAt(seat,`raises to ${state.currentBet} BB`); return;
    }

    if(need>0){
      const paid=payTo(seat,state.currentBet);
      chipAt(seat, paid>=rs? "calls all-in" : `calls ${paid.toFixed(1)} BB`);
      if(state.stacks[seat]<=0) return "jam";
    }else{
      chipAt(seat,"checks");
    }
  }

  async function vPost(seat){
    if(state.folded[seat]||state.allin[seat]) return;
    await sleep(950 + Math.floor(xsRand()*400));
    const rs=state.stacks[seat], need=toCall(seat), pol=policy(state.street,seat);

    if(need>0){
      // facing bet
      if(pol.startsWith("bet") && xsRand()<0.25 && rs>need){
        // turn into raise
        const raiseTo = state.currentBet + Math.max(2, Math.round(state.pot*0.4));
        const maxTo = state.committed[seat]+rs;
        if(raiseTo>=maxTo){ state.currentBet=maxTo; payTo(seat,state.currentBet); markAllIn(seat,true); chipAt(seat,"jams"); return "jam"; }
        state.currentBet=raiseTo; payTo(seat,state.currentBet); chipAt(seat,`raises to ${raiseTo} BB`); return;
      }
      // call or fold
      if(xsRand()<0.76 || rs<=need){
        const paid=payTo(seat, state.currentBet);
        chipAt(seat, paid>=rs? "calls all-in" : `calls ${paid.toFixed(1)} BB`);
        if(state.stacks[seat]<=0) return "jam";
      } else {
        state.folded[seat]=true; chipAt(seat,"folds");
      }
    } else {
      // no bet to face: maybe probe
      if(pol.startsWith("bet") && xsRand()<0.36 && rs>0){
        const base=Math.max(2, Math.round(state.pot*0.5));
        const to = Math.min(state.committed[seat]+rs, state.currentBet + base);
        state.currentBet=to; payTo(seat,state.currentBet);
        if(to>=state.committed[seat]+rs){ markAllIn(seat,true); chipAt(seat,"jams"); return "jam"; }
        chipAt(seat, `bets ${ (to - (state.committed[seat] - (to - state.committed[seat]))).toFixed(1) } BB`);
      } else {
        chipAt(seat,"checks");
      }
    }
  }

  /* ========= Hero action handler ========= */
  async function heroActs(action){
    if(state.allin[state.hero] || state.stacks[state.hero]<=0) return;
    // Scoring key selection
    const opt = policy(state.street, state.hero);
    const actKey = action.startsWith("raise_to")||action.startsWith("bet") ? (action.startsWith("bet")?"bet_med":"raise_med") : action;
    state.evLoss += evPenalty(state.street, actKey, opt);
    renderHUD();

    if(state.street==="preflop"){
      if(action==="fold"){ state.folded[state.hero]=true; chipAt(state.hero,"folds"); return endOrContinue(); }
      if(action==="check"){ chipAt(state.hero,"checks"); }
      if(action==="call"){
        const need=toCall(state.hero), paid=payTo(state.hero,state.currentBet);
        chipAt(state.hero, paid>=state.stacks[state.hero]+paid? "calls all-in" : `calls ${paid.toFixed(1)} BB`);
        if(state.stacks[state.hero]<=0) return allInRunout();
      }
      if(action.startsWith("raise_to:")){
        const to=parseFloat(action.split(":")[1]); state.currentBet=Math.max(state.currentBet,to);
        payTo(state.hero,state.currentBet); chipAt(state.hero,`raises to ${state.currentBet.toFixed(1)} BB`);
        if(state.stacks[state.hero]<=0){ markAllIn(state.hero,true); return allInRunout(); }
      }
      if(action==="allin"){
        const maxTo = state.committed[state.hero]+state.stacks[state.hero];
        state.currentBet=Math.max(state.currentBet,maxTo); payTo(state.hero,state.currentBet);
        markAllIn(state.hero,true); chipAt(state.hero,"jams");
        return allInRunout();
      }

      // villains after hero
      const start=state.seats.indexOf(state.hero)+1;
      for(let i=start;i<state.seats.length;i++){
        const res=await vPre(state.seats[i]); if(res==="jam") return allInRunout();
      }
      return endOrContinue();
    } else {
      if(action==="fold"){ state.folded[state.hero]=true; chipAt(state.hero,"folds"); return endOrContinue(); }
      if(action==="check"){ chipAt(state.hero,"checks"); }
      if(action==="call"){
        const paid=payTo(state.hero,state.currentBet);
        chipAt(state.hero, paid>=state.stacks[state.hero]+paid? "calls all-in" : `calls ${paid.toFixed(1)} BB`);
        if(state.stacks[state.hero]<=0) return allInRunout();
      }
      if(action.startsWith("bet:") || action.startsWith("raise_to:")){
        const to=parseFloat(action.split(":")[1]); state.currentBet=Math.max(state.currentBet,to);
        payTo(state.hero,state.currentBet);
        const verb = toCall(state.hero)>0? "raises to" : "bets";
        chipAt(state.hero, `${verb} ${state.currentBet.toFixed(1)} BB`);
        if(state.stacks[state.hero]<=0){ markAllIn(state.hero,true); return allInRunout(); }
      }
      if(action==="allin"){
        const maxTo=state.committed[state.hero]+state.stacks[state.hero];
        state.currentBet=Math.max(state.currentBet,maxTo); payTo(state.hero,state.currentBet);
        markAllIn(state.hero,true); chipAt(state.hero,"jams");
        return allInRunout();
      }

      // villains react
      for(const s of state.seats){ if(s===state.hero) continue; const res=await vPost(s); if(res==="jam") return allInRunout(); }
      return endOrContinue();
    }
  }

  /* ========= Streets & sequence ========= */
  async function endOrContinue(){
    // Move on only when active stacks have met price (or are folded/all-in)
    if(!equalized()){ offerHero(); return; }

    // Sequence cuts
    if(state.sequence==="preflop" && state.street==="preflop") return finish();
    if(state.street==="preflop"){ await dealFlop(); offerHero(); return; }
    if(state.sequence==="turn" && state.street==="turn") return finish();
    if(state.street==="flop"){ await dealTurn(); offerHero(); return; }
    if(state.street==="turn"){ await dealRiver(); return finish(); }
    if(state.street==="river") return finish();
  }

  async function allInRunout(){
    if(state.street==="preflop"){ await dealFlop(); if(state.sequence==="preflop") return finish(); }
    if(state.street==="flop"){ await dealTurn(); if(state.sequence==="turn") return finish(); }
    if(state.street==="turn"){ await dealRiver(); }
    return finish();
  }

  async function dealFlop(){
    const taken=new Set(Object.values(state.hands).flat().concat(state.board));
    state.board=deal(3,taken); state.street="flop"; initStreetAccounting(); renderBoard(); renderHUD(); await sleep(550);
  }
  async function dealTurn(){
    const taken=new Set(Object.values(state.hands).flat().concat(state.board));
    state.board=[...state.board, ...deal(1,taken)]; state.street="turn"; initStreetAccounting(); renderBoard(); renderHUD(); await sleep(550);
  }
  async function dealRiver(){
    const taken=new Set(Object.values(state.hands).flat().concat(state.board));
    state.board=[...state.board, ...deal(1,taken)]; state.street="river"; initStreetAccounting(); renderBoard(); renderHUD(); await sleep(550);
  }

  /* ========= Showdown reveal (only live seats) ========= */
  function revealSeat(seat){
    if(state.folded[seat]) return;
    const node=state.nodes[seat]; const holder=document.createElement("div");
    holder.style.position="absolute"; holder.style.left=node.seat.style.left; holder.style.top=node.seat.style.top;
    holder.style.transform="translate(-50%,-112%)"; holder.style.display="flex"; holder.style.gap="6px"; holder.style.zIndex=95;
    state.hands[seat].forEach(c=>{ const el=cardEl(c); el.style.width="66px"; el.style.height="96px"; holder.appendChild(el); });
    floatLayer.appendChild(holder);
  }
  function showdownReveal(){
    revealSeat(state.hero);
    state.seats.filter(s=>!state.folded[s] && s!==state.hero).forEach(revealSeat);
  }

  /* ========= Scoring ========= */
  // Fold junk = 100% fix: if hero folded preflop and hand strength below threshold, set 100%
  function isJunkFold(){
    if(state.street!=="preflop") return false;
    if(!state.folded[state.hero]) return false;
    const s=pfStrength(state.hands[state.hero]);
    // threshold tuned so 92o, 83o, etc. are "junk"; suited & connected get higher scores and may not be junk
    return s < 66;
  }
  function verdict(p){ return p>=85?"Excellent":p>=70?"Strong":p>=50?"Okay":"Needs Work"; }

  function computeScorePercent(){
    if(isJunkFold()) return 100;
    return liveAccuracy();
  }

  function overlayShow(pct){
    overlayScore.textContent=`${pct}%`;
    overlayScore.className=`overlay-score show ${pct>=50?'overlay-good':'overlay-bad'}`;
    setTimeout(()=>overlayScore.classList.remove("show"), 4000); // only at end
  }

  function finish(){
    showdownReveal();
    const pct=computeScorePercent();
    overlayShow(pct);

    evLine.textContent=`EV Deviation ${state.evLoss.toFixed(2)} BB`;
    gtoScore.textContent=`${pct}%`;
    gtoScore.className=`badge ${pct>=50?'score-good':'score-bad'}`;
    tutor.textContent=verdict(pct);
    summarySec.classList.remove("hidden");

    // add persistent log row
    const row=document.createElement("div"); row.className="log-item";
    row.innerHTML=`<div><span class="font-bold">${state.hero}</span> • ${state.players}-max • ${state.sequence.toUpperCase()}</div>
                   <div class="font-bold ${pct>=50?'score-good':'score-bad'}">${pct}% ${pct>=50?'✅':'❌'}</div>`;
    row.onclick=()=>replaySnapshot(state.lastSnapshot);
    logList.prepend(row);

    const store=JSON.parse(localStorage.getItem("gto_shark_log_v7")||"[]");
    store.push({ts:Date.now(), hero:state.hero, players:state.players, seq:state.sequence, score:pct, snap:state.lastSnapshot});
    localStorage.setItem("gto_shark_log_v7", JSON.stringify(store));

    // lock to next / replay
    clearActions();
    addBtn("Next Hand","btn-primary", resetHand);
    addBtn("Replay Hand","btn-ghost", ()=>replaySnapshot(state.lastSnapshot));
  }
  /* ========= Snapshot / replay ========= */
  function snapshot(){
    state.lastSnapshot = {
      rng:_seed, players:state.players, seats:state.seats.slice(), hero:state.hero,
      stackBB:state.stackBB, startStreet:state.startStreet, seq:state.sequence
    };
  }

  function rebuildFromSnapshot(snap){
    _seed=snap.rng;
    state.players=snap.players; state.seats=TEMPLATES[state.players].slice();
    layoutSeats();
    heroSel.innerHTML=state.seats.map(s=>`<option>${s}</option>`).join("");
    heroSel.value=snap.hero; state.hero=snap.hero;
    state.stackBB=snap.stackBB; state.startStreet=snap.startStreet; state.sequence=snap.seq;

    // reset per-hand
    state.hands={}; state.stacks={}; state.folded={}; state.allin={}; state.pot=0; state.board=[];
    state.seats.forEach(s=>{state.stacks[s]=state.stackBB; state.folded[s]=false; state.allin[s]=false;});

    const taken=new Set();
    state.seats.forEach(s=> state.hands[s]=deal(2,taken));

    if(state.startStreet==="preflop"){ state.board=[]; }
    if(state.startStreet==="flop"){ state.board=deal(3,taken); }
    if(state.startStreet==="turn"){ state.board=[...deal(3,taken), ...deal(1,taken)]; }
    if(state.startStreet==="river"){ state.board=[...deal(3,taken), ...deal(2,taken)]; }

    renderBoard(); renderHeroCards(); updateStacksUI();
    state.street=state.startStreet; renderHUD(); setPrompt();
    initStreetAccounting();
  }

  function replaySnapshot(snap){
    if(!snap) return;
    summarySec.classList.add("hidden"); sumBody.innerHTML="";
    rebuildFromSnapshot(snap);
    offerHero();
  }

  /* ========= New hand/reset ========= */
  async function resetHand(){
    summarySec.classList.add("hidden"); sumBody.innerHTML="";
    await seedFromAPI();

    state.players=parseInt(numSel.value,10);
    state.seats=TEMPLATES[state.players].slice();
    layoutSeats();

    // hero selector
    heroSel.innerHTML=state.seats.map(s=>`<option>${s}</option>`).join("");
    if(!state.seats.includes(heroSel.value)) heroSel.value="BTN";
    state.hero=heroSel.value;

    // per-hand reset
    state.stackBB=100;
    state.sequence=seqSel.value;
    state.startStreet="preflop";
    state.hands={}; state.stacks={}; state.folded={}; state.allin={};
    state.seats.forEach(s=>{state.stacks[s]=state.stackBB; state.folded[s]=false; state.allin[s]=false;});
    state.board=[]; state.pot=0; state.evLoss=0; state.street=state.startStreet;

    // deal cards
    const taken=new Set(); state.seats.forEach(s=> state.hands[s]=deal(2,taken));
    renderHeroCards(); renderBoard(); updateStacksUI(); renderHUD(); setPrompt();

    // blinds + preflop accounting
    initStreetAccounting();

    // pre-hero villains (to hero index)
    const idx=state.seats.indexOf(state.hero);
    for(let i=0;i<idx;i++){ await vPre(state.seats[i]); }

    offerHero();
    snapshot();
  }

  /* ========= Wiring ========= */
  newBtn.onclick=resetHand;
  againBtn.onclick=resetHand;
  replayBtn.onclick=()=>replaySnapshot(state.lastSnapshot);
  clearLog.onclick=()=>{localStorage.removeItem("gto_shark_log_v7"); logList.innerHTML="";};

  numSel.onchange=async()=>{ await resetHand(); };
  seqSel.onchange=()=>{ state.sequence=seqSel.value; };
  heroSel.onchange=()=>{ state.hero=heroSel.value; renderHeroCards(); setPrompt(); };

  /* ========= Boot ========= */
  (async function boot(){
    await seedFromAPI();
    state.players=parseInt(numSel.value,10);
    state.seats=TEMPLATES[state.players].slice();
    layoutSeats();
    heroSel.innerHTML=state.seats.map(s=>`<option>${s}</option>`).join(""); heroSel.value="BTN"; state.hero="BTN";
    await resetHand();

    // restore log
    const store=JSON.parse(localStorage.getItem("gto_shark_log_v7")||"[]");
    store.slice().reverse().forEach(e=>{
      const row=document.createElement("div"); row.className="log-item";
      row.innerHTML=`<div><span class="font-bold">${e.hero}</span> • ${e.players}-max • ${e.seq.toUpperCase()}</div>
                     <div class="font-bold ${e.score>=50?'score-good':'score-bad'}">${e.score}% ${e.score>=50?'✅':'❌'}</div>`;
      row.onclick=()=>replaySnapshot(e.snap); logList.appendChild(row);
    });
  })();

  </script>
</body>
</html>





