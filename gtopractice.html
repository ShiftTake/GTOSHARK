<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GTO Shark • Live Practice</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --ink:#e6ecff;
    --muted:#9fb2cc;
    --felt-1:#0b1a22;
    --felt-2:#0c2430;
    --felt-3:#0f2f3d;
    --indigo:#5b5ce0;
    --teal:#16c2b8;
    --hero:#29d37a;
    --act:#ffb02e;
    --bad:#ef4d4d;
    --good:#28d17c;
    --ring: rgba(91,92,224,.55);
  }
  html,body{height:100%;margin:0;background:#0b1119;color:var(--ink);font-family:Inter,system-ui,Segoe UI,Arial,sans-serif}
  .wrap{max-width:1280px;margin:0 auto;padding:18px}

  /* Header */
  .hdr{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:8px}
  .hdr h1{font-size:18px;margin:0;background:linear-gradient(90deg,#7aa0ff,#42e9da);-webkit-background-clip:text;background-clip:text;color:transparent}
  .ctl{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{display:flex;align-items:center;gap:6px;background:#0f1724;border:1px solid #20304a;color:#cfe3ff;padding:6px 10px;border-radius:999px;font-size:12px}
  select,button{background:#0f1724;border:1px solid #20304a;color:#cfe3ff;border-radius:8px;font-size:12px;padding:6px 10px}
  .btn-primary{background:linear-gradient(135deg,#6c6ef4,#4fd1c5);border:0;color:#07111a;font-weight:800}
  .btn-ghost{background:#112034}
  .btn-danger{background:linear-gradient(135deg,#ef4444,#b91c1c);border:0}

  /* Table */
  .table-area{display:grid;grid-template-columns:1fr 320px;gap:14px}
  .right{display:flex;flex-direction:column;gap:12px}
  .handlog{background:#0f1724;border:1px solid #20304a;border-radius:12px;padding:10px}
  .handlog h3{margin:.25rem 0 .5rem 0;font-size:12px;color:#a7b7d9}

  .felt-wrap{display:flex;justify-content:center;align-items:center;background:#0a1118;border:1px solid #1a2940;border-radius:16px;min-height:620px}
  .felt{
    position:relative;width:720px;height:720px;border-radius:9999px;
    background:radial-gradient(55% 55% at 50% 50%, var(--felt-3) 0%, var(--felt-2) 52%, var(--felt-1) 100%);
    box-shadow:inset 0 0 120px rgba(22,194,184,.15), 0 0 0 8px rgba(91,92,224,.2), 0 0 0 18px rgba(22,194,184,.08);
    outline:8px solid rgba(91,92,224,.35);
  }

  /* HUD center chip */
  .hud{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    display:inline-flex;gap:8px;align-items:center;
    background:#0e1826;border:1px solid #2a3a55;color:#cfe3ff;border-radius:999px;
    padding:6px 10px;font-weight:800;font-size:11px;white-space:nowrap;z-index:40
  }

  /* Seats */
  .seat{
    position:absolute;transform:translate(-50%,-50%);
    width:78px;height:78px;border-radius:999px;background:#0d1623;border:1px solid #2a3a55;
    color:#a9bed9;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:12px;
    box-shadow:0 10px 28px rgba(0,0,0,.35)
  }
  .seat.hero{border-color:#29d37a;box-shadow:0 0 0 2px rgba(41,211,122,.6),0 10px 28px rgba(0,0,0,.35);color:#c7ffdf}
  .seat.acting{border-color:#ffb02e;box-shadow:0 0 0 2px rgba(255,176,46,.75),0 10px 28px rgba(0,0,0,.35);color:#ffe6b5}
  .seat.folded{filter:grayscale(.55);opacity:.65}
  .stack{position:absolute;left:50%;top:calc(100% + 10px);transform:translateX(-50%);font-size:11px;color:#cfe3ff;background:#0e1826;border:1px solid #2a3a55;padding:2px 8px;border-radius:999px}
  .badge{position:absolute;left:50%;top:-12px;transform:translate(-50%,-50%);background:#0e1826;border:1px solid #2a3a55;color:#cfe3ff;padding:2px 8px;border-radius:999px;font-size:10px;font-weight:800}
  .badge.fold{color:#ffce74;border-color:#504020;background:#221a0e}
  .badge.allin{color:#ff9b9b;border-color:#6b1d1d;background:#1a0e0e}

  /* Hero cards */
  .hero-cards{position:absolute;display:flex;gap:10px;z-index:60;transform:translate(-50%,-65%)}
  .card{
    width:84px;height:116px;border-radius:14px;background:linear-gradient(160deg,#fff 0%,#eef2ff 60%,#e6ecff 100%);
    border:2px solid rgba(91,92,224,.85);display:flex;flex-direction:column;align-items:center;justify-content:center;
    box-shadow:0 10px 26px rgba(0,0,0,.35)
  }
  .rank{font-size:34px;font-weight:900}
  .suit{font-size:28px;margin-top:2px}
  .red{color:#e23b3b}.black{color:#0b1320}

  /* Board */
  .board{position:absolute;left:50%;top:56%;transform:translate(-50%,-50%);display:flex;gap:10px;z-index:30}
  .board .card{width:74px;height:104px;border-radius:12px}

  /* Chips / plates */
  .plate{
    position:absolute;left:50%;transform:translateX(-50%);top:-26px;
    display:flex;gap:6px;align-items:center;background:#0e1826;border:1px solid #2a3a55;color:#cfe3ff;font-weight:800;
    padding:3px 8px;border-radius:8px;font-size:11px;white-space:nowrap
  }
  .chip{width:14px;height:14px;border-radius:999px;background:
    radial-gradient(circle at 50% 50%, #f59e0b 0 26%, #6d28d9 28% 34%, #f59e0b 36% 62%, #6d28d9 64% 70%, #f59e0b 72%);border:1px solid #f59e0b}

  /* Action panel */
  .panel{grid-column:1/3;background:#0f1724;border:1px solid #20304a;border-radius:12px;padding:12px}
  .prompt{color:#9fb2cc;font-size:12px;margin:0 0 8px 0}
  .actions{display:flex;flex-wrap:wrap;gap:8px}
  .spacer{height:4px}

  /* Tiny helper text */
  .sub{font-size:11px;color:#9fb2cc}
</style>
</head>
<body>
<div class="wrap">
  <div class="hdr">
    <h1>GTO Shark • Live Practice</h1>
    <div class="ctl">
      <span class="pill">Mode
        <select id="mode">
          <option value="cash" selected>Cash (EV)</option>
          <option value="mtt">Tournament (ICM-lite)</option>
        </select>
      </span>
      <span class="pill">Players
        <select id="players">
          <option>9</option><option>8</option><option selected>6</option><option>5</option>
        </select>
      </span>
      <span class="pill">Hero
        <select id="heroSel"></select>
      </span>
      <span class="pill">Sequence
        <select id="sequence">
          <option value="preflop">Preflop only</option>
          <option value="turn">Play to Turn</option>
          <option value="river" selected>Play to River</option>
        </select>
      </span>
      <span class="pill">Scenario
        <select id="scenario">
          <option value="none" selected>None (standard)</option>
          <option value="bvb">Blind vs Blind</option>
          <option value="btnvbb">BTN vs BB</option>
          <option value="utgvbb">UTG vs BB</option>
        </select>
      </span>
      <span class="pill">Stacks (BB)
        <input id="stackBB" type="number" value="100" style="width:58px;background:#0f1724;border:1px solid #20304a;color:#cfe3ff;border-radius:6px;padding:4px 6px"/>
      </span>
      <button id="newHand" class="btn-primary">♻ New Hand</button>
    </div>
  </div>

  <div class="table-area">
    <div class="felt-wrap">
      <div id="felt" class="felt">
        <div id="hud" class="hud"><span id="hudStreet">—</span><span>|</span><span id="hudPot">Pot 0.0 BB</span><span>|</span><span id="hudSPR">SPR —</span></div>
        <div id="board" class="board"></div>
        <div id="seats"></div>
        <div id="overlay"></div>
      </div>
    </div>

    <div class="right">
      <div class="handlog">
        <h3>Hand Log</h3>
        <div class="sub">✅ ≥ 50% ❌ &lt; 50%</div>
        <div id="log"></div>
      </div>
    </div>

    <div class="panel">
      <p id="prompt" class="prompt">Loading…</p>
      <div id="actions" class="actions"></div>
    </div>
  </div>
</div>
<!-- ======= PART B script follows ======= -->
<script>
/**************
 * CONSTANTS
 **************/
const POS_9 = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"];
const POS_8 = ["UTG","UTG+1","UTG+2","HJ","CO","BTN","SB","BB"];
const POS_6 = ["UTG","HJ","CO","BTN","SB","BB"];
const POS_5 = ["UTG","CO","BTN","SB","BB"];
const TEMPLATES = {9:POS_9,8:POS_8,6:POS_6,5:POS_5};
const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const SUITS = ["♠","♥","♦","♣"];
const SUITCLASS = s => (s==="♥"||s==="♦")?"red":"black";

/**************
 * STATE
 **************/
const S = {
  mode:"cash",                                  // cash | mtt (ICM-lite toggle influences villain frequencies)
  players:6,
  seats:[],
  hero:"BTN",
  startStreet:"preflop",
  sequence:"river",
  scenario:"none",
  stackBB:100,

  street:"preflop",
  board:[],
  hands:{},          // seat -> [c1,c2]
  stacks:{},         // seat -> number
  putIn:{},          // seat -> amount contributed this street
  folded:{},         // seat -> boolean
  allin:{},          // seat -> boolean
  lastAggressor:null,
  currentBetTotal:0, // total to match this street
  lastRaiseSize:0,   // last raise size (for min re-raise rule)
  pot:0,
  toActIndex:0,      // index of next actor in order array
  order:[],          // acting order for the street
  interactingVillains:new Set(), // for showdown reveal rules
  snapshot:null
};

/**************
 * DOM REFS
 **************/
const felt = document.getElementById("felt");
const seatsLayer = document.getElementById("seats");
const overlay = document.getElementById("overlay");
const boardEl = document.getElementById("board");
const hudStreet = document.getElementById("hudStreet");
const hudPot = document.getElementById("hudPot");
const hudSPR = document.getElementById("hudSPR");
const promptEl = document.getElementById("prompt");
const actionsEl = document.getElementById("actions");
const logEl = document.getElementById("log");

const modeSel = document.getElementById("mode");
const playersSel = document.getElementById("players");
const heroSel = document.getElementById("heroSel");
const seqSel = document.getElementById("sequence");
const scSel = document.getElementById("scenario");
const stackInp = document.getElementById("stackBB");
const newBtn = document.getElementById("newHand");

/**************
 * RNG / DEAL
 **************/
let _seed = Date.now()|0;
function xorshift(){_seed^=_seed<<13;_seed^=_seed>>>17;_seed^=_seed<<5;return (_seed>>>0)/2**32;}
function pick(arr){return arr[Math.floor(xorshift()*arr.length)]}
function freshN(n,taken=new Set()){
  const out=[];
  while(out.length<n){
    const c = pick(RANKS)+pick(SUITS);
    if(!taken.has(c)){taken.add(c);out.push(c);}
  }
  return out;
}
function cardEl(c,small=false){
  const el=document.createElement("div");
  el.className="card"+(small?" small":"");
  el.innerHTML=`<div class="rank ${SUITCLASS(c[1])}">${c[0]}</div><div class="suit ${SUITCLASS(c[1])}">${c[1]}</div>`;
  return el;
}

/**************
 * LAYOUT
 **************/
const NODES = {}; // seat -> {seat, stack, badge}
function layoutSeats(){
  seatsLayer.innerHTML="";
  const N=S.players;
  const r=(felt.clientWidth/2)-86;
  const off=-90;
  NODES._list = [];
  for(let i=0;i<N;i++){
    const name=S.seats[i];
    const a=(off+(360/N)*i)*Math.PI/180;
    const x= felt.clientWidth/2 + r*Math.cos(a);
    const y= felt.clientHeight/2 + r*Math.sin(a);

    const seat=document.createElement("div");
    seat.className="seat";
    seat.style.left=`${x}px`; seat.style.top=`${y}px`;
    seat.dataset.pos=name; seat.textContent=name;

    const st=document.createElement("div"); st.className="stack"; st.id=`stack-${name}`; st.textContent="—";
    const badge=document.createElement("div"); badge.className="badge"; badge.textContent=name; badge.style.display="none";

    seat.appendChild(st); seat.appendChild(badge);
    seatsLayer.appendChild(seat);
    NODES[name]={seat,stack:st,badge,pos:[x,y]};
    NODES._list.push(name);
  }
  // hero highlight
  for(const s of S.seats) NODES[s].seat.classList.toggle("hero", s===S.hero);
}

/**************
 * RENDER HELPERS
 **************/
function setActing(seat,on){
  for(const s of S.seats) NODES[s].seat.classList.remove("acting");
  if(on) NODES[seat]?.seat.classList.add("acting");
}
function setFold(seat){
  S.folded[seat]=true;
  NODES[seat].seat.classList.add("folded");
  NODES[seat].badge.style.display="block";
  NODES[seat].badge.textContent="FOLD";
  NODES[seat].badge.classList.add("fold");
}
function setAllIn(seat){
  S.allin[seat]=true;
  NODES[seat].badge.style.display="block";
  NODES[seat].badge.textContent="ALL-IN";
  NODES[seat].badge.classList.add("allin");
}
function clearBadges(){
  for(const s of S.seats){ const b=NODES[s].badge; b.style.display="none"; b.classList.remove("fold","allin"); b.textContent=s; }
}
function renderStacks(){
  for(const s of S.seats){
    NODES[s].stack.textContent = `${S.stacks[s].toFixed(1)} BB`;
  }
}
function renderBoard(){
  boardEl.innerHTML="";
  S.board.forEach(c=>boardEl.appendChild(cardEl(c,true)));
}
function renderHeroCards(){
  // wipe previous
  for(const el of felt.querySelectorAll(".hero-cards")) el.remove();
  const pos = NODES[S.hero]?.pos; if(!pos) return;
  const hc=document.createElement("div"); hc.className="hero-cards";
  hc.style.left=pos[0]+"px"; hc.style.top=pos[1]+"px";
  S.hands[S.hero].forEach(c=>hc.appendChild(cardEl(c,false)));
  felt.appendChild(hc);
}
function hud(){
  hudStreet.textContent = S.street.toUpperCase();
  hudPot.textContent = `Pot ${S.pot.toFixed(1)} BB`;
  const live = S.seats.filter(p=>!S.folded[p]);
  const eff = live.length ? Math.min(...live.map(p=>Math.max(.1,S.stacks[p]))) : S.stackBB;
  const spr = (eff/Math.max(1,S.pot)).toFixed(1);
  hudSPR.textContent = `SPR ${spr}`;
}
function plate(seat,label,sticky=false){
  const p=document.createElement("div");
  p.className="plate"; p.style.left=NODES[seat].seat.style.left; p.style.top=`calc(${NODES[seat].seat.style.top} - 40px)`;
  p.innerHTML=`<span class="chip"></span>${label}`;
  overlay.appendChild(p);
  if(!sticky) setTimeout(()=>p.remove(), 2000);
}

/**************
 * ORDER & STREET INITIALIZATION
 **************/
function orderPreflop(){
  // action starts UTG, ends BB
  const arr = S.seats.slice(); // positions already in table order clockwise UTG..BB
  const start = arr.indexOf("UTG");
  return [...arr.slice(start), ...arr.slice(0,start)];
}
function orderPostflop(){
  // action starts SB (or next active left to BTN) and goes to BTN last
  const arr = S.seats.slice();
  const start = arr.indexOf("SB");
  return [...arr.slice(start), ...arr.slice(0,start)];
}
function resetContrib(){
  S.putIn={}; for(const s of S.seats) S.putIn[s]=0;
}
function initStreet(kind){
  S.street=kind; resetContrib(); S.currentBetTotal=0; S.lastRaiseSize=0; S.lastAggressor=null;
  clearBadges(); overlay.innerHTML="";
  if(kind==="preflop"){
    // blinds
    S.putIn["SB"]=0.5; S.stacks["SB"]=+(S.stacks["SB"]-0.5).toFixed(1); S.pot+=0.5;
    S.putIn["BB"]=1.0; S.stacks["BB"]=+(S.stacks["BB"]-1.0).toFixed(1); S.pot+=1.0;
    S.currentBetTotal=1.0;
    S.order = orderPreflop();
  }else{
    S.order = orderPostflop();
  }
  S.toActIndex = 0;
  renderStacks(); hud();
}
/**************
 * STREET ENDING RULES (robust)
 **************/
function everyoneMatched(){
  const active = S.seats.filter(p=>!S.folded[p] && !S.allin[p]);
  return active.every(p => S.putIn[p] === S.currentBetTotal);
}
function impliedAggressorForStreet(){
  // Preflop: if no raise happened, BB is implied aggressor. Postflop with no bet → lastAggressor stays null and everyoneMatched triggers street end.
  if(S.street==="preflop" && S.lastAggressor==null) return "BB";
  return S.lastAggressor;
}
function shouldCloseRound(nextSeat){
  // Close when all active matched AND action has returned to aggressor (or implied BB)
  const aggr = impliedAggressorForStreet();
  if(!everyoneMatched()) return false;
  if(aggr==null) return true;                // postflop check-around
  return nextSeat===aggr;                    // action has circled back to aggressor, who cannot act again
}

/**************
 * MIN-RAISE / PAY / ACCOUNTING
 **************/
function toCall(p){ return Math.max(0, S.currentBetTotal - S.putIn[p]); }
function minRaiseTotal(){
  // if no raise yet this street → min raise size equals BB (1) preflop, else lastRaiseSize
  const base = (S.street==="preflop" && S.lastRaiseSize===0) ? 1.0 : S.lastRaiseSize;
  return +(S.currentBetTotal + base).toFixed(1);
}
function commit(p, targetTotal){
  // Move chips to the pot up to targetTotal
  const need = Math.max(0, targetTotal - S.putIn[p]);
  const pay = Math.min(need, S.stacks[p]);
  S.stacks[p] = +(S.stacks[p]-pay).toFixed(1);
  S.putIn[p]   = +(S.putIn[p]+pay).toFixed(1);
  S.pot        = +(S.pot+pay).toFixed(1);
  renderStacks(); hud();
  if(S.stacks[p]===0) setAllIn(p);
  return pay;
}

/**************
 * SIMPLE “GTO-ish” villain policy (frequency-mixed)
 * (lightweight but non-trivial; uses RNG for mixed actions and mode)
 **************/
function rankStrength([a,b]){
  const r1=RANKS.indexOf(a[0]), r2=RANKS.indexOf(b[0]);
  const pair = a[0]===b[0], suited=a[1]===b[1], gap=Math.abs(r1-r2);
  let base = pair? (96 - r1*2.5) : (76 - Math.min(r1,r2)*3.2) + (suited?5.5:0) + (gap<=1?5:0);
  return Math.max(0, Math.min(98, base + xorshift()*2));
}
function boardPressure(cards,board){
  const highs = board.filter(c=>"AKQJT".includes(c[0])).length;
  const pair = board.some(c=>c[0]===cards[0][0]||c[0]===cards[1][0]);
  return highs*2 + (pair?5:0) + (cards[0][1]===cards[1][1]?2:0) + xorshift()*1.5;
}
function villainPolicy(seat){
  if(S.street==="preflop"){
    const s = rankStrength(S.hands[seat]);
    // Mode tilt: MTT tightens
    const tilt = (S.mode==="mtt") ? -6 : 0;
    const val = s + tilt;
    // Mixed frequencies
    if(val>90) return (xorshift()<0.55)?"raise_big":"raise_med";
    if(val>80) return (xorshift()<0.50)?"raise_med":"call";
    if(val>70) return (xorshift()<0.70)?"call":"fold";
    return (xorshift()<0.85)?"fold":"call";
  }else{
    const s = boardPressure(S.hands[seat],S.board);
    if(s>14) return (xorshift()<0.55)?"bet_big":"bet_med";
    if(s>10) return (xorshift()<0.60)?"bet_med":"check";
    if(s>7)  return (xorshift()<0.40)?"bet_small":"check";
    return "check";
  }
}
/**************
 * HERO UI
 **************/
function clearActions(){ actionsEl.innerHTML=""; }
function addBtn(label,cls,cb,disabled=false){ const b=document.createElement("button"); b.className=cls; b.textContent=label; b.disabled=!!disabled; b.onclick=cb; actionsEl.appendChild(b); return b; }
function heroOffer(){
  clearActions();
  const h=S.hero; const need=toCall(h); const eff=S.stacks[h];
  const minTo = minRaiseTotal();

  // Fold always available
  addBtn("Fold","btn-ghost", ()=>heroAct({type:"fold"}));

  if(need===0) addBtn("Check","btn-ghost", ()=>heroAct({type:"check"}));
  if(need>0)   addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`, "btn-primary", ()=>heroAct({type:"call"}));

  // Bet/Raise sizes (sticky plates remain until street advances)
  const potsz = Math.max(2, S.pot);
  const sizes = (S.street==="preflop")
    ? [Math.max(2, S.currentBetTotal*2), Math.max(3, S.currentBetTotal*2.5), Math.max(4, S.currentBetTotal*3)]
    : [Math.round(potsz*0.33), Math.round(potsz*0.5), Math.round(potsz*0.66)];

  for(const to of sizes){
    const toTotal = Math.max(minTo, +(to).toFixed(1));
    const label = (need>0) ? `Raise to ${toTotal} BB` : `Bet ${toTotal} BB`;
    addBtn(label,"btn-primary", ()=>heroAct({type:(need>0?"raise":"bet"), to:toTotal}));
  }

  if(eff>0) addBtn("All-in","btn-danger", ()=>heroAct({type:"allin"}));
  promptEl.textContent = `${S.street.toUpperCase()}: Your action as ${S.hero}.`;
}

/**************
 * ACTION ENGINE (with strict raise legality + round termination)
 **************/
function advanceToNextActor(){
  // Move pointer to next active, skipping folds/all-ins
  const n=S.order.length;
  for(let step=1; step<=n; step++){
    S.toActIndex = (S.toActIndex + 1) % n;
    const seat=S.order[S.toActIndex];
    if(!S.folded[seat] && !S.allin[seat]) return seat;
  }
  return null; // no eligible actor
}

function endRoundOrAdvance(nextSeatFromCurrent){
  const closingSeat = advanceToNextActor(); // where action would go if not closing
  const close = shouldCloseRound(closingSeat ?? nextSeatFromCurrent);
  if(!close){ setActing(closingSeat,true); if(closingSeat===S.hero) heroOffer(); else villainTurn(closingSeat); return; }

  // Move all street contributions to the pot (already in S.pot) & advance street
  S.putIn={...S.putIn}; // (kept for potential side-pots in future)
  if(S.sequence==="preflop" && S.street==="preflop"){ return finishHand(); }

  if(S.street==="preflop"){ dealFlop(); initStreet("flop"); }
  else if(S.street==="flop"){ if(S.sequence==="turn") return finishHand(); dealTurn(); initStreet("turn"); }
  else if(S.street==="turn"){ dealRiver(); initStreet("river"); }
  else { return finishHand(); }

  // New street: if hero next, show actions; otherwise roll villains until hero
  const first = S.order[S.toActIndex]; setActing(first,true);
  if(first===S.hero) heroOffer(); else villainTurn(first);
}

function legalizeRaise(totalWanted){
  const minTotal = minRaiseTotal();
  return Math.max(minTotal, totalWanted);
}

function treatAllInAsRaise(newTo, prevTotal){
  // Under-raise all-in is treated as CALL; do not set lastAggressor nor lastRaiseSize
  const isRaise = newTo > S.currentBetTotal && (newTo - S.currentBetTotal) >= (S.lastRaiseSize || (S.street==="preflop"?1.0:0));
  if(isRaise){
    S.lastRaiseSize = +(newTo - S.currentBetTotal).toFixed(1);
    S.currentBetTotal = newTo;
    return true;
  }
  // treat as call
  return false;
}

function heroAct(a){
  const p=S.hero, prev=S.currentBetTotal;
  if(a.type==="fold"){ setFold(p); plate(p,"Fold"); return endRoundOrAdvance(); }

  if(a.type==="check"){
    if(toCall(p)>0) return; plate(p,"Check"); return endRoundOrAdvance();
  }

  if(a.type==="call"){
    const paid=commit(p,S.currentBetTotal); plate(p,`Call ${paid.toFixed(1)} BB`,true);
    S.interactingVillains.add(p);
    if(S.allin[p]) setAllIn(p);
    return endRoundOrAdvance();
  }

  if(a.type==="bet"){
    // first bet post-flop: set currentBetTotal to 'to'
    const to=legalizeRaise(a.to);
    S.lastRaiseSize = (S.currentBetTotal===0) ? Math.max(1.0, to) : +(to - S.currentBetTotal).toFixed(1);
    S.currentBetTotal = to;
    commit(p,S.currentBetTotal); plate(p,`Bet ${(S.currentBetTotal).toFixed(1)} BB`,true);
    S.lastAggressor = p; S.interactingVillains.add(p);
    return endRoundOrAdvance();
  }

  if(a.type==="raise"){
    const to=legalizeRaise(a.to);
    S.lastRaiseSize = +(to - S.currentBetTotal).toFixed(1);
    S.currentBetTotal = to;
    commit(p,S.currentBetTotal); plate(p,`Raise to ${to.toFixed(1)} BB`,true);
    S.lastAggressor = p; S.interactingVillains.add(p);
    return endRoundOrAdvance();
  }

  if(a.type==="allin"){
    const maxTo = S.putIn[p] + S.stacks[p];
    const newTo = Math.max(S.currentBetTotal, +(maxTo).toFixed(1));
    const wasRaise = treatAllInAsRaise(newTo, prev);
    commit(p,newTo); plate(p,"All-in",true); if(wasRaise) S.lastAggressor=p;
    S.interactingVillains.add(p);
    return endRoundOrAdvance();
  }
}

/**************
 * VILLAIN TURN
 **************/
function villainTurn(seat){
  if(S.folded[seat]||S.allin[seat]) return endRoundOrAdvance();
  setActing(seat,true);

  // tiny delay for cinematic pacing
  setTimeout(()=>{
    const need=toCall(seat);
    const pol=villainPolicy(seat);

    if(need>0){
      // facing bet/raise: fold/call/raise
      if(pol.startsWith("raise") && S.stacks[seat] > need){
        const base = pol==="raise_big" ? Math.max(3, S.currentBetTotal + Math.round(S.pot*0.5))
                                       : Math.max(2, S.currentBetTotal + Math.round(S.pot*0.33));
        const to = legalizeRaise(base);
        commit(seat,to);
        plate(seat,`Raise to ${to.toFixed(1)} BB`,true);
        S.lastRaiseSize = +(to - S.currentBetTotal).toFixed(1);
        S.currentBetTotal = to;
        S.lastAggressor = seat; S.interactingVillains.add(seat);
        return endRoundOrAdvance();
      }
      // call (or call all-in)
      const paid=commit(seat,S.currentBetTotal);
      if(paid===0 && S.stacks[seat]===0){ setAllIn(seat); }
      plate(seat, paid>=S.stacks[seat]+paid ? "Call all-in" : `Call ${paid.toFixed(1)} BB`, true);
      S.interactingVillains.add(seat);
      return endRoundOrAdvance();
    }else{
      // no bet: check or bet
      if(pol.startsWith("bet") && S.stacks[seat]>0){
        const base = pol==="bet_big"? Math.round(S.pot*0.66) : pol==="bet_med"? Math.round(S.pot*0.5) : Math.round(S.pot*0.33);
        const to = Math.max(1, base);
        S.currentBetTotal = to;
        S.lastRaiseSize = (S.street==="preflop")?1.0:to; // first bet sets raise size baseline
        commit(seat,to);
        plate(seat,`Bet ${to.toFixed(1)} BB`,true);
        S.lastAggressor = seat; S.interactingVillains.add(seat);
        return endRoundOrAdvance();
      }
      plate(seat,"Check");
      return endRoundOrAdvance();
    }
  }, 450);
}

/**************
 * DEAL RUNOUT
 **************/
function dealFlop(){ const t=new Set(Object.values(S.hands).flat().concat(S.board)); S.board = freshN(3,t); renderBoard(); hud(); }
function dealTurn(){ const t=new Set(Object.values(S.hands).flat().concat(S.board)); S.board = [...S.board, ...freshN(1,t)]; renderBoard(); hud(); }
function dealRiver(){ const t=new Set(Object.values(S.hands).flat().concat(S.board)); S.board = [...S.board, ...freshN(1,t)]; renderBoard(); hud(); }

/**************
 * FINISH / SHOWDOWN (show hero + opponents who reached showdown vs hero)
 **************/
function finishHand(){
  // reveal rule: only hero + villains who interacted and didn’t fold
  const show = new Set([S.hero, ...S.seats.filter(p=>p!==S.hero && !S.folded[p] && (S.interactingVillains.has(p)))]);
  for(const el of overlay.querySelectorAll(".reveal")) el.remove();
  for(const p of show){
    const h=S.hands[p]; if(!h) continue;
    const holder=document.createElement("div");
    holder.className="reveal"; holder.style.position="absolute";
    holder.style.left=NODES[p].seat.style.left; holder.style.top=NODES[p].seat.style.top;
    holder.style.transform="translate(-50%,-115%)"; holder.style.display="flex"; holder.style.gap="6px"; holder.style.zIndex=70;
    h.forEach(c=>holder.appendChild(cardEl(c,true)));
    overlay.appendChild(holder);
  }

  clearActions();
  addBtn("Next Hand","btn-primary", startNewHand);
  promptEl.textContent="Hand complete. Click Next Hand.";
  logEl.insertAdjacentHTML("afterbegin", `<div class="sub">Hand • ${S.street.toUpperCase()} • Pot ${S.pot.toFixed(1)} BB</div>`);
}

/**************
 * SCENARIO PRESETS
 **************/
function applyScenario(){
  if(S.scenario==="bvb"){
    // everyone else folded preflop, SB acts first vs BB
    for(const p of S.seats){ if(p!=="SB"&&p!=="BB") S.folded[p]=true; }
  }else if(S.scenario==="btnvbb"){
    for(const p of S.seats){ if(!["BTN","BB"].includes(p)) S.folded[p]=true; }
    // force BTN to act preflop first (UTG path bypassed by folds)
  }else if(S.scenario==="utgvbb"){
    for(const p of S.seats){ if(!["UTG","BB"].includes(p)) S.folded[p]=true; }
  }
}

/**************
 * NEW HAND (auto-start safe)
 **************/
function startNewHand(){
  // reset state
  overlay.innerHTML=""; boardEl.innerHTML=""; clearActions(); promptEl.textContent="Dealing…";
  S.players = +playersSel.value;
  S.seats   = TEMPLATES[S.players].slice();
  heroSel.innerHTML = S.seats.map(s=>`<option ${s===S.hero?"selected":""}>${s}</option>`).join("");
  if(!S.seats.includes(S.hero)) S.hero="BTN";
  S.sequence = seqSel.value; S.scenario = scSel.value; S.mode = modeSel.value; S.stackBB = Math.max(10, +stackInp.value||100);

  // layout after a frame so sizes are correct
  requestAnimationFrame(()=>{
    layoutSeats();
    for(const s of S.seats){ S.stacks[s]=S.stackBB; S.folded[s]=false; S.allin[s]=false; }
    // deal
    const taken=new Set();
    for(const s of S.seats){ S.hands[s]=freshN(2,taken); }
    S.board=[]; S.pot=0; S.interactingVillains=new Set();

    renderStacks(); renderBoard(); renderHeroCards(); hud();

    // start street
    initStreet("preflop");
    applyScenario();

    // preflop: advance until first eligible actor (UTG unless folded by scenario)
    let first = S.order[S.toActIndex];
    while(S.folded[first]||S.allin[first]){ S.toActIndex=(S.toActIndex+1)%S.order.length; first=S.order[S.toActIndex]; }
    setActing(first,true);
    if(first===S.hero) heroOffer(); else villainTurn(first);
  });
}

/**************
 * WIRING + BOOT
 **************/
newBtn.onclick = startNewHand;
playersSel.onchange = ()=>startNewHand();
seqSel.onchange = ()=>startNewHand();
scSel.onchange = ()=>startNewHand();
modeSel.onchange = ()=>startNewHand();
stackInp.onchange = ()=>startNewHand();
heroSel.onchange = ()=>{ S.hero=heroSel.value; layoutSeats(); renderHeroCards(); };

window.addEventListener("load", ()=>{
  // initial selections & seat list
  S.players=+playersSel.value; S.seats=TEMPLATES[S.players].slice(); heroSel.innerHTML=S.seats.map(s=>`<option>${s}</option>`).join("");
  if(!S.seats.includes(S.hero)) S.hero="BTN"; heroSel.value=S.hero;
  layoutSeats();
  // ensure felt measured
  requestAnimationFrame(startNewHand);
});
</script>
</body>
</html>

