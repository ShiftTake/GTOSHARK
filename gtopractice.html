<script>
/* ========= GTO Shark — Core Engine Scaffold (Part 1/3) =========
   - State model (S)
   - Seat templates and correct action order per street
   - Deck & dealing utilities (unique card draw)
   - Hero cards rendered above hero seat (big, not cut by table)
   - Blind posting with precise pot math (SB 0.5, BB 1.0 preflop)
   - HUD (Pot / SPR / Street) kept accurate
   - Visual chips in front of acting players (persist until street changes)
   ================================================================= */

(function(){
  // ---- DOM anchors expected from your layout ----
  const table       = document.getElementById("table");        // the big ring container
  const seatsLayer  = document.getElementById("seatsLayer");    // seat nodes get injected here
  const boardEl     = document.getElementById("board");         // community cards
  const hudStreet   = document.getElementById("hudStreet");
  const hudPot      = document.getElementById("hudPot");
  const hudSPR      = document.getElementById("hudSPR");
  const actionsEl   = document.getElementById("actions");       // (buttons go here in Part 2)
  const floatLayer  = document.getElementById("floatLayer");    // floating chips / reveals
  const narrBox     = document.getElementById("narrationBox");  // optional narrator (module you added)

  // Convenience narrator
  function narr(msg){ if(narrBox){ const d=document.createElement("div"); d.style.color="#c7d2fe"; d.className="fade-in"; d.textContent=msg; narrBox.appendChild(d); narrBox.scrollTop=narrBox.scrollHeight; } }

  // ---- Global state (S) ----
  window.S = {
    // Table config
    playersMax: 9,
    seats: [],            // seat labels in clockwise order
    hero: "BTN",          // hero seat label
    bbSize: 1.0,          // 1.0 = 1BB; SB will be 0.5
    stackBB: 100,         // default starting stack for everyone (modifiable elsewhere)

    // Hand state
    street: "preflop",    // preflop | flop | turn | river | showdown
    board: [],            // community cards: ["A♠","J♦","5♣",...]
    hands: {},            // seat -> [c1,c2]
    stacks: {},           // seat -> remaining BB
    committed: {},        // seat -> chips committed *this* street (for toCall math)
    inPot: {},            // seat -> chips committed total this hand (for display)
    folded: {},           // seat -> boolean
    allin: {},            // seat -> boolean
    pot: 0,               // total main pot in BB (side pots in Part 3 if needed)

    // Betting round
    currentBet: 0,        // CurrentBetTotal (CB)
    lastRaiseSize: 0,     // LastRaiseSize (LRS)
    actedThisRound: {},   // seat -> boolean (used to detect equalization)

    // UI nodes cache
    nodes: {},            // seat -> { seatEl, stackEl, name, xy }

    // RNG
    seed: Date.now()|0,
  };

  // ---- Seat templates for 9-max standard order (clockwise around table) ----
  // We'll use these as seat names and *also* action order baselines.
  const TEMPLATE_9MAX = ["SB","BB","UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN"];

  // ---- Utility: seeded RNG ----
  function xsSeed(n){ S.seed = (n>>>0) || 2463534242; }
  function xsRand(){ S.seed ^= S.seed<<13; S.seed ^= S.seed>>>17; S.seed ^= S.seed<<5; return ((S.seed>>>0)%1e5)/1e5; }

  // ---- Cards helpers ----
  const RANKS=["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
  const SUITS=["♠","♥","♦","♣"];
  const RED   = s => (s==="♥"||s==="♦");

  function drawUnique(n, taken){
    const out=[];
    while(out.length<n){
      const c = RANKS[Math.floor(xsRand()*13)] + SUITS[Math.floor(xsRand()*4)];
      if(!taken.has(c)){ taken.add(c); out.push(c); }
    }
    return out;
  }

  function cardEl(card, isBoard=false){
    const r=card[0], s=card[1];
    const el=document.createElement("div");
    el.className = isBoard ? "card board-card" : "card";
    el.innerHTML = `
      <div class="rank ${RED(s)?'red':'black'}">${r}</div>
      <div class="suit ${RED(s)?'red':'black'}">${s}</div>
    `;
    return el;
  }

  // ---- Seat placement & UI ----
  function placeSeats(){
    seatsLayer.innerHTML = "";
    S.nodes = {};
    // radius tuned to avoid cards being cut off on 1080p
    const R = (table.clientWidth/2) - 105;
    const center = { x: table.clientWidth/2, y: table.clientHeight/2 };

    // Distribute clockwise, starting with TEMPLATE_9MAX order
    S.seats.forEach((name, i)=>{
      const angle = ((-90) + (360/S.seats.length)*i) * Math.PI/180;
      const px = center.x + R*Math.cos(angle);
      const py = center.y + R*Math.sin(angle);

      const seat = document.createElement("div");
      seat.className = "seat" + (name===S.hero ? " hero" : "");
      seat.dataset.seat = name;
      seat.textContent = name;

      // Position
      seat.style.left = (px/table.clientWidth*100) + "%";
      seat.style.top  = (py/table.clientHeight*100) + "%";

      // Stack badge
      const st = document.createElement("span");
      st.className = "stack";
      st.id = `stack-${name}`;
      st.textContent = `${S.stackBB.toFixed(1)} BB`;
      seat.appendChild(st);

      seatsLayer.appendChild(seat);

      S.nodes[name] = {
        seatEl: seat,
        stackEl: st,
        name,
        xy: { left: seat.style.left, top: seat.style.top }
      };
    });
  }

  function setHeroHighlight(){
    S.seats.forEach(seat=>{
      S.nodes[seat].seatEl.classList.toggle("hero", seat===S.hero);
    });
  }

  // Hero cards above seat (not clipped)
  function renderHeroCards(){
    // remove old holders
    document.querySelectorAll(".hero-cards").forEach(n=>n.remove());
    const hero = S.hero;
    const node = S.nodes[hero]; if(!node) return;

    const holder = document.createElement("div");
    holder.className = "hero-cards";
    // position a touch above hero circle
    holder.style.left = node.xy.left;
    // pull upward slightly; if near top, nudge down
    const topPct = parseFloat(node.xy.top);
    const y = topPct > 70 ? (topPct - 14) : (topPct - 8);
    holder.style.top = y + "%";

    (S.hands[hero]||[]).forEach(c=>holder.appendChild(cardEl(c,false)));
    table.appendChild(holder);
  }

  // Board render
  function renderBoard(){
    boardEl.innerHTML = "";
    S.board.forEach(c=> boardEl.appendChild(cardEl(c,true)));
  }

  // HUD (Pot, SPR, Street)
  function updateHUD(){
    const live = S.seats.filter(s=>!S.folded[s]);
    const eff  = live.length ? Math.min(...live.map(s=> Math.max(0.01, S.stacks[s]))) : S.stackBB;
    const spr  = eff/Math.max(1, S.pot);
    hudStreet.textContent = S.street[0].toUpperCase() + S.street.slice(1);
    hudPot.textContent    = `Pot ${S.pot.toFixed(1)} BB`;
    hudSPR.textContent    = `SPR ${spr.toFixed(1)}`;
  }

  // Update stack badges
  function updateStacks(){
    S.seats.forEach(seat=>{
      S.nodes[seat].stackEl.textContent = `${S.stacks[seat].toFixed(1)} BB`;
    });
  }

  // ---- Floating chip plaques that PERSIST for the street (cleared on street change) ----
  // We keep one plaque per seat id "plaque-<seat>" so it updates (not disappears) when multiple calls/raises happen in a round
  function setStreetPlaque(seat, label){
    let p = document.getElementById(`plaque-${seat}`);
    if(!p){
      p = document.createElement("div");
      p.id = `plaque-${seat}`;
      p.className = "bet-chip"; // styled in your CSS
      p.style.left = S.nodes[seat].xy.left;
      // Put in front (toward table center) — slightly above seat center
      const topPct = parseFloat(S.nodes[seat].xy.top);
      p.style.top  = (topPct - 6) + "%";
      p.style.opacity = "1";
      p.style.animation = "none"; // persistent (no auto fade)
      floatLayer.appendChild(p);
    }
    p.innerHTML = `<span class="chip-icon"></span><span>${label}</span>`;
  }

  function clearStreetPlaques(){
    S.seats.forEach(seat=>{
      const p = document.getElementById(`plaque-${seat}`);
      if(p) p.remove();
    });
  }

  // ---- Accounting primitives (commit chips, toCall, min-raise calc) ----
  function commit(seat, amount){
    // clip by stack
    const pay = Math.max(0, Math.min(amount, S.stacks[seat]));
    if(pay<=0) return 0;

    S.stacks[seat]     = +(S.stacks[seat] - pay).toFixed(2);
    S.committed[seat]  = +((S.committed[seat]||0) + pay).toFixed(2);
    S.inPot[seat]      = +((S.inPot[seat]||0) + pay).toFixed(2);
    S.pot              = +(S.pot + pay).toFixed(2);

    updateStacks(); updateHUD();
    return pay;
  }

  function toCall(seat){
    return Math.max(0, +(S.currentBet - (S.committed[seat]||0)).toFixed(2));
  }

  function setCurrentBet(newTotal){
    // newTotal is the total each player must match this round
    const prev = S.currentBet;
    S.currentBet = +newTotal.toFixed(2);
    const raiseSize = +(S.currentBet - prev).toFixed(2);
    if(raiseSize > 0){
      // If there's no previous raise yet (preflop first raise), LRS = BB
      if(prev===0 && S.street==="preflop"){
        S.lastRaiseSize = Math.max(S.bbSize, raiseSize);
      }else{
        S.lastRaiseSize = raiseSize;
      }
    }
  }

  function minRaiseTo(){
    // Minimum legal *total* a raise must set: CB + LRS
    if(S.currentBet===0){
      // postflop first bet: minimum is 1BB open
      return S.bbSize;
    }
    const lrs = S.lastRaiseSize || S.bbSize; // first raise uses BB
    return +(S.currentBet + lrs).toFixed(2);
  }

  // ---- Mark fold / acting glow helpers ----
  function markFold(seat){
    S.folded[seat] = true;
    const el = S.nodes[seat].seatEl;
    el.classList.add("folded");
    const text = el.textContent;
    el.textContent = "FOLD";
    // brief orange "Fold" then restore label (keeps folded style)
    setTimeout(()=>{ el.textContent = text; }, 1000);
  }

  function setActing(seat, on){
    S.seats.forEach(s=> S.nodes[s].seatEl.classList.toggle("acting", false));
    if(on) S.nodes[seat].seatEl.classList.add("acting");
  }

  // ---- Street init & blinds ----
  function resetRoundFlags(){
    S.seats.forEach(seat=>{
      S.committed[seat] = 0;
      S.actedThisRound[seat] = false;
    });
    S.currentBet   = 0;
    S.lastRaiseSize= 0;
    clearStreetPlaques();
  }

  function postBlinds(){
    // SB 0.5BB, BB 1.0BB (if present and not folded)
    resetRoundFlags();
    if(S.seats.includes("SB")){
      const paid = commit("SB", 0.5*S.bbSize);
      setStreetPlaque("SB", `${paid.toFixed(1)} BB`);
    }
    if(S.seats.includes("BB")){
      const paid = commit("BB", 1.0*S.bbSize);
      setStreetPlaque("BB", `${paid.toFixed(1)} BB`);
      S.currentBet = 1.0*S.bbSize;
      S.lastRaiseSize = S.bbSize; // first raise reference for preflop
    }
  }

  // ---- Dealing helpers ----
  function dealHole(){
    const taken = new Set();
    S.seats.forEach(seat=>{
      S.hands[seat] = drawUnique(2, taken);
    });
  }

  function dealFlop(){
    const taken = new Set(Object.values(S.hands).flat());
    S.board = drawUnique(3, taken);
    S.street = "flop";
    resetRoundFlags();
    renderBoard(); updateHUD();
    narr("Flop is dealt.");
  }

  function dealTurn(){
    const taken = new Set(Object.values(S.hands).flat().concat(S.board));
    S.board.push(...drawUnique(1, taken));
    S.street = "turn";
    resetRoundFlags();
    renderBoard(); updateHUD();
    narr("Turn card is dealt.");
  }

  function dealRiver(){
    const taken = new Set(Object.values(S.hands).flat().concat(S.board));
    S.board.push(...drawUnique(1, taken));
    S.street = "river";
    resetRoundFlags();
    renderBoard(); updateHUD();
    narr("River card is dealt.");
  }

  // ---- Boot / New hand scaffold ----
  async function newHandScaffold({players=9, hero="BTN", bb=1.0, stack=100}={}){
    // Init table config
    S.playersMax = players;
    S.seats = TEMPLATE_9MAX.slice(0, players); // use leading seats for smaller tables
    S.hero  = S.seats.includes(hero) ? hero : "BTN";
    S.bbSize = bb;
    S.stackBB = stack;

    // Reset per-hand state
    S.street = "preflop";
    S.board = [];
    S.hands = {};
    S.stacks = {};
    S.committed = {};
    S.inPot = {};
    S.folded = {};
    S.allin = {};
    S.actedThisRound = {};
    S.pot = 0;
    S.currentBet = 0;
    S.lastRaiseSize = 0;

    // Layout seats fresh
    placeSeats();
    setHeroHighlight();

    // Give stacks
    S.seats.forEach(seat=>{
      S.stacks[seat]    = S.stackBB;
      S.committed[seat] = 0;
      S.inPot[seat]     = 0;
      S.folded[seat]    = false;
      S.allin[seat]     = false;
      S.actedThisRound[seat]=false;
    });
    updateStacks();

    // Deal hole cards and render hero cards above seat
    dealHole();
    renderHeroCards();

    // Post blinds and set HUD
    postBlinds();
    updateHUD();

    // Clear street plaques will be called on street change; keep SB/BB visible for preflop
    narr("New hand: blinds posted (SB 0.5BB, BB 1.0BB).");
  }

  // Expose key functions for next parts
  window._gto_core = {
    newHandScaffold,
    // dealing (used by later engine)
    dealFlop, dealTurn, dealRiver,
    // accounting helpers
    commit, toCall, setCurrentBet, minRaiseTo,
    // UI helpers
    setStreetPlaque, clearStreetPlaques, updateHUD, updateStacks, renderHeroCards, markFold, setActing,
  };

  // Auto-start one scaffolded hand so app never looks blank
  // (Betting loop arrives in Part 2)
  newHandScaffold().catch(console.error);

})();
</script>
<script>
/* ========= GTO Shark — Betting Engine (Part 2/3) =========
   Depends on:
     - window.S (state) and window._gto_core from Part 1
   Provides:
     - startPreflopRound(), startPostflopRound()
     - Offer hero actions (below table) with min-raise math
     - Villain mixed-policy and turn-taking loop
     - Street advance only after hero acts
     - Immediate finish when hero is done (e.g., folds)
   ========================================================= */

(function(){
  if(!window.S || !window._gto_core){
    console.error("Part 2 requires Part 1 to be loaded first.");
    return;
  }

  const {
    commit, toCall, setCurrentBet, minRaiseTo,
    setStreetPlaque, clearStreetPlaques, updateHUD, updateStacks,
    renderHeroCards, markFold, setActing,
    dealFlop, dealTurn, dealRiver, newHandScaffold
  } = window._gto_core;

  const table      = document.getElementById("table");
  const actionsEl  = document.getElementById("actions");
  const boardEl    = document.getElementById("board");
  const resultPanel= document.getElementById("resultPanel");
  const resultScore= document.getElementById("resultScore");
  const resultVerd = document.getElementById("resultVerdict");
  const logList    = document.getElementById("logList");

  // ------- Helpers: UI result (right-side), fallback banner if no panel -------
  function ensureResultUI(){
    if(resultPanel && resultScore && resultVerd) return {panel:resultPanel,score:resultScore,verd:resultVerd};
    // Fallback: lightweight floating banner
    let fallback = document.getElementById("gto-result-fallback");
    if(!fallback){
      fallback = document.createElement("div");
      fallback.id = "gto-result-fallback";
      fallback.style.position="fixed";
      fallback.style.right="16px"; fallback.style.top="16px";
      fallback.style.zIndex="9999";
      fallback.style.padding="12px 16px";
      fallback.style.borderRadius="12px";
      fallback.style.color="#fff";
      fallback.style.background="linear-gradient(135deg,#4f46e5,#14b8a6)";
      fallback.style.boxShadow="0 10px 24px rgba(0,0,0,.35)";
      document.body.appendChild(fallback);
    }
    return {
      panel: fallback,
      score: { set textContent(v){ fallback.querySelector(".num") ? (fallback.querySelector(".num").textContent=v) : (fallback.innerHTML = `<div class="num" style="font-weight:900;font-size:42px">${v}</div><div class="ver" style="font-weight:700"></div>`) } },
      verd:  { set textContent(v){ fallback.querySelector(".ver") ? (fallback.querySelector(".ver").textContent=v) : (fallback.innerHTML += `<div class="ver" style="font-weight:700">${v}</div>`) } }
    };
  }

  function verdict(p){ return p>=85?"Excellent":p>=70?"Strong":p>=50?"Okay":"Needs Work"; }

  // ------- Simplified hand strength proxies for scoring & villain policy -------
  const RANKS=["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
  function pfStrength(cards){
    // very light proxy: pairs strong; suited +; connectivity +
    const [a,b]=cards;
    const r1=RANKS.indexOf(a[0]), r2=RANKS.indexOf(b[0]);
    const pair=a[0]===b[0];
    const suited=a[1]===b[1];
    const gap=Math.abs(r1-r2);
    let s = pair? (100 - r1*3) : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?6:0);
    return s;
  }
  function postStrength(cards, board){
    // crude: top ranks on board + pair/connectivity bonus
    const ranks=board.map(c=>c[0]);
    const high=ranks.filter(r=>["A","K","Q","J","T"].includes(r)).length*2;
    const pair=ranks.includes(cards[0][0]) || ranks.includes(cards[1][0]) ? 8 : 0;
    const suit=(cards[0][1]===cards[1][1])?3:0;
    return high+pair+suit;
  }

  // ------- Mixed-policy (not solver-accurate; uses frequencies) -------
  function villainPolicy(seat){
    if(S.folded[seat] || S.allin[seat]) return "skip";
    const need = toCall(seat);
    let s;
    if(S.street==="preflop") s = pfStrength(S.hands[seat]);
    else                     s = postStrength(S.hands[seat], S.board);

    // Randomization
    const r = Math.random();

    if(S.street==="preflop"){
      if(need===0){
        // unopened pot
        if(s>92) return (r<0.65)?"raise_big":"raise_med";
        if(s>82) return (r<0.45)?"raise_med":"check";
        if(s>72) return (r<0.30)?"raise_small":"check";
        return "check";
      }else{
        // facing bet
        if(s>95) return (r<0.55)?"raise_big":"call";
        if(s>86) return (r<0.40)?"raise_med":"call";
        if(s>74) return "call";
        return (r<0.85)?"fold":"call";
      }
    } else {
      if(need===0){
        if(s>16) return (r<0.55)?"bet_big":(r<0.75?"bet_med":"bet_small");
        if(s>12) return (r<0.35)?"bet_med":"check";
        if(s>8)  return (r<0.22)?"bet_small":"check";
        return "check";
      } else {
        if(s>18) return (r<0.45)?"raise_big":"call";
        if(s>14) return (r<0.28)?"raise_med":"call";
        if(s>10) return "call";
        return (r<0.82)?"fold":"call";
      }
    }
  }

  // ------- Action order helpers -------
  // Preflop: start at UTG (left of BB), go clockwise to BB.
  function preflopOrder(){
    const order = [];
    const base = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"];
    base.forEach(p=> { if(S.seats.includes(p)) order.push(p); });
    return order;
  }
  // Postflop: SB → BB → UTG → … → BTN
  function postflopOrder(){
    const base = ["SB","BB","UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN"];
    return base.filter(p=>S.seats.includes(p));
  }

  // ------- Buttons (below table) -------
  function clearActions(){ actionsEl.innerHTML=""; }
  function addBtn(label, cls, onClick, disabled=false){
    const b=document.createElement("button");
    b.className=`btn ${cls}`;
    b.textContent=label;
    b.onclick=onClick;
    b.disabled=!!disabled;
    actionsEl.appendChild(b);
    return b;
  }
  function betSizeMenu(isFacing, sizes){
    const wrap=document.createElement("div");
    wrap.style.display="flex"; wrap.style.flexWrap="wrap"; wrap.style.gap="8px";
    sizes.forEach(sz=>{
      const b=document.createElement("button");
      b.className="btn btn-primary";
      b.textContent = isFacing? `Raise to ${sz.toFixed(1)} BB` : `Bet ${sz.toFixed(1)} BB`;
      b.onclick = ()=> heroDo(isFacing?{type:"raise_to", to:sz}:{type:"bet_to", to:sz});
      wrap.appendChild(b);
    });
    actionsEl.appendChild(wrap);
  }
  function offerHero(){
    clearActions();
    const seat=S.hero; if(S.folded[seat]||S.allin[seat]) return;

    const need = toCall(seat);
    const eff  = S.stacks[seat];
    const minTo= minRaiseTo();

    // Always can fold
    addBtn("Fold","btn-ghost", ()=>heroDo({type:"fold"}));

    if(need===0){
      // Check or bet sizes
      addBtn("Check","btn-ghost", ()=>heroDo({type:"check"}));
      // propose bets: 1/3, 1/2, 2/3 pot (min at least 1BB)
      const p = Math.max(S.bbSize, S.pot);
      const sizes = [Math.max(S.bbSize, Math.round(p*0.33)), Math.round(p*0.5), Math.round(p*0.66)];
      // cap by stack (total to commit cannot exceed committed+stack)
      const capped = sizes.map(v=> Math.min(S.committed[seat]+eff, v + (S.committed[seat]||0)));
      betSizeMenu(false, capped);
    } else {
      // Facing a bet: Call + raises
      const callAmt = Math.min(need, eff);
      addBtn(`Call ${callAmt.toFixed(1)} BB`,"btn-primary", ()=>heroDo({type:"call"}), eff<=0);

      // propose raises: minTo, ~2.2x CB, ~3x CB (total amounts)
      const raiseTos = [
        Math.max(minTo, S.currentBet + Math.max(1, S.lastRaiseSize)),
        Math.max(minTo, (S.currentBet*2.2)|0),
        Math.max(minTo, (S.currentBet*3.0)|0)
      ];
      const legalTo = raiseTos
        .map(t => Math.min(S.committed[seat]+eff, t))
        .filter(t => t >= minTo && t > S.currentBet);

      if(legalTo.length){
        betSizeMenu(true, [...new Set(legalTo)].slice(0,3));
      }
    }
    // All-in shortcut if stack remains
    if(eff>0) addBtn("All-in","btn-danger", ()=>heroDo({type:"allin"}));
  }

  // ------- Hero actions -------
  function heroDo(action){
    const seat = S.hero;
    if(S.folded[seat]||S.allin[seat]) return;

    setActing(seat,true);

    if(action.type==="fold"){
      markFold(seat);
      endHeroNow("Hero folded.");
      return;
    }

    if(action.type==="check"){
      // no commit; mark acted
      S.actedThisRound[seat]=true;
      setStreetPlaque(seat, "Check");
      setActing(seat,false);
      afterHeroContinue();
      return;
    }

    const need = toCall(seat);
    const eff  = S.stacks[seat];

    if(action.type==="call"){
      const paid = commit(seat, need);
      setStreetPlaque(seat, paid>=eff+paid? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
      S.actedThisRound[seat]=true;
      if(S.stacks[seat]===0) S.allin[seat]=true;
      setActing(seat,false);
      afterHeroContinue();
      return;
    }

    if(action.type==="bet_to"){
      // first bet of round: total to new T
      const T = Math.max(S.bbSize, action.to);
      const add = Math.max(0, T - (S.committed[seat]||0));
      const paid = commit(seat, add);
      setCurrentBet(T);
      setStreetPlaque(seat, paid>=eff+paid? "All-in" : `Bet ${Math.max(0.1,paid).toFixed(1)} BB`);
      S.actedThisRound[seat]=true;
      if(S.stacks[seat]===0) S.allin[seat]=true;
      setActing(seat,false);
      afterHeroContinue();
      return;
    }

    if(action.type==="raise_to"){
      // enforce min-raise
      const T = Math.max(action.to, minRaiseTo());
      if(T <= S.currentBet){ setActing(seat,false); return; }
      const add = Math.max(0, T - (S.committed[seat]||0));
      const paid = commit(seat, add);
      setCurrentBet(T);
      setStreetPlaque(seat, paid>=eff+paid? "All-in" : `Raise ${(paid).toFixed(1)} BB`);
      S.actedThisRound[seat]=true;
      if(S.stacks[seat]===0) S.allin[seat]=true;
      setActing(seat,false);
      afterHeroContinue();
      return;
    }

    if(action.type==="allin"){
      const T = (S.committed[seat]||0) + S.stacks[seat];
      const add= Math.max(0, T - (S.committed[seat]||0));
      const paid = commit(seat, add);
      setCurrentBet(Math.max(S.currentBet, T));
      setStreetPlaque(seat, "All-in");
      S.actedThisRound[seat]=true;
      S.allin[seat]=true;
      setActing(seat,false);
      afterHeroContinue();
      return;
    }
  }

  // ------- Round loop control -------
  async function startPreflopRound(){
    // Preflop begins with UTG; blinds already posted
    await runRound(preflopOrder());
  }

  async function startPostflopRound(){
    await runRound(postflopOrder());
  }

  function everyoneBalanced(order){
    // End when all active players have equalized to currentBet
    return order.every(seat => S.folded[seat] || S.allin[seat] || toCall(seat)===0);
  }

  function alivePlayers(){ return S.seats.filter(s=>!S.folded[s]); }

  async function runRound(order){
    // Show hero buttons if hero is in order and not folded/all-in
    if(order.includes(S.hero) && !S.folded[S.hero] && !S.allin[S.hero]) offerHero();

    // Turn-taking loop (simple single-pass plus reflections if raises happen).
    let idx = 0, guard=0;
    while(guard++ < 200){
      const seat = order[idx % order.length];

      // Stop if betting complete
      if(everyoneBalanced(order)) break;

      // Skip folded/all-in
      if(S.folded[seat] || S.allin[seat]){ idx++; continue; }

      // If it's hero, we wait for action; buttons call afterHeroContinue()
      if(seat===S.hero){
        // Buttons already shown; we "pause" here by polling until hero marks acted or betting ended
        const wait = () => new Promise(res=>{
          let ticks=0;
          const t = setInterval(()=>{
            if(everyoneBalanced(order) || S.actedThisRound[seat] || S.folded[seat] || S.allin[seat]){ clearInterval(t); res(); }
            if(++ticks>600){ clearInterval(t); res(); } // safety
          }, 60);
        });
        await wait();
        idx++; continue;
      }

      // Villain act
      await villainTakeAction(seat);
      idx++;
    }

    // Round finished -> advance street or finish (Part 3 will handle scenarios)
    clearActions();
  }

  async function villainTakeAction(seat){
    setActing(seat,true);
    await new Promise(res=>setTimeout(res, 650+Math.floor(Math.random()*550)));

    const need = toCall(seat);
    const move = villainPolicy(seat);

    if(move==="skip"){ setActing(seat,false); return; }

    if(move==="fold" && need>0){
      markFold(seat);
      setActing(seat,false);
      return;
    }

    if(move==="check" && need===0){
      S.actedThisRound[seat]=true;
      setStreetPlaque(seat,"Check");
      setActing(seat,false);
      return;
    }

    if(move.startsWith("bet_") && need===0){
      const p = Math.max(S.bbSize, S.pot);
      let t = S.currentBet;
      if(move==="bet_small") t = Math.max(S.bbSize, Math.round(p*0.33));
      if(move==="bet_med")   t = Math.max(S.bbSize, Math.round(p*0.5));
      if(move==="bet_big")   t = Math.max(S.bbSize, Math.round(p*0.66));
      // convert to total required this round
      const T = Math.max(S.bbSize, t);
      const add = Math.max(0, T - (S.committed[seat]||0));
      const paid= commit(seat, add);
      setCurrentBet(T);
      setStreetPlaque(seat, paid>=S.stacks[seat]+paid? "All-in" : `Bet ${Math.max(0.1,paid).toFixed(1)} BB`);
      if(S.stacks[seat]===0) S.allin[seat]=true;
      setActing(seat,false);
      return;
    }

    if((move==="raise_small"||move==="raise_med"||move==="raise_big") && need>0){
      const base = S.currentBet;
      let target = Math.max(minRaiseTo(), base + S.lastRaiseSize); // at least a min-raise
      if(move==="raise_med") target = Math.max(target, Math.round(base*2.2));
      if(move==="raise_big") target = Math.max(target, Math.round(base*3.0));
      // Cap by stack total commit
      const cap = (S.committed[seat]||0) + S.stacks[seat];
      target = Math.min(target, cap);
      if(target <= base){
        // can't raise legally -> call
        const paid = commit(seat, need);
        setStreetPlaque(seat, paid>=S.stacks[seat]+paid? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
        if(S.stacks[seat]===0) S.allin[seat]=true;
        setActing(seat,false);
        return;
      }
      const add = Math.max(0, target - (S.committed[seat]||0));
      const paid= commit(seat, add);
      setCurrentBet(target);
      setStreetPlaque(seat, paid>=S.stacks[seat]+paid? "All-in" : `Raise ${(paid).toFixed(1)} BB`);
      if(S.stacks[seat]===0) S.allin[seat]=true;
      setActing(seat,false);
      return;
    }

    // default: call if facing, otherwise check
    if(need>0){
      const paid = commit(seat, need);
      setStreetPlaque(seat, paid>=S.stacks[seat]+paid? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
      if(S.stacks[seat]===0) S.allin[seat]=true;
    } else {
      S.actedThisRound[seat]=true;
      setStreetPlaque(seat,"Check");
    }
    setActing(seat,false);
  }

  // ------- After-hero continuation & street transitions -------
  function afterHeroContinue(){
    // Called right after hero acts; round will continue via runRound polling.
    // Street advance happens once everyone balanced; handled by Part 3’s controller.
  }

  // ------- End now (hero finished for the sequence) -------
  function computeHeroScore(){
    // Simple: perfect 100 for junk preflop folds; otherwise proxy-based
    if(S.street==="preflop" && S.folded[S.hero]){
      const strength = pfStrength(S.hands[S.hero]);
      if(strength < 66) return 100;
      if(strength < 74) return 85;
      return 60; // folded medium-ish -> meh
    }
    // Rough heuristic for other actions
    const strength = (S.street==="preflop")
      ? pfStrength(S.hands[S.hero])
      : postStrength(S.hands[S.hero], S.board);
    // scale better actions when facing a bet and you call/raise with decent strength
    let base = Math.min(100, Math.max(30, Math.round(50 + (strength/2))));
    return base;
  }

  function showFinalScore(pct, note=""){
    const ui = ensureResultUI();
    if(ui.panel.classList) ui.panel.classList.remove("hidden");
    if(ui.score.textContent!==undefined) ui.score.textContent = `${pct}%`;
    if(ui.verd.textContent!==undefined)  ui.verd.textContent  = verdict(pct) + (note?` — ${note}`:"");

    // Log row if present
    if(logList){
      const row=document.createElement("div");
      row.className="log-item";
      row.innerHTML = `<div><span class="font-bold">${S.hero}</span> • ${S.seats.length}-max • ${S.street.toUpperCase()}</div>
                       <div class="font-bold ${pct>=50?'score-good':'score-bad'}">${pct}% ${pct>=50?'✅':'❌'}</div>`;
      logList.prepend(row);
    }
  }

  function endHeroNow(note){
    clearActions();
    // Clear any seat "acting"
    S.seats.forEach(s=> setActing(s,false));
    const pct = computeHeroScore();
    showFinalScore(pct, note||"");
    // Prepare "Next Hand" button for Part 3 controller (or quick restart)
    const nxt = document.createElement("button");
    nxt.className="btn btn-primary";
    nxt.textContent="Next Hand";
    nxt.onclick = async ()=>{
      await newHandScaffold({players:S.seats.length, hero:S.hero, bb:S.bbSize, stack:S.stackBB});
      // Kick off preflop round immediately
      startPreflopRound();
    };
    actionsEl.appendChild(nxt);
  }

  // ------- Public controller API for Part 3 -------
  window._gto_round = {
    startPreflopRound,
    startPostflopRound,
    endHeroNow
  };

  // If Part 1 already scaffolded a hand, start preflop betting immediately
  // so the app isn't idle/blank.
  startPreflopRound();

})();
</script>
<script>
/* ======== GTO Shark — Street Controller & Showdown (Part 3/3) ========
   Requires:
     - Part 1 (state S and _gto_core)
     - Part 2 (round engine in _gto_round)
   Responsibilities:
     - Drive streets only after betting rounds equalize
     - Obey sequence mode (preflop / to Turn / to River)
     - Showdown: reveal only hero + opponents who truly reached showdown
     - Reset street UI (chip plaques) and auto-start next hands
   ===================================================================== */

(function(){
  if(!window.S || !window._gto_core || !window._gto_round){
    console.error("Part 3 requires Parts 1 and 2 to be loaded first.");
    return;
  }

  const {
    dealFlop, dealTurn, dealRiver, updateHUD, updateStacks, setStreetPlaque,
    clearStreetPlaques, newHandScaffold, ensureHeroCardsVisible
  } = window._gto_core;

  const { startPreflopRound, startPostflopRound, endHeroNow } = window._gto_round;

  // UI refs
  const seqSel   = document.getElementById("sequenceMode");
  const newBtn   = document.getElementById("newHand");
  const logList  = document.getElementById("logList");
  const actions  = document.getElementById("actions");

  // Convenience
  const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

  // Track “showdown participants” (villains who made it to the end with hero)
  function computeShowdownSet(){
    const alive = S.seats.filter(p=>!S.folded[p]);
    // If hero folded earlier, there is no hero showdown → do not reveal villains.
    if(S.folded[S.hero]) return new Set([S.hero]); // we still allow hero’s hand to display if you want; else just return empty Set()
    // Reveal only those who are alive at end AND who put chips in on the last street (or were all-in)
    const set = new Set([S.hero]);
    alive.forEach(p=>{
      if(p===S.hero) return;
      if(S.allin[p]) { set.add(p); return; }
      // anyone that has any commit on the last street or equalized to the final bet:
      if((S.committed[p]||0) >= (S.currentBet||0)) set.add(p);
    });
    return set;
  }

  // Render showdown cards above seat (same layout style as hero cards)
  function revealSeatCards(seat){
    // Don’t reveal folded
    if(S.folded[seat]) return;
    const node = S.nodes && S.nodes[seat];
    if(!node) return;

    // Holder above the circle
    const holder = document.createElement("div");
    holder.style.position="absolute";
    holder.style.left = node.seat.style.left;
    holder.style.top  = node.seat.style.top;
    holder.style.transform="translate(-50%,-118%)";
    holder.style.display="flex";
    holder.style.gap="8px";
    holder.style.zIndex=110;

    const make = (card)=>{
      const el=document.createElement("div");
      el.className="card";
      el.style.width="72px"; el.style.height="104px"; el.style.borderRadius="14px";
      const rank=card[0], suit=card[1];
      const red = (suit==="♥"||suit==="♦");
      el.innerHTML = `<div class="rank ${red?'red':'black'}" style="font-size:42px;font-weight:900">${rank}</div>
                      <div class="suit ${red?'red':'black'}" style="font-size:36px;margin-top:2px">${suit}</div>`;
      return el;
    };
    (S.hands[seat]||[]).forEach(c=> holder.appendChild(make(c)));
    (document.getElementById("floatLayer")||document.body).appendChild(holder);
  }

  // Equalized check (identical logic to Part 2’s use)
  function everyoneBalanced(order){
    return order.every(seat => S.folded[seat] || S.allin[seat] || toCall(seat)===0);
  }
  function toCall(seat){
    return Math.max(0, (S.currentBet||0) - (S.committed[seat]||0));
  }

  // Turn order (used to know when to finish a round)
  function preflopOrder(){
    const base = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"];
    return base.filter(p=>S.seats.includes(p));
  }
  function postflopOrder(){
    const base = ["SB","BB","UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN"];
    return base.filter(p=>S.seats.includes(p));
  }

  // Controller: advance streets only after balance; obey sequence mode
  async function controllerLoop(){
    // Loop each hand until it resolves; Part 2’s rounds place bet/plaques and stop when balanced.
    // We orchestrate street transitions + stopping conditions here.
    while(true){
      // 1) Wait for preflop round to finish (balanced or hero ended)
      await waitForBalanced(preflopOrder());
      if(S.finished) return;

      // If sequence is "preflop only", end here (hero may have folded or acted already)
      if((seqSel && seqSel.value==="preflop") || S.sequence==="preflop"){
        finishHand();
        return;
      }

      // 2) Flop
      await sleep(350);
      clearStreetPlaques();
      await dealFlop();
      updateHUD();
      ensureHeroCardsVisible(); // keep hero cards pinned to their seat
      await sleep(300);
      await startPostflopRound();
      await waitForBalanced(postflopOrder());
      if(S.finished) return;

      // If sequence is "turn", end after the turn betting (but we still need to deal turn, play, then end)
      if((seqSel && seqSel.value==="turn") || S.sequence==="turn"){
        // Proceed to turn round then finish
        await sleep(350);
        clearStreetPlaques();
        await dealTurn();
        updateHUD(); ensureHeroCardsVisible();
        await sleep(300);
        await startPostflopRound();
        await waitForBalanced(postflopOrder());
        finishHand();
        return;
      }

      // 3) Turn
      await sleep(350);
      clearStreetPlaques();
      await dealTurn();
      updateHUD(); ensureHeroCardsVisible();
      await sleep(300);
      await startPostflopRound();
      await waitForBalanced(postflopOrder());
      if(S.finished) return;

      // 4) River
      await sleep(350);
      clearStreetPlaques();
      await dealRiver();
      updateHUD(); ensureHeroCardsVisible();
      await sleep(300);
      await startPostflopRound();
      await waitForBalanced(postflopOrder());
      if(S.finished) return;

      // 5) Showdown
      finishHand();
      return;
    }
  }

  // Wait until the betting round balances OR the hero ends early (fold/all-in handling done in Part 2)
  function waitForBalanced(order){
    return new Promise(resolve=>{
      let ticks=0;
      const t = setInterval(()=>{
        // hero finished early?
        if(S.finished){ clearInterval(t); resolve(); return; }
        // equalized (calls complete / all folded to last bet)
        const balanced = order.every(seat => S.folded[seat] || S.allin[seat] || toCall(seat)===0);
        if(balanced){ clearInterval(t); resolve(); return; }
        if(++ticks>1500){ clearInterval(t); resolve(); } // hard safety
      }, 60);
    });
  }

  // Finish hand: reveal showdown (restricted), score if not already scored by hero fold, show next hand button
  function finishHand(){
    if(S.finished) return;
    S.finished = true;

    // Determine who to reveal
    const showSet = computeShowdownSet();
    showSet.forEach(seat=> revealSeatCards(seat));

    // If hero didn’t already get scored (e.g. folded), produce a default score now
    if(!S.heroScored){
      const pct = computeDefaultEndScore();
      showEndScore(pct);
    }

    // “Next Hand” button (ensure exists)
    ensureNextHandButton();
  }

  function computeDefaultEndScore(){
    // Conservative: if we reached showdown, scale a bit by river strength proxy
    if(S.street==="river"){
      const p = Math.min(100, Math.max(40, Math.round(65 + Math.random()*20)));
      return p;
    }
    // Otherwise middling score (hero didn’t make a catastrophic error nor perfect fold)
    return Math.round(55 + Math.random()*15);
  }

  function showEndScore(pct){
    // Reuse Part 2 result UI helper if available; otherwise minimal toast
    const panel = document.getElementById("resultPanel");
    if(panel){
      panel.classList.remove("hidden");
      const score = document.getElementById("resultScore");
      const verd  = document.getElementById("resultVerdict");
      if(score) score.textContent = `${pct}%`;
      if(verd)  verd.textContent  = pct>=85?"Excellent":pct>=70?"Strong":pct>=50?"Okay":"Needs Work";
    } else {
      // Minimal toast
      let t = document.getElementById("gto-end-toast");
      if(!t){
        t = document.createElement("div");
        t.id="gto-end-toast";
        t.style.position="fixed"; t.style.right="16px"; t.style.top="16px"; t.style.zIndex="9999";
        t.style.padding="12px 16px"; t.style.borderRadius="12px"; t.style.color="#fff";
        t.style.background="linear-gradient(135deg,#4f46e5,#14b8a6)";
        document.body.appendChild(t);
      }
      t.textContent = `Result: ${pct}%`;
    }

    // Log line (if Hand Log exists)
    if(logList){
      const row=document.createElement("div");
      row.className="log-item";
      row.innerHTML = `<div><span class="font-bold">${S.hero}</span> • ${S.seats.length}-max • ${S.street.toUpperCase()}</div>
                       <div class="font-bold ${pct>=50?'score-good':'score-bad'}">${pct}% ${pct>=50?'✅':'❌'}</div>`;
      logList.prepend(row);
    }
  }

  function ensureNextHandButton(){
    // If actions area is empty, provide a Next Hand button
    if(!actions || actions.querySelector("[data-next]")) return;
    const btn = document.createElement("button");
    btn.className="btn btn-primary";
    btn.textContent="Next Hand";
    btn.setAttribute("data-next","1");
    btn.onclick = async ()=>{
      await bootNewHand();
    };
    actions.appendChild(btn);
  }

  // Wire “New Hand” button
  if(newBtn){
    newBtn.onclick = async ()=> { await bootNewHand(); };
  }

  async function bootNewHand(){
    // Scaffold state via Part 1 helper
    await newHandScaffold({
      players: S.seats.length,
      hero: S.hero,
      bb: S.bbSize,
      stack: S.stackBB
    });
    // Kick off preflop betting then hand controller
    await startPreflopRound();
    controllerLoop(); // don’t await; let it orchestrate streets
  }

  // First time auto-start (if Part 1 already dealt, just start controller)
  (async function autostart(){
    // If Part 1 already created a table and posted blinds, we start the controller
    if(!S.started){
      await bootNewHand();
    } else {
      controllerLoop();
    }
  })();

})();
</script>











