<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GTO Shark • Live Practice (Deck + Legal Min-Raise)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b1220;            /* deep slate */
    --felt:#0f3d2e;          /* realistic poker felt base */
    --felt-hi:#155e47;       /* felt highlight */
    --ink:#e2e8f0;
    --mut:#9fb2cc;
    --indigo:#4f46e5;
    --teal:#14b8a6;
    --hero:#22c55e;
    --acting:#f59e0b;
    --ring:#2b3a58;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; padding:16px; font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--ink); background: radial-gradient(1200px 900px at 30% 10%, #0d1b2a 0%, #0b1220 50%, #08101c 100%);
  }

  /* App layout */
  .app{display:grid; grid-template-columns:minmax(820px,1fr) 360px; gap:16px; align-items:start}
  @media (max-width:1200px){ .app{grid-template-columns:1fr} .sidebar{order:3} }

  header{display:flex; gap:12px; align-items:flex-end; justify-content:space-between; margin-bottom:14px}
  .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
  .sel,.btn{appearance:none; border:1px solid #2e3b54; background:#0d1626; color:var(--ink); padding:.55rem .75rem; border-radius:.6rem; font-weight:700}
  .btn-primary{background:var(--indigo); border-color:transparent}
  .btn-ghost{background:rgba(20,184,166,.1); border-color:rgba(45,212,191,.35); color:#5eead4}
  .btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626); border:0; color:#fff}

  /* Table */
  .table-wrap{display:flex; justify-content:center}
  .table{
    --S:720px;
    width:var(--S); height:var(--S); position:relative; border-radius:9999px;
    background:
      radial-gradient(300px 140px at 50% 35%, rgba(255,255,255,.06) 0%, rgba(255,255,255,0) 60%),
      radial-gradient(100% 100% at 50% 30%, var(--felt-hi) 0%, var(--felt) 45%, #0a3024 70%, #071e17 100%);
    border:10px solid rgba(79,70,229,.35);
    box-shadow:
      inset 0 0 60px rgba(20,184,166,.25),
      inset 0 0 120px rgba(79,70,229,.2),
      0 18px 50px rgba(0,0,0,.45);
  }
  .hud{
    position:absolute; left:50%; top:12%; transform:translateX(-50%);
    display:flex; gap:10px; padding:6px 10px; border-radius:.6rem;
    background:#08121eCC; border:1px solid #26324a; font-weight:900; color:#c7d2fe; z-index:30;
  }
  .hud span.muted{color:#94a3b8; font-weight:700}

  /* Seats */
  .seat{
    position:absolute; transform:translate(-50%,-50%);
    width:90px; height:90px; border-radius:9999px;
    display:flex; align-items:center; justify-content:center; font-weight:900; letter-spacing:.2px;
    background:#0c1930; color:#b7c6de; border:2px solid var(--ring); text-transform:uppercase;
    box-shadow:0 10px 24px rgba(0,0,0,.45); transition:.15s;
  }
  .seat.hero{border-color:rgba(34,197,94,.8); color:#d1fae5; box-shadow:0 0 28px rgba(34,197,94,.55)}
  .seat.acting{border-color:rgba(245,158,11,.9); color:#fde68a; box-shadow:0 0 28px rgba(245,158,11,.55)}
  .seat.folded{border-color:#3a485f; color:#6b778d; filter:grayscale(.4)}
  .stack{
    position:absolute; left:50%; top:calc(100% + 14px); transform:translateX(-50%);
    background:#0b1220; color:#c7d2fe; border:1px solid rgba(99,102,241,.5); padding:2px 10px; border-radius:9999px; font-size:12px;
  }

  /* Cards */
  .card{
    width:86px; height:122px; border-radius:14px; background:linear-gradient(160deg,#fff 0%,#f3f5ff 55%,#e9ecff 100%);
    border:2px solid rgba(79,70,229,.9); box-shadow:0 10px 24px rgba(0,0,0,.35);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
  }
  .rank{font-size:42px; font-weight:900}
  .suit{font-size:36px; margin-top:0}
  .red{color:#ef4444}.black{color:#0f172a}

  .board{position:absolute; left:50%; top:38%; transform:translateX(-50%); display:flex; gap:8px; z-index:25}
  .board .card{width:78px; height:112px; border-radius:12px}
  .hero-cards{position:absolute; display:flex; gap:8px; z-index:26; transform:translate(-50%,-50%)}
  .hero-cards .card{box-shadow:0 12px 28px rgba(79,70,229,.35)}

  /* Bet plates (persist until street advances) */
  .plates{position:absolute; inset:0; z-index:24; pointer-events:none}
  .plate{
    position:absolute; transform:translate(-50%,-40px);
    background:linear-gradient(135deg,#18253b,#0d1629);
    border:1px solid rgba(99,102,241,.6); color:#c7d2fe; font-weight:900; font-size:12px;
    padding:.35rem .55rem; border-radius:.65rem; display:flex; gap:.35rem; align-items:center;
    box-shadow:0 10px 22px rgba(0,0,0,.35);
  }
  .chip{width:14px; height:14px; border-radius:9999px; background:
    radial-gradient(circle at 50% 50%, #f59e0b 0 26%, #7c3aed 28% 32%, #f59e0b 35% 60%, #7c3aed 63% 67%, #f59e0b 70%);
    border:1px solid rgba(245,158,11,.85); box-shadow:0 0 0 1px rgba(124,58,237,.75) inset;
  }

  /* Action bar (under table) */
  .action-wrap{margin-top:14px; background:#0b1220; border:1px solid #2b3a4b; border-radius:1rem; padding:12px}
  .action-title{font-weight:900; margin-bottom:6px}
  .action-row{display:flex; flex-wrap:wrap; gap:8px}
  .btn{cursor:pointer}

  /* Side bar */
  .panel{background:#0b1220; border:1px solid #2b3a4b; border-radius:1rem; padding:12px}
  .result{background:linear-gradient(135deg,var(--indigo),var(--teal)); color:#fff; border-radius:1rem; padding:12px; box-shadow:0 0 26px rgba(20,184,166,.25)}
  .big{font-size:44px; font-weight:900}
  .good{color:#22c55e}.bad{color:#ef4444}

  /* Log */
  .log{max-height:520px; overflow:auto}
  .log-item{display:flex; justify-content:space-between; align-items:center; padding:.5rem .6rem; border-radius:.6rem; border:1px solid #2b3a4b; background:#0b1220; margin-bottom:6px}

  /* Helper badges */
  .badge{font-size:12px; background:#0d1a2a; border:1px solid #2b3a4b; padding:3px 8px; border-radius:999px; color:#c7d2fe}

  /* Hide utility */
  .hidden{display:none!important}
</style>
</head>
<body>
  <header>
    <div>
      <div style="font-size:26px; font-weight:900; color:#c7d2fe">GTO Shark • Live Practice</div>
      <div style="color:#94a3b8; font-size:13px">Cinematic felt • legal min-raise • sequential action • showdown-only reveals</div>
    </div>
    <div class="controls">
      <label class="badge">Mode</label>
      <select id="mode" class="sel">
        <option value="cash" selected>Cash (EV)</option>
        <option value="mtt">MTT (ICM tilt)</option>
      </select>

      <label class="badge">Players</label>
      <select id="numPlayers" class="sel">
        <option>9</option><option selected>6</option><option>5</option><option>7</option><option>8</option>
      </select>

      <label class="badge">Hero</label>
      <select id="heroPos" class="sel"></select>

      <label class="badge">Sequence</label>
      <select id="sequence" class="sel">
        <option value="preflop">Preflop only</option>
        <option value="turn">Play to Turn</option>
        <option value="river" selected>Play to River</option>
      </select>

      <label class="badge">Scenario</label>
      <select id="scenario" class="sel">
        <option value="none" selected>None (Standard)</option>
        <option value="bvb">Blind vs Blind (SB opens)</option>
        <option value="btn_bb">BTN vs BB</option>
        <option value="co_bb">CO vs BB</option>
        <option value="utg_bb">UTG vs BB</option>
      </select>

      <button id="newHand" class="btn btn-primary">♻ New Hand</button>
    </div>
  </header>

  <div class="app">
    <main>
      <section class="table-wrap">
        <div id="table" class="table">
          <div id="hud" class="hud">
            <span id="hudStreet">—</span>
            <span class="muted">•</span>
            <span id="hudPot">Pot: —</span>
            <span class="muted">•</span>
            <span id="hudSPR">SPR: —</span>
          </div>

          <div id="board" class="board"></div>
          <div id="seatsLayer"></div>
          <div id="plates" class="plates"></div>
        </div>
      </section>

      <section class="action-wrap">
        <div class="action-title">Your move</div>
        <div id="prompt" style="color:#9fb2cc; font-size:13px">Preparing…</div>
        <div id="actions" class="action-row"></div>
      </section>
    </main>

    <aside class="sidebar">
      <div id="result" class="result hidden">
        <div id="resultScore" class="big"></div>
        <div id="resultVerd"></div>
      </div>

      <div class="panel" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
          <div style="font-weight:900; color:#c7d2fe">Hand Log</div>
          <button id="clearLog" class="btn btn-ghost" style="padding:.3rem .6rem">Clear</button>
        </div>
        <div class="log" id="log"></div>
      </div>
    </aside>
  </div>
  <script>
  /***********************
   * CONSTANTS
   ***********************/
  const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
  const SUITS = ["♠","♥","♦","♣"];
  const SUITCLASS = s => (s==="♥"||s==="♦") ? "red" : "black";

  const POS_9  = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"];
  const POS_8  = ["UTG","UTG+1","UTG+2","HJ","CO","BTN","SB","BB"];
  const POS_7  = ["UTG","UTG+1","HJ","CO","BTN","SB","BB"];
  const POS_6  = ["UTG","HJ","CO","BTN","SB","BB"];
  const POS_5  = ["UTG","CO","BTN","SB","BB"];
  const POSMAP = {5:POS_5,6:POS_6,7:POS_7,8:POS_8,9:POS_9};

  /***********************
   * STATE
   ***********************/
  const S = {
    mode:"cash",            // cash | mtt (affects villain frequencies)
    players:6,
    seats:[],               // seat names in table order
    hero:"BTN",             // seat name for hero
    sequence:"river",       // preflop | turn | river
    scenario:"none",

    /* Hand state */
    street:"preflop",       // preflop/flop/turn/river
    hands:{},               // {seat: [c1,c2]}
    board:[],               // 0/3/4/5 cards
    stacks:{},              // {seat: bb}
    folded:{},              // {seat: bool}
    allin:{},               // {seat: bool}
    committed:{},           // this-street committed totals
    pot:0,                  // total pot
    lastAggressor:null,     // seat who last bet/raised (null if none)
    currentBetTotal:0,      // CB (to match)
    lastRaiseSize:0,        // LRS (size of last raise)
    toActIndex:0,           // index in S.order for next actor
    order:[],               // action order array for current street

    /* Deck */
    deck:[],

    /* UI nodes */
    nodes:{},               // seat -> {el, stackEl, xy}
    heroCardsEl:null,

    /* Score */
    evLoss:0,
    resultShown:false
  };

  /***********************
   * DOM REFS
   ***********************/
  const $mode   = document.getElementById("mode");
  const $num    = document.getElementById("numPlayers");
  const $hero   = document.getElementById("heroPos");
  const $seq    = document.getElementById("sequence");
  const $scn    = document.getElementById("scenario");
  const $new    = document.getElementById("newHand");
  const $clear  = document.getElementById("clearLog");

  const $table  = document.getElementById("table");
  const $seats  = document.getElementById("seatsLayer");
  const $plates = document.getElementById("plates");
  const $board  = document.getElementById("board");
  const $hudStreet = document.getElementById("hudStreet");
  const $hudPot    = document.getElementById("hudPot");
  const $hudSPR    = document.getElementById("hudSPR");

  const $prompt = document.getElementById("prompt");
  const $actions= document.getElementById("actions");
  const $log    = document.getElementById("log");
  const $result = document.getElementById("result");
  const $resultScore = document.getElementById("resultScore");
  const $resultVerd  = document.getElementById("resultVerd");

  /***********************
   * RNG & DECK
   ***********************/
  let _seed = (Date.now() ^ 0x9e3779b9) >>> 0;
  function xr(){ _seed ^= _seed<<13; _seed ^= _seed>>>17; _seed ^= _seed<<5; return (_seed>>>0)%1e5/1e5; }

  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(xr()*(i+1)); const t=a[i]; a[i]=a[j]; a[j]=t;
    }
  }
  function createDeck(){
    const d=[];
    for(const r of RANKS) for(const s of SUITS) d.push(r+s);
    shuffle(d); S.deck=d;
  }
  function deal(n){
    if(S.deck.length<n) return [];
    return S.deck.splice(0,n);
  }

  /***********************
   * LAYOUT
   ***********************/
  function layoutSeats(){
    $seats.innerHTML=""; S.nodes={};
    const N=S.players;
    const R = ($table.clientWidth/2) - 100;
    const off = -90;
    for(let i=0;i<N;i++){
      const name = S.seats[i];
      const a=(off+(360/N)*i)*Math.PI/180;
      const x=50+(R*Math.cos(a))/($table.clientWidth/100);
      const y=50+(R*Math.sin(a))/($table.clientHeight/100);

      const el = document.createElement("div");
      el.className="seat"+(name===S.hero?" hero":"");
      el.style.left=x+"%"; el.style.top=y+"%";
      el.textContent=name;

      const sk = document.createElement("div");
      sk.className="stack"; sk.id=`stack-${name}`; sk.textContent="—";
      el.appendChild(sk);

      $seats.appendChild(el);
      S.nodes[name]={el, stackEl:sk, xy:{x,y}, label:name};
    }
  }
  function setHeroHighlight(){
    S.seats.forEach(p=>{
      const n=S.nodes[p]; if(!n) return;
      n.el.classList.toggle("hero", p===S.hero);
    });
  }
  function setActing(seat,on=true){
    const n=S.nodes[seat]; if(!n) return;
    n.el.classList.toggle("acting",on);
    if(on){ setTimeout(()=>n.el.classList.remove("acting"), 1100); }
  }
  function markFold(seat){
    const n=S.nodes[seat]; if(!n) return;
    n.el.classList.add("folded");
    n.el.textContent="FOLD";
    n.el.appendChild(n.stackEl);
  }

  /***********************
   * RENDER
   ***********************/
  function cardEl(c,small=false){
    const r=c[0], s=c[1];
    const el=document.createElement("div");
    el.className="card";
    if(small){ el.style.width="72px"; el.style.height="104px"; }
    el.innerHTML = `<div class="rank ${SUITCLASS(s)}">${r}</div><div class="suit ${SUITCLASS(s)}">${s}</div>`;
    return el;
  }
  function renderBoard(){
    $board.innerHTML="";
    S.board.forEach(c=>$board.appendChild(cardEl(c,true)));
  }
  function clearHeroCards(){
    if(S.heroCardsEl){ S.heroCardsEl.remove(); S.heroCardsEl=null; }
  }
  function renderHeroCards(){
    clearHeroCards();
    const n=S.nodes[S.hero]; if(!n) return;
    const hc=document.createElement("div");
    hc.className="hero-cards";
    hc.style.left=n.xy.x+"%"; hc.style.top=`calc(${n.xy.y}% - 4%)`;
    const H=S.hands[S.hero]||[];
    H.forEach(c=>hc.appendChild(cardEl(c,false)));
    S.heroCardsEl=hc;
    $table.appendChild(hc);
  }
  function updateStacksUI(){ S.seats.forEach(p=> S.nodes[p].stackEl.textContent = `${S.stacks[p].toFixed(1)} BB` ); }
  function hud(){
    const streetLabel = S.street==="preflop"?"PREFLOP":(S.street[0].toUpperCase()+S.street.slice(1));
    $hudStreet.textContent = streetLabel;
    $hudPot.textContent = `Pot: ${S.pot.toFixed(1)} BB`;
    const live = S.seats.filter(p=>!S.folded[p]);
    const eff = live.length? Math.min(...live.map(p=> Math.max(0.1, S.stacks[p]))): 0;
    const spr = (eff / Math.max(1,S.pot)).toFixed(1);
    $hudSPR.textContent = `SPR: ${spr}`;
  }

  /***********************
   * PLATES & LOG
   ***********************/
  function plate(seat, text){
    const n=S.nodes[seat]; if(!n) return;
    const el=document.createElement("div");
    el.className="plate";
    el.style.left = n.el.style.left;
    const ty = parseFloat(n.el.style.top);
    el.style.top = `calc(${ty}% - 48px)`;
    el.innerHTML = `<span class="chip"></span><span>${text}</span>`;
    $plates.appendChild(el);
    return el;
  }
  function clearPlates(){ $plates.innerHTML=""; }

  function logLine(tailHTML){
    const r=document.createElement("div"); r.className="log-item";
    r.innerHTML = `<div>${tailHTML}</div><div style="color:#c7d2fe;font-weight:900">${S.street.toUpperCase()}</div>`;
    $log.prepend(r);
  }
  function logAction(seat, verb, amount=null){
    const amt = amount!=null ? ` <span style="color:#22c55e;font-weight:900">${amount.toFixed ? amount.toFixed(1):amount} BB</span>` : "";
    const who = `<span style="color:#c7d2fe;font-weight:900">${seat}</span>`;
    logLine(`${who}: ${verb}${amt}`);
  }

  /***********************
   * HELPERS (Pot/Commit/Order)
   ***********************/
  function resetCommitted(){ S.committed={}; S.seats.forEach(p=> S.committed[p]=0); }
  function payTo(seat, targetTotal){
    const need = Math.max(0, targetTotal - S.committed[seat]);
    if(need<=0) return 0;
    const can  = S.stacks[seat];
    const put  = Math.min(need, can);
    S.stacks[seat]    = +(S.stacks[seat]-put).toFixed(1);
    S.committed[seat] = +(S.committed[seat]+put).toFixed(1);
    S.pot             = +(S.pot+put).toFixed(1);
    updateStacksUI(); hud();
    return put;
  }
  function toCall(seat){ return Math.max(0, S.currentBetTotal - S.committed[seat]); }

  function streetOrderPreflop(){
    // UTG → ... → BTN → SB → BB
    const idxUTG = S.seats.indexOf("UTG");
    // If table isn’t 9-max, UTG is still first seat in S.seats (we ensured templates)
    const order = [];
    // start at first non-blind seat
    const nonBlinds = S.seats.filter(n=> n!=="SB" && n!=="BB");
    order.push(...nonBlinds);
    order.push("SB","BB");
    return order.filter(n=> S.seats.includes(n));
  }
  function streetOrderPostflop(){
    // SB → BB → UTG → ... → BTN  (clockwise from SB)
    const sbIndex = S.seats.indexOf("SB");
    const order=[];
    for(let k=0;k<S.seats.length;k++){
      const i=(sbIndex+k)%S.seats.length;
      order.push(S.seats[i]);
    }
    return order;
  }
  function firstActorForStreet(){
    return (S.street==="preflop") ? streetOrderPreflop()[0] : streetOrderPostflop()[0];
  }

  function allActiveEqualized(){
    const act = S.seats.filter(p=> !S.folded[p] && !S.allin[p]);
    if(act.length===0) return true;
    return act.every(p=> S.committed[p]===S.currentBetTotal );
  }

  function minRaiseTotal(){
    // If no bet yet postflop => min "bet" is 1BB total
    if(S.currentBetTotal===0){
      if(S.street==="preflop"){
        // opening raise over BB (implicitly 1BB) must be at least to 2BB total
        return 2.0;
      }
      return 1.0;
    }
    // Otherwise min-raise total = CB + LRS (LRS default 1.0 over BB pre)
    const base = (S.street==="preflop" && S.lastRaiseSize===0) ? 1.0 : (S.lastRaiseSize||1.0);
    return +(S.currentBetTotal + base).toFixed(1);
  }
  /***********************
   * INIT STREET / DEAL
   ***********************/
  function initStreet(kind){
    S.street = kind;
    resetCommitted();

    // Blinds only preflop
    if(kind === "preflop"){
      S.currentBetTotal = 1.0;    // BB to match
      S.lastRaiseSize   = 1.0;
      if(S.seats.includes("SB")) payTo("SB", 0.5);
      if(S.seats.includes("BB")) payTo("BB", 1.0);
      S.lastAggressor = null;
    } else {
      S.currentBetTotal = 0.0;
      S.lastRaiseSize   = 0.0;
      S.lastAggressor   = null;
      clearPlates();
    }

    // Set action order
    S.order = (kind==="preflop") ? streetOrderPreflop() : streetOrderPostflop();
    S.toActIndex = 0;
    while(S.toActIndex < S.order.length &&
          (S.folded[S.order[S.toActIndex]] || S.allin[S.order[S.toActIndex]])) {
      S.toActIndex++;
    }

    // Immediate end if only one active player
    const activeSeats = S.seats.filter(p => !S.folded[p] && !S.allin[p]);
    if(activeSeats.length <= 1) return finishHand();

    hud();
  }

  /* --- Proper burn/deal sequence --- */
  function dealFlop(){
    // No burn before flop (deck was fresh)
    S.board.push(...deal(3));
    renderBoard(); hud();
  }
  function dealTurn(){
    deal(1);                   // burn one
    S.board.push(...deal(1));  // deal one
    renderBoard(); hud();
  }
  function dealRiver(){
    deal(1);                   // burn one
    S.board.push(...deal(1));  // deal one
    renderBoard(); hud();
  }

  /***********************
   * ROUND ADVANCEMENT
   ***********************/
  function advanceToNextActor(startFrom=S.toActIndex){
    let i = startFrom;
    for(let k=0; k<S.order.length; k++){
      i = (i + 1) % S.order.length;
      const seat = S.order[i];
      if(!S.folded[seat] && !S.allin[seat]){ S.toActIndex = i; return seat; }
    }
    return null;
  }

  function actionReturnedToAggressor(current){
    if(S.lastAggressor == null){
      // If no one raised:
      if(S.street === "preflop") return current === "BB"; // BB closes preflop
      return true; // postflop check-around
    }
    return current === S.lastAggressor;
  }

  function shouldCloseRound(current){
    return allActiveEqualized() && actionReturnedToAggressor(current);
  }

  function endRoundOrAdvance(nextSeatFromCurrent){
    // --- Immediate fold end check (exclude folded/all-in) ---
    const active = S.seats.filter(p => !S.folded[p] && !S.allin[p]);
    if(active.length <= 1) return finishHand();

    // Determine next actor
    const closingSeat = advanceToNextActor(S.toActIndex);
    const currentSeat = closingSeat ?? nextSeatFromCurrent;

    // If round not closed, continue
    if(!shouldCloseRound(currentSeat)){
      if(!closingSeat) return;
      if(closingSeat === S.hero) heroOffer(); else villainTurn(closingSeat);
      return;
    }

    // --- Round closed → advance or finish ---
    switch(S.street){
      case "preflop":
        if(S.sequence === "preflop") return finishHand();
        dealFlop(); initStreet("flop"); break;
      case "flop":
        if(S.sequence === "turn") return finishHand();
        dealTurn(); initStreet("turn"); break;
      case "turn":
        if(S.sequence === "river") {
          dealRiver(); initStreet("river");
        } else return finishHand();
        break;
      case "river":
        return finishHand();
    }

    // Continue with next actor already set by initStreet
    const nextActor = S.order[S.toActIndex];
    if(nextActor === S.hero) heroOffer(); else villainTurn(nextActor);
  }

  /***********************
   * MIN RAISE LOGIC (fixed)
   ***********************/
  function minRaiseTotal(){
    let baseRaiseSize;
    if(S.street === "preflop" && S.lastRaiseSize === 0){
      baseRaiseSize = 1.0; // first raise is +1BB
    } else if(S.lastRaiseSize === 0){
      // postflop no bet yet → min bet = 1BB
      return 1.0;
    } else {
      baseRaiseSize = S.lastRaiseSize;
    }
    const minTotal = S.currentBetTotal + baseRaiseSize;
    return +(minTotal).toFixed(1);
  }

  /***********************
   * HERO ACTIONS (fixed fold logic)
   ***********************/
  function heroAct(action){
    const me = S.hero;
    if(S.folded[me] || S.allin[me]) return;

    if(action.type === "fold"){
      S.folded[me] = true;
      markFold(me);
      plate(me,"Fold"); logAction(me,"fold");
      // Continue loop normally
      return endRoundOrAdvance(me);
    }

    if(action.type === "check"){
      plate(me,"Check"); logAction(me,"check");
      return endRoundOrAdvance(me);
    }

    if(action.type === "call"){
      const need = toCall(me);
      const put = payTo(me, S.currentBetTotal);
      plate(me, `Call ${Math.min(need, put).toFixed(1)} BB`);
      logAction(me,"call", Math.min(need,put));
      if(S.stacks[me] <= 0) S.allin[me] = true;
      return endRoundOrAdvance(me);
    }

    if(action.type === "bet_to" || action.type === "raise_to"){
      const to = +(action.to || 0).toFixed(1);
      if(applyUnderRaiseRules(me, to)) return endRoundOrAdvance(me);

      const prev = S.currentBetTotal;
      S.currentBetTotal = to;
      const put = payTo(me, to);
      const delta = +(to - prev).toFixed(1);
      S.lastRaiseSize = (prev === 0 && S.street !== "preflop")
                        ? Math.max(1.0, delta)
                        : delta;
      S.lastAggressor = me;
      plate(me, prev===0 ? `Bet ${put.toFixed(1)} BB` : `Raise ${delta.toFixed(1)} BB`);
      logAction(me, prev===0 ? "bet" : "raise", put);
      if(S.stacks[me] <= 0) S.allin[me] = true;
      return endRoundOrAdvance(me);
    }

    if(action.type === "allin"){
      const cap = S.committed[me] + S.stacks[me];
      const prev = S.currentBetTotal;
      const newTo = Math.max(prev, cap);

      if(applyUnderRaiseRules(me, newTo)) return endRoundOrAdvance(me);

      S.currentBetTotal = newTo;
      const delta = +(newTo - prev).toFixed(1);
      S.lastRaiseSize = (prev === 0 && S.street !== "preflop")
                        ? Math.max(1.0, delta)
                        : delta;
      payTo(me, newTo);
      plate(me, "All-in");
      logAction(me,"all-in", newTo);
      S.lastAggressor = me;
      S.allin[me] = true;
      return endRoundOrAdvance(me);
    }
  }

  /***********************
   * FINISH / SCORING (unchanged)
   ***********************/
  function computeScore(){
    const H=S.hands[S.hero];
    const pre=pfStrength(H);
    let score = 100 - Math.max(0,S.evLoss*22);
    if(S.street==="preflop" && S.folded[S.hero] && pre<66) score=100;
    return Math.max(0,Math.min(100,Math.round(score)));
  }

  function verdict(p){ return p>=85?"Excellent": p>=70?"Strong": p>=50?"OK":"Needs Work"; }

  function revealShowdown(){
    const surv = S.seats.filter(p => !S.folded[p]);
    surv.forEach(p=>{
      if(p !== S.hero){
        const n=S.nodes[p];
        const holder=document.createElement("div");
        holder.style.position="absolute";
        holder.style.left=n.el.style.left;
        holder.style.top=n.el.style.top;
        holder.style.transform="translate(-50%,-120%)";
        holder.style.display="flex";
        holder.style.gap="6px";
        holder.style.zIndex=40;
        S.hands[p].forEach(c => holder.appendChild(cardEl(c,true)));
        $table.appendChild(holder);
      }
    });
  }

  function finishHand(){
    if(S.resultShown) return;
    S.resultShown = true;

    if(S.street === "river" && S.seats.filter(p => !S.folded[p]).length >= 2){
      revealShowdown();
    }

    const pct = computeScore();
    $result.classList.remove("hidden");
    $resultScore.textContent = pct+"%";
    $resultScore.classList.toggle("good", pct>=50);
    $resultScore.classList.toggle("bad", pct<50);
    $resultVerd.textContent = verdict(pct);

    logLine(`<span style="color:#c7d2fe;font-weight:900">Result</span>: <span style="font-weight:900;color:${pct>=50?'#22c55e':'#ef4444'}">${pct}%</span>`);

    clearActions();
    const b=document.createElement("button");
    b.className="btn btn-primary";
    b.textContent="Next Hand";
    b.onclick=startNewHand;
    $actions.appendChild(b);
  }
