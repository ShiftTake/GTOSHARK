<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>GTO Shark • Live Practice</title>
<style>
  :root{
    --bg:#0b1220;
    --felt1:#062027;
    --felt2:#0d2b33;
    --felt3:#0a1a22;
    --ring:#4f46e5;
    --teal:#14b8a6;
    --ink:#e2e8f0;
    --muted:#94a3b8;
    --orange:#f59e0b;
    --green:#22c55e;
    --red:#ef4444;
    --panel:#0c1523;
    --border:#223047;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  *{box-sizing:border-box}

  /* Top bar */
  .topbar{
    position:sticky;top:0;z-index:40;
    display:flex;gap:.6rem;align-items:center;justify-content:flex-end;
    padding:.7rem .9rem;border-bottom:1px solid rgba(148,163,184,.15);
    background:linear-gradient(180deg,#0b1220 0%, #0b1220e6 70%, #0b1220cc 100%);
  }
  .brand{margin-right:auto;font-weight:900;color:#c7d2fe;letter-spacing:.2px}
  .select{
    display:flex;gap:.45rem;align-items:center;background:#0f1827;border:1px solid var(--border);
    padding:.45rem .6rem;border-radius:.6rem;color:#d1d5db;font-size:.86rem;min-width:148px
  }
  .select select{background:transparent;color:inherit;border:0;outline:0;width:100%}
  .btn{
    background:linear-gradient(135deg,var(--ring),var(--teal));
    color:#fff;border:0;border-radius:.75rem;padding:.6rem 1rem;font-weight:900;cursor:pointer
  }

  /* Layout */
  .app{
    max-width:1200px;margin:0 auto;padding:1rem;
    display:grid;grid-template-columns:minmax(700px,1fr) 320px;gap:1rem;align-items:start;
  }
  @media (max-width:1100px){.app{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:1rem;padding:12px}

  /* Felt table */
  .table-wrap{display:flex;justify-content:center;align-items:center}
  .table{
    width:min(82vh,82vw);height:min(82vh,82vw);
    border-radius:9999px;position:relative;
    background:radial-gradient(circle at 50% 45%,var(--felt1) 0%,var(--felt2) 55%,var(--felt3) 100%);
    border:9px solid rgba(79,70,229,.45);
    box-shadow:inset 0 0 44px rgba(79,70,229,.35),0 0 40px rgba(20,184,166,.15);
    overflow:visible;
  }

  /* HUD */
  .hud{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    display:flex;gap:.6rem;background:#0b1220c8;border:1px solid #263247;color:#c7d2fe;
    padding:.35rem .6rem;border-radius:.55rem;font-weight:800;font-size:.8rem;z-index:6
  }

  /* Seats */
  .seat{
    position:absolute;transform:translate(-50%,-50%);
    width:78px;height:78px;border-radius:9999px;background:#141d2d;border:2px solid #2a3a52;
    display:flex;align-items:center;justify-content:center;font-weight:900;font-size:.78rem;color:#9fb2cc;
    user-select:none;box-shadow:0 6px 18px rgba(0,0,0,.45);transition:.15s all ease;
  }
  .seat.hero{border-color:var(--green);color:#d1fae5;box-shadow:0 0 26px rgba(34,197,94,.6)}
  .seat.acting{border-color:#fbbf24;color:#fde68a;box-shadow:0 0 26px rgba(251,191,36,.85)}
  .seat.folded{filter:grayscale(.65);border-color:#334155;color:#64748b}
  .stack{
    position:absolute;top:calc(100% + 12px);left:50%;transform:translateX(-50%);
    background:#0b1220;border:1px solid #313a52;border-radius:9999px;color:#c7d2fe;
    padding:2px 8px;font-size:.72rem;font-weight:800;white-space:nowrap
  }

  /* Cards */
  .board{position:absolute;top:44%;left:50%;transform:translate(-50%,-50%);display:flex;gap:8px;z-index:4}
  .heroCards{position:absolute;display:flex;gap:8px;z-index:5;transform:translate(-50%,-50%)}
  .card{
    width:86px;height:120px;border-radius:14px;
    background:linear-gradient(160deg,#fff 0%,#eef2ff 70%,#e7e9ff 100%);
    border:2px solid rgba(99,102,241,.85);
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    box-shadow:0 10px 26px rgba(0,0,0,.35)
  }
  .rank{font:900 42px/1 Inter,sans-serif}
  .suit{font:900 34px/1 Inter,sans-serif;margin-top:2px}
  .red{color:#ef4444}
  .black{color:#0f172a}

  /* Chip tags (persist per street) */
  .chipTag{
    position:absolute;transform:translate(-50%,-50%);
    background:#0a1320;border:1px solid rgba(99,102,241,.55);color:#c7d2fe;border-radius:.6rem;
    padding:.25rem .5rem;font-weight:900;font-size:.72rem;white-space:nowrap;box-shadow:0 8px 18px rgba(0,0,0,.45);
    z-index:7;pointer-events:none
  }

  /* Actions area (below table) */
  .actionPanel{margin-top:14px}
  .prompt{color:var(--muted);font-size:.92rem;margin-bottom:.6rem}
  .actions{display:flex;flex-wrap:wrap;gap:.6rem;justify-content:center}
  .aBtn{
    border:0;border-radius:.8rem;padding:.85rem 1.1rem;font-weight:900;cursor:pointer;
    color:#fff;background:#223055
  }
  .aBtn.primary{background:linear-gradient(135deg,var(--ring),var(--teal))}
  .aBtn.danger{background:linear-gradient(135deg,#ef4444,#dc2626)}
  .aBtn.ghost{background:rgba(20,184,166,.12);color:#5eead4;border:1px solid rgba(45,212,191,.35)}

  /* Right sidebar */
  .result{
    display:none;background:linear-gradient(135deg,var(--ring),var(--teal));
    color:#fff;border-radius:1rem;padding:14px;font-weight:800;box-shadow:0 0 26px rgba(79,70,229,.25)
  }
  .result .big{font-size:40px}
  .logItem{display:flex;justify-content:space-between;align-items:center;background:#0b1220;border:1px solid var(--border);border-radius:.7rem;padding:.55rem .7rem;margin:.5rem 0}
  .good{color:#22c55e}.bad{color:#ef4444}
</style>
</head>
<body>
  <div class="topbar">
    <div class="brand">GTO Shark • Live Practice</div>
    <div class="select">
      <span>Players</span>
      <select id="selPlayers">
        <option value="9" selected>9-max</option>
        <option value="8">8-max</option>
        <option value="7">7-max</option>
        <option value="6">6-max</option>
        <option value="5">5-max</option>
      </select>
    </div>
    <div class="select">
      <span>Hero</span>
      <select id="selHero"></select>
    </div>
    <div class="select">
      <span>Play to</span>
      <select id="selRange">
        <option value="preflop">Preflop</option>
        <option value="turn">Turn</option>
        <option value="river" selected>River</option>
      </select>
    </div>
    <button id="btnNew" class="btn">New Hand</button>
  </div>

  <div class="app">
    <main>
      <!-- Table -->
      <div class="table-wrap">
        <div id="table" class="table">
          <div id="hud" class="hud"><span id="hudStreet">—</span>|<span id="hudPot">Pot —</span>|<span id="hudSPR">SPR —</span></div>
          <div id="board" class="board"></div>
          <div id="seatsLayer"></div>
          <div id="floatLayer"></div>
          <div id="heroCards" class="heroCards"></div>
        </div>
      </div>

      <!-- Actions below table -->
      <div class="panel actionPanel">
        <div id="prompt" class="prompt">Loading…</div>
        <div id="actions" class="actions"></div>
      </div>
    </main>

    <!-- Sidebar -->
    <aside>
      <div id="result" class="result">
        <div id="scorePct" class="big">—%</div>
        <div id="scoreVerdict"></div>
      </div>
      <div class="panel">
        <div style="font-weight:900;color:#c7d2fe;margin-bottom:.4rem">Hand Log</div>
        <div id="logList"></div>
      </div>
    </aside>
  </div>

<script>
/* ===========================================================
   Utility & constants
   =========================================================== */
const RANKS=['2','3','4','5','6','7','8','9','T','J','Q','K','A'];
const SUITS=['♠','♥','♦','♣'];
const POS_9 = ['SB','BB','UTG','UTG+1','UTG+2','LJ','HJ','CO','BTN'];
const POS_8 = ['SB','BB','UTG','UTG+1','HJ','CO','BTN','LJ']; // compact
const POS_7 = ['SB','BB','UTG','HJ','CO','BTN','LJ'];
const POS_6 = ['SB','BB','UTG','HJ','CO','BTN'];
const POS_5 = ['SB','BB','UTG','CO','BTN'];
const TEMPLATES={5:POS_5,6:POS_6,7:POS_7,8:POS_8,9:POS_9};

const $ = (id)=>document.getElementById(id);
const tableEl = $('table');
const boardEl = $('board');
const seatsLayer = $('seatsLayer');
const floatLayer = $('floatLayer');
const heroCardsEl = $('heroCards');
const hudStreet = $('hudStreet');
const hudPot = $('hudPot');
const hudSPR = $('hudSPR');
const promptEl = $('prompt');
const actionsEl = $('actions');
const resultEl = $('result');
const scorePctEl = $('scorePct');
const scoreVerdictEl = $('scoreVerdict');
const logListEl = $('logList');
const selPlayers = $('selPlayers');
const selHero = $('selHero');
const selRange = $('selRange');
const btnNew = $('btnNew');

/* ===========================================================
   RNG & cards
   =========================================================== */
function randInt(n){return Math.floor(Math.random()*n);}
function randomCard(){
  const r=RANKS[randInt(13)]; const s=SUITS[randInt(4)];
  const color=(s==='♥'||s==='♦')?'red':'black';
  return {r,s,color,code:r+s};
}
function cardHTML(c){
  return `<div class="card"><div class="rank ${c.color}">${c.r}</div><div class="suit ${c.color}">${c.s}</div></div>`;
}
function dealUnique(taken, n){
  const out=[];
  while(out.length<n){
    const c=randomCard();
    if(!taken.has(c.code)){taken.add(c.code);out.push(c);}
  }
  return out;
}

/* ===========================================================
   State
   =========================================================== */
const State = {
  players: 9,
  seats: [],                // seat names
  hero: 'BTN',
  heroIndex: 8,             // index in seats
  playTo: 'river',          // preflop | turn | river
  stage: 'idle',            // idle | preflop | flop | turn | river | showdown

  stacks: {},               // seat -> BB
  hands: {},                // seat -> [c1,c2]
  folded: {},               // seat -> bool
  committed: {},            // seat -> amount committed THIS STREET
  totalCommitted: {},       // seat -> total committed (for pot side tracking if needed)

  pot: 0,                   // central pot BB
  currentTo: 0,             // the current total amount a player must match
  lastRaiseSize: 1,         // min raise increment for next legal raise (preflop starts at 1 BB)
  actingIndex: 0,           // turn pointer (varies by street)
  showdownSet: new Set(),   // who reaches showdown (hero + non-folded who didn’t fold)
  chipTags: {},             // seat -> DOM chip tag (persist until street changes)

  nodes: {},                // seat -> {root,stack}
  taken: new Set(),         // deck tracker
};

/* ===========================================================
   Layout & rendering
   =========================================================== */
function coordsForSeat(i,n){
  // circle layout, centered
  const angle = (Math.PI*2)*(i/n) - Math.PI/2;
  const radius = 42; // percent
  return {left: 50+radius*Math.cos(angle), top: 50+radius*Math.sin(angle)};
}
function buildSeatNodes(){
  seatsLayer.innerHTML='';
  State.nodes={};
  for(let i=0;i<State.seats.length;i++){
    const seat = State.seats[i];
    const el = document.createElement('div');
    el.className='seat';
    el.dataset.seat=seat;
    el.textContent=seat; // label (updated to "Fold" only when folding)
    const p = coordsForSeat(i, State.seats.length);
    el.style.left = `${p.left}%`;
    el.style.top  = `${p.top}%`;
    const stack = document.createElement('div');
    stack.className='stack';
    stack.id = `stack-${seat}`;
    stack.textContent = `${(State.stacks[seat]??100).toFixed(1)} BB`;
    el.appendChild(stack);
    seatsLayer.appendChild(el);
    State.nodes[seat] = {root: el, stack};
  }
}
function setHeroHighlight(){
  Object.values(State.nodes).forEach(n => n.root.classList.remove('hero'));
  State.nodes[State.hero]?.root.classList.add('hero');
}
function setActing(seat, on){
  const n = State.nodes[seat]; if(!n) return;
  if(on){ n.root.classList.add('acting'); setTimeout(()=>n.root.classList.remove('acting'), 1200); }
}
function updateStacksUI(){
  State.seats.forEach(seat=>{
    const st = State.nodes[seat]?.stack;
    if(st) st.textContent = `${State.stacks[seat].toFixed(1)} BB`;
  });
}
function renderHUD(){
  hudStreet.textContent = State.stage.toUpperCase();
  hudPot.textContent = `Pot ${State.pot.toFixed(1)} BB`;
  const live = State.seats.filter(s=>!State.folded[s] && State.stacks[s]>0);
  const eff = live.length ? Math.min(...live.map(s=>State.stacks[s])) : 0;
  const spr = (eff/Math.max(1,State.pot)).toFixed(1);
  hudSPR.textContent = `SPR ${spr}`;
}
function clearBoard(){ boardEl.innerHTML=''; }
function renderBoard(){
  boardEl.innerHTML= State.board.map(cardHTML).join('');
}
function renderHeroCards(){
  // One instance only; position by hero seat
  heroCardsEl.innerHTML='';
  const hero = State.hero;
  const h = State.hands[hero];
  if(!h) return;
  heroCardsEl.innerHTML = cardHTML(h[0]) + cardHTML(h[1]);
  const node = State.nodes[hero]?.root;
  if(node){
    heroCardsEl.style.left = node.style.left;
    heroCardsEl.style.top  = node.style.top;
  }
}

/* ===========================================================
   Chip Tags (persist until street changes)
   =========================================================== */
function clearChipTags(){
  // remove all existing chip tags from DOM
  Object.values(State.chipTags).forEach(tag => tag.remove());
  State.chipTags = {};
}
function showChipTag(seat, label){
  // create or update persistent tag
  const node = State.nodes[seat]; if(!node) return;
  if(State.chipTags[seat]) State.chipTags[seat].remove();
  const tag = document.createElement('div');
  tag.className='chipTag';
  tag.textContent = label;
  // place toward center a bit, above the seat
  const topNum = parseFloat(node.root.style.top);
  const leftNum = parseFloat(node.root.style.left);
  tag.style.left = `${leftNum}%`;
  tag.style.top  = `calc(${topNum}% - 44px)`;
  floatLayer.appendChild(tag);
  State.chipTags[seat] = tag;
}

/* ===========================================================
   Pot & commitment helpers
   =========================================================== */
function resetStreetAccounting(){
  State.committed = {};
  State.seats.forEach(s => State.committed[s]=0);
  State.currentTo = 0;
  // blinds on preflop
  if(State.stage==='preflop'){
    if(State.seats.includes('SB')){
      State.committed['SB']=0.5;
      State.stacks['SB'] = Math.max(0, +(State.stacks['SB']-0.5).toFixed(1));
      showChipTag('SB','SB 0.5 BB');
    }
    if(State.seats.includes('BB')){
      State.committed['BB']=1.0;
      State.stacks['BB'] = Math.max(0, +(State.stacks['BB']-1.0).toFixed(1));
      showChipTag('BB','BB 1.0 BB');
      State.currentTo = 1.0;
      State.lastRaiseSize = 1.0; // min raise increment (initial)
    }
    State.pot = +(Object.values(State.committed).reduce((a,b)=>a+b,0)).toFixed(1); // 1.5
  }
  updateStacksUI(); renderHUD();
}
function toCall(seat){
  return Math.max(0, +(State.currentTo - (State.committed[seat]||0)).toFixed(1));
}
function commitTo(seat, newTotal){
  // player must reach newTotal total contribution this street
  const need = +(newTotal - (State.committed[seat]||0)).toFixed(1);
  if(need<=0) return 0;
  const pay = Math.min(need, State.stacks[seat]);
  State.stacks[seat] = +(State.stacks[seat] - pay).toFixed(1);
  State.committed[seat] = +((State.committed[seat]||0) + pay).toFixed(1);
  State.pot = +(State.pot + pay).toFixed(1);
  updateStacksUI(); renderHUD();
  return pay;
}
function everyoneEqualized(){
  const alive = State.seats.filter(s=>!State.folded[s] && State.stacks[s]>=0);
  return alive.every(s => +(State.committed[s]||0) === +State.currentTo );
}

/* ===========================================================
   Turn order & stage helpers
   =========================================================== */
function preflopOrder(){
  // UTG … BTN … SB … BB (BB last preflop)
  const idx = State.seats.indexOf('UTG');
  const arr = [];
  for(let i=idx;i<State.seats.length;i++) arr.push(State.seats[i]);
  for(let i=0;i<idx;i++) arr.push(State.seats[i]);
  // ensure BB last
  const noBB = arr.filter(s=>s!=='BB');
  return [...noBB,'BB'];
}
function postflopOrder(){
  // First active left of BTN → typically SB first
  const idxBTN = State.seats.indexOf('BTN');
  const arr=[];
  for(let i=idxBTN+1;i<State.seats.length;i++) arr.push(State.seats[i]);
  for(let i=0;i<=idxBTN;i++) arr.push(State.seats[i]);
  return arr;
}
function setPrompt(txt){
  promptEl.textContent = txt || `${State.stage.toUpperCase()}: Your action as ${State.hero}.`;
}

/* ===========================================================
   Very-simplified “GTO-ish” policy (kept deterministic/legal)
   (You can later swap for a stronger oracle. Focus here is legality.)
   =========================================================== */
function handStrength([a,b]){
  // rank points (A high), pocket pair bonus, suited bonus, connector bonus
  const v = (r)=>RANKS.indexOf(r); // lower index is worse here, invert
  const strength = (12 - v(a.r)) + (12 - v(b.r))
                 + (a.r===b.r ? 6 : 0)
                 + (a.s===b.s ? 2 : 0)
                 + (Math.abs(v(a.r)-v(b.r))<=1 ? 2 : 0);
  return strength; // 0..?(~30)
}
function villainDecision(seat){
  // return 'fold' | 'call' | 'raise' with legal sizing chosen if raise
  // pick by strength and facing action
  const need = toCall(seat);
  const hs = handStrength(State.hands[seat]);
  // tendencies:
  // strong → raise/call, medium → call, weak → fold (if need>0)
  if(need===0){
    if(hs>=18) return {type:'bet', size:Math.max(1, Math.round(State.pot*0.5))};
    if(hs>=14) return {type:'check'};
    return {type:'check'};
  } else {
    if(hs<10 && need>0) return {type:'fold'};
    if(hs>=20){
      // raise with legal minimum
      const minRaiseTotal = +(State.currentTo + Math.max(1, State.lastRaiseSize)).toFixed(1);
      const myCap = +((State.committed[seat]||0)+State.stacks[seat]).toFixed(1);
      const to = Math.min(myCap, minRaiseTotal + Math.max(0, Math.round(State.pot*0.25)));
      if(to > State.currentTo) return {type:'raise', to:+to.toFixed(1)};
      // if can’t legally raise, call
      return {type:'call'};
    }
    if(hs>=12) return {type:'call'};
    return {type:'fold'};
  }
}

/* ===========================================================
   Actions (villain & hero)
   =========================================================== */
function markFold(seat){
  State.folded[seat]=true;
  const n=State.nodes[seat];
  if(n){
    n.root.classList.add('folded');
    n.root.textContent='Fold'; // overwrite seat label ONLY when folding
  }
  showChipTag(seat,'Fold');
}
function villainActQueue(order, i, onDone){
  if(i>=order.length){ onDone(); return; }
  const seat = order[i];
  if(seat===State.hero || State.folded[seat]){ villainActQueue(order,i+1,onDone); return; }

  setActing(seat,true);
  setTimeout(()=>{
    setActing(seat,false);
    // If player is all-in, skip acting
    if(State.stacks[seat]<=0){ villainActQueue(order,i+1,onDone); return; }

    const need = toCall(seat);
    const dec = villainDecision(seat);

    if(dec.type==='fold'){
      if(need>0){ markFold(seat); }
      // if need==0 and chooses fold, that’s a check (don’t allow folding for 0)
      else { showChipTag(seat,'Check'); }
    }
    else if(dec.type==='check'){
      if(need===0) showChipTag(seat,'Check');
      else{
        // cannot check facing a bet, must call/fold/raise
        // default to fold if weak
        if(handStrength(State.hands[seat])<12) { markFold(seat); }
        else {
          const paid = commitTo(seat, State.currentTo);
          showChipTag(seat, `Call ${paid.toFixed(1)} BB`);
        }
      }
    }
    else if(dec.type==='call'){
      const paid = commitTo(seat, State.currentTo);
      showChipTag(seat, paid>0 ? `Call ${paid.toFixed(1)} BB` : 'Check');
    }
    else if(dec.type==='bet'){
      // betting when need==0 (postflop opener)
      const baseTo = +((State.committed[seat]||0) + dec.size).toFixed(1);
      const myCap  = +((State.committed[seat]||0) + State.stacks[seat]).toFixed(1);
      const to = Math.min(myCap, baseTo);
      if(to > State.currentTo){
        State.lastRaiseSize = +(to - State.currentTo).toFixed(1);
        State.currentTo = to;
        const paid = commitTo(seat, State.currentTo);
        showChipTag(seat, (paid>=State.stacks[seat]+paid)?'All-in':`Bet ${paid.toFixed(1)} BB`);
      } else {
        // fallback to check if cannot increase
        showChipTag(seat,'Check');
      }
    }
    else if(dec.type==='raise'){
      // legal raise sizing already picked; enforce minimum again
      const minRaiseTotal = +(State.currentTo + Math.max(1, State.lastRaiseSize)).toFixed(1);
      let to = Math.max(minRaiseTotal, dec.to);
      const myCap  = +((State.committed[seat]||0) + State.stacks[seat]).toFixed(1);
      to = Math.min(myCap, to);

      if(to > State.currentTo){
        const inc = +(to - State.currentTo).toFixed(1);
        State.lastRaiseSize = inc; // update LRS to the size of THIS raise
        State.currentTo = to;
        const paid = commitTo(seat, State.currentTo);
        showChipTag(seat, (paid>=State.stacks[seat]+paid)?'All-in':`Raise ${paid.toFixed(1)} BB`);
      } else {
        // can’t raise → call if needed
        const paid = commitTo(seat, State.currentTo);
        showChipTag(seat, paid>0 ? `Call ${paid.toFixed(1)} BB` : 'Check');
      }
    }

    villainActQueue(order, i+1, onDone);
  }, 650 + Math.random()*450);
}

function heroOffer(){
  actionsEl.innerHTML='';
  const need = toCall(State.hero);
  const eff  = State.stacks[State.hero];

  // Fold always allowed
  addAction('Fold','ghost', ()=> heroDo('fold'));

  if(need===0) addAction('Check','ghost',()=> heroDo('check'));
  if(need>0)   addAction(`Call ${Math.min(need, eff).toFixed(1)} BB`,'primary',()=> heroDo('call'));

  // Min-raise (legal): currentTo + lastRaiseSize. If facing no bet (postflop), lastRaiseSize is at least 1 BB.
  const minRaiseTotal = +(State.currentTo + Math.max(1, State.lastRaiseSize)).toFixed(1);
  if(minRaiseTotal > (State.committed[State.hero]||0)){
    const canTotal = +((State.committed[State.hero]||0) + eff).toFixed(1);
    if(canTotal > State.currentTo){
      const to = Math.min(canTotal, minRaiseTotal);
      addAction(`Raise to ${to.toFixed(1)} BB`,'primary', ()=> heroDo({type:'raise', to}));
    }
  }

  if(eff>0) addAction('All-in','danger', ()=> heroDo('allin'));

  setPrompt();
}

function addAction(label, kind, fn){
  const b = document.createElement('button');
  b.className = `aBtn ${kind}`;
  b.textContent = label;
  b.onclick = fn;
  actionsEl.appendChild(b);
}

function heroDo(action){
  // End the hand IMMEDIATELY if hero folds or jams, OR if our “playTo” street is reached after hero action.
  const seat = State.hero;
  if(action==='fold'){
    markFold(seat);
    endHand('Hero folded');
    return;
  }
  if(action==='check'){
    showChipTag(seat,'Check');
    afterHeroAct();
    return;
  }
  if(action==='call'){
    const paid = commitTo(seat, State.currentTo);
    showChipTag(seat, paid>0 ? `Call ${paid.toFixed(1)} BB` : 'Check');
    afterHeroAct();
    return;
  }
  if(action==='allin'){
    // commit everything
    const cap = +((State.committed[seat]||0) + State.stacks[seat]).toFixed(1);
    const newTotal = Math.max(State.currentTo, cap);
    // If this increases over currentTo, update lastRaiseSize
    if(newTotal > State.currentTo){
      State.lastRaiseSize = +(newTotal - State.currentTo).toFixed(1);
      State.currentTo = newTotal;
    }
    commitTo(seat, State.currentTo);
    showChipTag(seat,'All-in');
    endHand('Hero jammed');
    return;
  }
  if(typeof action==='object' && action.type==='raise'){
    const to = +action.to.toFixed(1);
    const minLegal = +(State.currentTo + Math.max(1, State.lastRaiseSize)).toFixed(1);
    const myCap = +((State.committed[seat]||0) + State.stacks[seat]).toFixed(1);
    const legalTo = Math.max(minLegal, Math.min(to, myCap));
    if(legalTo<=State.currentTo){
      // fallback to call if cannot raise
      const paid = commitTo(seat, State.currentTo);
      showChipTag(seat, paid>0 ? `Call ${paid.toFixed(1)} BB` : 'Check');
      afterHeroAct();
      return;
    }
    const inc = +(legalTo - State.currentTo).toFixed(1);
    State.lastRaiseSize = inc;
    State.currentTo = legalTo;
    const paid = commitTo(seat, State.currentTo);
    showChipTag(seat, (paid>=State.stacks[seat]+paid)?'All-in':`Raise ${paid.toFixed(1)} BB`);
    afterHeroAct();
    return;
  }
}

/* ===========================================================
   Streets, progression & finishing
   =========================================================== */
function clearForNewStreet(){
  // Persist hero/villain chip tags? Requirement: chip tags should persist UNTIL street changes
  clearChipTags();
  State.committed = {};
  State.seats.forEach(s => State.committed[s]=0);
  State.currentTo = 0;
  State.lastRaiseSize = 1; // postflop: first opener must be at least 1 BB
}

function dealBoard(num){
  const add = dealUnique(State.taken, num);
  State.board = (State.board||[]).concat(add);
  renderBoard();
}

function beginPreflop(){
  State.stage='preflop';
  State.board=[];
  resetStreetAccounting();
  renderBoard();
  renderHeroCards();
  runPreflopBeforeHero();
}

function beginFlop(){
  clearForNewStreet();
  State.stage='flop';
  dealBoard(3);
  renderHUD();
  runPostflopBeforeHero();
}

function beginTurn(){
  clearForNewStreet();
  State.stage='turn';
  dealBoard(1);
  renderHUD();
  runPostflopBeforeHero();
}

function beginRiver(){
  clearForNewStreet();
  State.stage='river';
  dealBoard(1);
  renderHUD();
  runPostflopBeforeHero();
}

function afterHeroAct(){
  // If we only play to the current street, finish immediately.
  if( (State.playTo==='preflop' && State.stage==='preflop') ||
      (State.playTo==='turn'    && State.stage==='turn')    ||
      (State.playTo==='river'   && State.stage==='river') ){
    endHand('Sequence target reached');
    return;
  }

  // Otherwise, after hero acts, the rest of table completes round, then proceed to next street
  const order = (State.stage==='preflop') ? preflopOrder() : postflopOrder();
  const idxHero = order.indexOf(State.hero);
  villainActQueue(order, idxHero+1, ()=>{
    // If players are not equalized, cycle back to hero
    if(!everyoneEqualized()){
      heroOffer();
      return;
    }
    // Advance to next street
    if(State.stage==='preflop') beginFlop();
    else if(State.stage==='flop') beginTurn();
    else if(State.stage==='turn') beginRiver();
    else if(State.stage==='river') endHand('River reached');
  });
}

function runPreflopBeforeHero(){
  const order = preflopOrder();
  const idxHero = order.indexOf(State.hero);
  villainActQueue(order, 0, ()=>{
    // stop at hero
    heroOffer();
  });
}

function runPostflopBeforeHero(){
  const order = postflopOrder();
  const idxHero = order.indexOf(State.hero);
  villainActQueue(order, 0, ()=>{
    heroOffer();
  });
}

/* ===========================================================
   Start / reset hand
   =========================================================== */
function startNewHand(){
  actionsEl.innerHTML='';
  resultEl.style.display='none';
  scorePctEl.textContent='—%'; scoreVerdictEl.textContent='';

  const np = parseInt(selPlayers.value,10);
  State.players = np;
  State.seats = TEMPLATES[np].slice();

  // hero existence
  if(!State.seats.includes(State.hero)){
    State.hero = State.seats.includes('BTN') ? 'BTN' : State.seats[np-1];
  }
  // hero dropdown options
  selHero.innerHTML = State.seats.map(s=>`<option ${s===State.hero?'selected':''}>${s}</option>`).join('');
  State.hero = selHero.value;
  State.heroIndex = State.seats.indexOf(State.hero);
  State.playTo = selRange.value;

  // stacks / hands / resets
  State.stacks={}; State.folded={}; State.totalCommitted={}; State.taken=new Set();
  State.seats.forEach(s=>{ State.stacks[s]=100; State.folded[s]=false; State.totalCommitted[s]=0; });
  State.hands={};
  State.seats.forEach(s=>{ State.hands[s]=dealUnique(State.taken,2); });

  buildSeatNodes();
  setHeroHighlight();
  updateStacksUI();
  State.pot=0; State.board=[]; State.showdownSet=new Set();

  // hero hole cards
  renderHeroCards();
  renderHUD();
  clearChipTags();

  // begin hand automatically
  beginPreflop();
}

/* ===========================================================
   Finish & scoring
   =========================================================== */
function computeScore(){
  // Simple proxy scoring:
  // Good folds of trash preflop = 100
  // Penalty for illegal/over-aggressive jams with weak hands
  let score = 75;
  const h = State.hands[State.hero];
  const hs = handStrength(h);
  // if hero folded on preflop with poor hand → boost
  if(State.stage!=='showdown' && State.folded[State.hero]){
    if(hs<=10) score = 100;
    else if(hs<=14) score = 88;
    else score = 70;
  }
  // if hero jammed preflop with very weak stuff → punish
  // crude heuristic: if total committed by hero >= stack start and hs < threshold
  const heroPaid = (State.totalCommitted[State.hero]||0);
  if(heroPaid>=100 && hs<18) score = Math.max(25, 90 - (18-hs)*4);

  return Math.max(0, Math.min(100, Math.round(score)));
}
function verdict(p){ return p>=85?'Excellent':p>=70?'Strong':p>=50?'OK':'Needs work'; }

function endHand(reason){
  // Only reveal hero and showdown opponents (those not folded at the end).
  State.stage='showdown';
  // build showdown set
  State.showdownSet = new Set(State.seats.filter(s=>!State.folded[s]));
  // Reveal only hero + others who reached showdown (i.e., not folded). Do NOT reveal folders.
  revealForShowdown();

  // scoring (at end only)
  const pct = computeScore();
  resultEl.style.display='block';
  scorePctEl.textContent = `${pct}%`;
  scoreVerdictEl.textContent = verdict(pct);
  // log
  const row = document.createElement('div');
  row.className='logItem';
  row.innerHTML = `<div>${State.hero} • ${State.players}-max • ${State.playTo.toUpperCase()}</div>
                   <div class="${pct>=50?'good':'bad'}" style="font-weight:900">${pct}% ${pct>=50?'✅':'❌'}</div>`;
  logListEl.prepend(row);

  // “Next hand” button
  actionsEl.innerHTML='';
  addAction('Next Hand','primary', startNewHand);
}

/* Reveal logic: hero always, villains only if not folded (i.e., showdown) */
function revealForShowdown(){
  // remove any previous temporary hero cards above hero (we’ll recreate compact reveals)
  // but keep them by design request? We will keep the heroCards above the hero.
  // Add showdown reveals for non-hero, non-folded seats:
  const toShow = State.seats.filter(s=> s!==State.hero && !State.folded[s]);
  toShow.forEach(seat=>{
    const node = State.nodes[seat]; if(!node) return;
    // create two small cards just above their circle (not overlapping labels)
    const holder = document.createElement('div');
    holder.style.position='absolute';
    holder.style.left=node.root.style.left;
    holder.style.top=`calc(${node.root.style.top} - 54px)`;
    holder.style.transform='translate(-50%,-50%)';
    holder.style.display='flex';
    holder.style.gap='6px';
    holder.style.zIndex='8';
    holder.innerHTML = State.hands[seat].map(c=>{
      return `<div class="card" style="width:72px;height:100px;border-radius:12px">${cardHTML(c)}</div>`;
    }).join('');
    floatLayer.appendChild(holder);
  });
}

/* ===========================================================
   Wiring
   =========================================================== */
function savePrefs(){
  localStorage.setItem('gto_players', selPlayers.value);
  localStorage.setItem('gto_hero', selHero.value);
  localStorage.setItem('gto_playto', selRange.value);
}
function restorePrefs(){
  const p = localStorage.getItem('gto_players');
  const h = localStorage.getItem('gto_hero');
  const r = localStorage.getItem('gto_playto');
  if(p && TEMPLATES[+p]) selPlayers.value=p;
  if(r) selRange.value=r;
  // hero restored after seats built
  return h;
}

btnNew.onclick = ()=>{ savePrefs(); startNewHand(); };
selPlayers.onchange = ()=>{ savePrefs(); startNewHand(); };
selHero.onchange = ()=>{ State.hero = selHero.value; State.heroIndex = State.seats.indexOf(State.hero); setHeroHighlight(); renderHeroCards(); setPrompt(); savePrefs(); };
selRange.onchange = ()=>{ State.playTo = selRange.value; savePrefs(); };

function init(){
  const wantHero = restorePrefs();

  // initial seats & hero
  State.players = parseInt(selPlayers.value,10);
  State.seats = TEMPLATES[State.players].slice();
  selHero.innerHTML = State.seats.map(s=>`<option>${s}</option>`).join('');
  if(wantHero && State.seats.includes(wantHero)) selHero.value = wantHero;
  State.hero = selHero.value;
  State.heroIndex = State.seats.indexOf(State.hero);

  startNewHand(); // auto-start
}
init();

/* ===========================================================
   NOTE: Accurate per-street pot accounting for “totalCommitted”
         (kept simple; can be expanded if you add side pots).
   Wrap commitTo to also add to totalCommitted.
   =========================================================== */
// Patch commitTo to also track totalCommitted by seat
const _commitTo = commitTo;
commitTo = function(seat, newTotal){
  const before = (State.committed[seat]||0);
  const paid = _commitTo(seat, newTotal);
  const inc = (State.committed[seat]||0) - before;
  State.totalCommitted[seat] = +((State.totalCommitted[seat]||0) + Math.max(0,inc)).toFixed(1);
  return paid;
};
</script>
</body>
</html>









