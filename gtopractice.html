<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>GTO Shark • Live Practice (Vanilla)</title>
  <style>
    :root{
      --felt-1:#003a36; --felt-2:#001f1d; --indigo:#4f46e5; --teal:#14b8a6;
      --ink:#e2f3f1; --slate:#0d1a1a; --hero:#22c55e; --acting:#f59e0b;
      --chip-bg:#0e7490; --chip-ink:#fff; --ring:#7dd3fc;
    }
    html,body{height:100%}
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      color:var(--ink);
      background: radial-gradient(1200px 700px at 50% -10%, #014a43 0%, var(--felt-1) 43%, var(--felt-2) 100%);
      overflow-x:hidden;
    }

    /* HUD */
    .hud{
      max-width: 1160px; margin: 14px auto 10px auto; padding: 10px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      color:#bff3ea; font-weight:700; background: rgba(0,30,30,.45);
      border:1px solid rgba(20,184,166,.35); border-radius: 12px; backdrop-filter: blur(4px);
    }
    .hud .left, .hud .right{ display:flex; align-items:center; gap:16px; flex-wrap:wrap; }
    .pill{ background: rgba(79,70,229,.18); border:1px solid rgba(79,70,229,.45); color:#c7d2fe; padding:6px 10px; border-radius:10px; font-weight:800; }

    /* Control strip */
    .controls{
      max-width:1160px; margin: 0 auto 10px auto; display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;
    }
    .group{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    label{ font-size:12px; opacity:.85 }
    select, input[type="number"]{
      padding:7px 10px; border-radius:8px; border:1px solid #164e63; background:#052325; color:#cceeed; font-weight:700; min-width: 110px;
    }
    button.primary{
      background: linear-gradient(135deg, var(--indigo), var(--teal));
      border:none; color:white; padding:10px 14px; border-radius:10px; font-weight:900; cursor:pointer;
      box-shadow: 0 12px 26px rgba(20,184,166,.25);
    }

    /* Table */
    .wrap{ max-width:1160px; margin: 0 auto; }
    #table{
      position:relative; width: 980px; height: 620px; margin: 12px auto 8px auto; border-radius:50%;
      background:
        radial-gradient(60% 45% at 50% 45%, #005147 0%, #003a36 60%, #002522 100%),
        radial-gradient(70% 50% at 50% 50%, rgba(79,70,229,.25) 0%, transparent 60%);
      box-shadow: inset 0 0 60px rgba(0,0,0,.65), 0 0 44px rgba(20,184,166,.25), 0 0 18px rgba(79,70,229,.25);
      border: 9px solid rgba(79,70,229,.35);
    }
    #board{ position:absolute; top:46%; left:50%; transform: translate(-50%,-50%); display:flex; gap:10px; z-index: 40; }
    #seatsLayer{ position:absolute; inset:0; }
    #floatLayer{ position:absolute; inset:0; pointer-events:none; z-index:70; }

    /* Seats */
    .seat{
      position:absolute; transform: translate(-50%, -50%);
      width:90px; height:90px; border-radius:9999px; background: rgba(255,255,255,.06);
      border: 2px solid rgba(255,255,255,.18); display:flex; align-items:center; justify-content:center;
      box-shadow: 0 6px 18px rgba(0,0,0,.35); color:#d3f8f2; font-size:12px; font-weight:900; text-transform:uppercase;
      transition: .2s ease filter, .2s ease box-shadow, .2s ease border-color, .2s ease transform;
    }
    .seat.hero{ border-color: rgba(34,197,94,.9); box-shadow:0 0 22px rgba(34,197,94,.55); color:#bbf7d0; }
    .seat.acting{ outline: 3px solid var(--acting); box-shadow:0 0 26px rgba(245,158,11,.65); }
    .seat.folded{ filter: grayscale(.8) brightness(.75); color: #f59e0b; }
    .stack{ position:absolute; top: calc(100% + 10px); left:50%; transform: translateX(-50%); font-size:12px; color:#d1fae5; background:#06333a; border:1px solid rgba(20,184,166,.45); padding:2px 8px; border-radius:999px; }

    /* Cards */
    .card{
      width:78px; height:112px; border-radius:14px; background: linear-gradient(160deg, #fff 0%, #f2f6ff 60%, #e5e9ff 100%);
      border: 2px solid rgba(79,70,229,.9); box-shadow: 0 10px 22px rgba(0,0,0,.35); display:flex; flex-direction:column; align-items:center; justify-content:center;
    }
    .rank{ font-size:38px; font-weight:900; line-height: 1; }
    .suit{ font-size:32px; line-height:1; margin-top: 2px; }
    .red{ color:#e11d48; } .black{ color:#0f172a; }
    .board-card{ width:72px; height:104px; border-radius:12px; }

    /* Hero hole cards holder (by seat) */
    .hero-cards{ position:absolute; display:flex; gap:8px; z-index:60; transform: translate(-50%, -60%); }

    /* Bet chips that persist until next street */
    .bet-chip{
      position:absolute; transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #083344, #0e7490); border:1px solid rgba(125,211,252,.6);
      color:#fff; padding:5px 8px; border-radius:10px; font-weight:900; font-size:12px;
      box-shadow: 0 8px 18px rgba(0,0,0,.35); display:flex; align-items:center; gap:6px;
    }
    .chip-icon{
      width:15px; height:15px; border-radius:9999px; background:
        radial-gradient(circle at 50% 50%, #f59e0b 0 26%, #7c3aed 28% 32%, #f59e0b 35% 60%, #7c3aed 63% 67%, #f59e0b 70%);
      border:1px solid rgba(245,158,11,.85); box-shadow:0 0 0 1px rgba(124,58,237,.75) inset;
    }

    /* Actions (below table) */
    #actions{ max-width: 980px; margin: 12px auto 18px auto; display:flex; flex-wrap:wrap; align-items:center; justify-content:center; gap:10px; }
    .btn{ border:none; border-radius:10px; padding:10px 14px; font-weight:900; cursor:pointer; transition:.15s; }
    .btn.primary{ background:#0ea5e9; color:white; }
    .btn.ghost{ background: rgba(20,184,166,.1); color:#99f6e4; border:1px solid rgba(45,212,191,.35); }
    .btn.danger{ background: linear-gradient(135deg, #ef4444, #dc2626); color:white; }

    /* Result panel (right, persistent) */
    .result{
      position: fixed; right: 16px; top: 16px; background: rgba(1,36,36,.94);
      border: 1px solid rgba(20,184,166,.6); padding: 12px 16px; border-radius: 12px; box-shadow: 0 0 24px rgba(0,0,0,.55);
      display:none; z-index: 120;
    }
    .result .score{ font-size: 40px; font-weight: 1000; }
    .good{ color:#22c55e } .bad{ color:#ef4444 }

    /* Smaller table toggle (fits 1080p comfortably) */
    @media (max-height: 900px){
      #table{ transform: scale(.92); transform-origin: top center; }
    }
  </style>
</head>
<body>
  <!-- HUD -->
  <div class="hud" id="hud">
    <div class="left">
      <div class="pill" id="hudStreet">Preflop</div>
      <div class="pill" id="hudPot">Pot 0 BB</div>
      <div class="pill" id="hudSPR">SPR —</div>
    </div>
    <div class="right">
      <div class="pill">GTO Shark — Indigo/Teal Felt</div>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <div class="group">
      <label>Scenario</label>
      <select id="scenario">
        <option value="none">None (free play)</option>
        <option value="standard" selected>Standard (full ring)</option>
        <option value="bvb">Blind vs Blind</option>
        <option value="btnvbb">BTN vs BB</option>
        <option value="covbb">CO vs BB</option>
        <option value="utgvbb">UTG vs BB</option>
        <option value="hjvbb">HJ vs BB</option>
        <option value="ljvbb">LJ vs BB</option>
      </select>

      <label>Sequence</label>
      <select id="sequence">
        <option value="preflop">Preflop Only</option>
        <option value="turn">Play to Turn</option>
        <option value="river" selected>Play to River</option>
      </select>

      <label>Hero</label>
      <select id="heroPos"></select>

      <label>Players</label>
      <select id="numPlayers">
        <option value="9" selected>9-max</option>
        <option value="8">8-max</option>
        <option value="6">6-max</option>
        <option value="5">5-max</option>
      </select>

      <label>Stack BB</label>
      <input id="stackBB" type="number" min="10" max="400" value="100" />
    </div>
    <div class="group">
      <button class="primary" id="newHand">♻ New Hand</button>
    </div>
  </div>

  <!-- Table -->
  <div class="wrap">
    <div id="table">
      <div id="seatsLayer"></div>
      <div id="board"></div>
      <div id="floatLayer"></div>
    </div>
  </div>

  <!-- Actions below table -->
  <div id="actions"></div>

  <!-- Result panel -->
  <div class="result" id="result">
    <div class="score" id="resultScore">0%</div>
    <div id="resultVerdict">—</div>
  </div>
  <script>
  /* ===== Core constants & helpers ===== */
  const POS_9 = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"];
  const POS_8 = ["UTG","UTG+1","LJ","HJ","CO","BTN","SB","BB"];
  const POS_6 = ["UTG","HJ","CO","BTN","SB","BB"];
  const POS_5 = ["UTG","CO","BTN","SB","BB"];
  const LAYOUTS = { 9: POS_9, 8: POS_8, 6: POS_6, 5: POS_5 };

  const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
  const SUITS = ["♠","♥","♦","♣"];
  const SUITCLASS = s => (s==="♥"||s==="♦")?"red":"black";

  const $ = sel => document.querySelector(sel);

  const hudStreet = $("#hudStreet");
  const hudPot = $("#hudPot");
  const hudSPR = $("#hudSPR");
  const scenarioSel = $("#scenario");
  const sequenceSel = $("#sequence");
  const heroSel = $("#heroPos");
  const numPlayersSel = $("#numPlayers");
  const stackBBSel = $("#stackBB");
  const newHandBtn = $("#newHand");

  const seatsLayer = $("#seatsLayer");
  const boardEl = $("#board");
  const floatLayer = $("#floatLayer");
  const tableEl = $("#table");
  const actionsEl = $("#actions");
  const resultEl = $("#result");
  const resultScoreEl = $("#resultScore");
  const resultVerdEl = $("#resultVerdict");

  /* ===== Game State ===== */
  const S = {
    players: 9,
    seats: [],            // names in order around table (clockwise)
    hero: "BTN",
    stackBB: 100,
    street: "preflop",    // preflop, flop, turn, river
    sequence: "river",    // preflop | turn | river
    hands: {},            // seat -> [c1,c2]
    board: [],            // 0/3/4/5
    active: {},           // seat -> true/false (folded => false)
    allin: {},            // seat -> true/false
    committed: {},        // seat -> total committed this street
    stack: {},            // seat -> remaining stack
    pot: 0,
    currentBet: 0,        // CurrentBetTotal (CB) this street
    lastRaise: 0,         // LastRaiseSize (LRS) this street
    actedThisStreet: new Set(),
    showdownSet: new Set(),   // villains revealed at showdown vs hero
    chipsOnTable: [],         // DOM chip nodes to clear each street
    heroTurnGate: false,      // true when it's hero's turn
    rngSeed: Date.now()|0
  };

  function resetStreetAccounting() {
    S.currentBet = 0;
    S.lastRaise = 0;
    S.committed = {};
    S.seats.forEach(p => S.committed[p] = 0);
  }

  function shuffleDeck() {
    const d = [];
    for (const r of RANKS) for (const s of SUITS) d.push(r+s);
    // Fisher-Yates seeded-ish shuffle
    let m = d.length, i;
    while (m) {
      i = Math.floor(rand() * m--);
      [d[m], d[i]] = [d[i], d[m]];
    }
    return d;
  }

  /* Simple seedable RNG */
  function srand(seed){ S.rngSeed = seed>>>0; }
  function rand(){
    // xorshift32
    let x = S.rngSeed|0;
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
    S.rngSeed = x>>>0;
    return (S.rngSeed % 100000) / 100000;
  }

  /* Deal unique cards from deck */
  function dealFrom(deck, n) {
    const out = [];
    for (let i=0; i<n; i++) out.push(deck.pop());
    return out;
  }

  /* Rendering */
  function clearBoard(){ boardEl.innerHTML = ""; }
  function renderBoard(){
    boardEl.innerHTML = "";
    S.board.forEach(c => {
      const el = document.createElement("div");
      el.className = "card board-card";
      el.innerHTML = `<div class="rank ${SUITCLASS(c[1])}">${c[0]}</div><div class="suit ${SUITCLASS(c[1])}">${c[1]}</div>`;
      boardEl.appendChild(el);
    });
  }

  function layoutSeats(){
    seatsLayer.innerHTML = "";
    const W = tableEl.clientWidth;
    const H = tableEl.clientHeight;
    const R = Math.min(W,H)*0.42; // radius
    const cx = W/2, cy = H/2;

    S.nodes = {};
    S.seats.forEach((name, idx) => {
      const a = (idx / S.seats.length) * Math.PI*2 - Math.PI/2;
      const x = cx + R * Math.cos(a);
      const y = cy + R * Math.sin(a);
      const seat = document.createElement("div");
      seat.className = "seat";
      seat.style.left = x + "px";
      seat.style.top  = y + "px";
      seat.dataset.pos = name;
      seat.textContent = name;

      const stack = document.createElement("div");
      stack.className = "stack";
      stack.id = `stack-${name}`;
      stack.textContent = `${S.stack[name]?.toFixed(1) ?? S.stackBB} BB`;
      seat.appendChild(stack);

      seatsLayer.appendChild(seat);
      S.nodes[name] = { seat, stack, pos:{x,y} };
    });
    setHeroGlow();
  }

  function setHeroGlow(){
    S.seats.forEach(p => {
      S.nodes[p].seat.classList.toggle("hero", p === S.hero);
    });
  }

  function setActing(pos, on){
    const node = S.nodes[pos]; if(!node) return;
    node.seat.classList.toggle("acting", !!on);
  }

  function labelFold(pos){
    const n = S.nodes[pos]; if(!n) return;
    n.seat.classList.add("folded");
    n.seat.textContent = "FOLD";
    // keep stack badge
    n.seat.appendChild(n.stack);
  }

  function placeHeroCards(){
    // one holder near hero seat
    const holderId = "heroCardsHolder";
    const old = document.getElementById(holderId);
    if(old) old.remove();

    const hero = S.hero;
    const n = S.nodes[hero]; if(!n) return;

    const hc = document.createElement("div");
    hc.id = holderId;
    hc.className = "hero-cards";
    hc.style.left = n.pos.x + "px";
    hc.style.top  = (n.pos.y - 26) + "px";

    const cards = S.hands[hero] || [];
    cards.forEach(c => {
      const el = document.createElement("div");
      el.className = "card";
      el.innerHTML = `<div class="rank ${SUITCLASS(c[1])}">${c[0]}</div><div class="suit ${SUITCLASS(c[1])}">${c[1]}</div>`;
      hc.appendChild(el);
    });

    tableEl.appendChild(hc);
  }

  function updateStacksUI(){
    S.seats.forEach(p=>{
      const n = S.nodes[p]; if(!n) return;
      n.stack.textContent = `${S.stack[p].toFixed(1)} BB`;
    });
  }

  function updateHUD(){
    hudStreet.textContent = S.street[0].toUpperCase() + S.street.slice(1);
    hudPot.textContent = `Pot ${S.pot.toFixed(1)} BB`;
    const live = S.seats.filter(p => S.active[p] && !S.allin[p]);
    const eff = live.length ? Math.min(...live.map(p=>S.stack[p])) : S.stackBB;
    const spr = (eff / Math.max(1, S.pot)).toFixed(1);
    hudSPR.textContent = `SPR ${spr}`;
  }

  /* Persisting bet chips until next street/fold */
  function chipPlate(pos, label){
    const n = S.nodes[pos]; if(!n) return;
    const plate = document.createElement("div");
    plate.className = "bet-chip";
    plate.style.left = n.seat.style.left;
    // toward center a bit (above)
    const y = parseFloat(n.seat.style.top);
    plate.style.top = (y - 56) + "px";
    plate.innerHTML = `<span class="chip-icon"></span><span>${label}</span>`;
    floatLayer.appendChild(plate);
    S.chipsOnTable.push({pos, node: plate});
  }
  function clearChipsForStreet(){
    S.chipsOnTable.forEach(c => c.node.remove());
    S.chipsOnTable = [];
  }

  /* ====== 5-card evaluator (fast, simple) ======
     This is a minimalist evaluator used only for showdown tie-breaks.
     It ranks hands roughly: 8 straight flush, 7 quads, 6 full house,
     5 flush, 4 straight, 3 trips, 2 two-pair, 1 pair, 0 high-card.
     Returns tuple: [rank, hi, k1, k2, kickers...] (bigger is better)
  */
  function eval5(cards){ // cards: array like ["A♠","K♥",...]
    const ranksMap = {A:14,K:13,Q:12,J:11,T:10,"9":9,"8":8,"7":7,"6":6,"5":5,"4":4,"3":3,"2":2};
    const rs = cards.map(c=>ranksMap[c[0]]).sort((a,b)=>b-a);
    const ss = cards.map(c=>c[1]);
    const counts = {};
    rs.forEach(r => counts[r] = (counts[r]||0)+1);
    const pairs = Object.entries(counts).sort((a,b)=> b[1]-a[1] || b[0]-a[0]).map(e=>[+e[0],e[1]]);
    const isFlush = ss.every(s => s===ss[0]);
    // straight
    const uniq = [...new Set(rs)];
    let isStr=false, top=0;
    for(let i=0;i<=uniq.length-5;i++){
      const seq = uniq.slice(i,i+5);
      if(seq[0]-seq[4]===4) { isStr=true; top=seq[0]; break; }
    }
    // wheel A5432
    if(!isStr && uniq.includes(14) && [5,4,3,2].every(v=>uniq.includes(v))){ isStr=true; top=5; }

    if(isFlush && isStr) return [8, top];
    if(pairs[0][1]===4)  return [7, pairs[0][0], pairs[1][0]];
    if(pairs[0][1]===3 && pairs[1]?.[1]===2) return [6, pairs[0][0], pairs[1][0]];
    if(isFlush)          return [5, ...rs];
    if(isStr)            return [4, top];
    if(pairs[0][1]===3)  return [3, pairs[0][0], ...rs.filter(r=>r!==pairs[0][0])];
    if(pairs[0][1]===2 && pairs[1]?.[1]===2){
      const hi = Math.max(pairs[0][0], pairs[1][0]), lo = Math.min(pairs[0][0], pairs[1][0]);
      const kick = rs.find(r => r!==hi && r!==lo);
      return [2, hi, lo, kick];
    }
    if(pairs[0][1]===2){
      const k = rs.filter(r=>r!==pairs[0][0]).slice(0,3);
      return [1, pairs[0][0], ...k];
    }
    return [0, ...rs];
  }

  /* Choose best 5 among 7 (hole 2 + board 5) for showdown comparing */
  function bestOf7(hole, board){
    // brute force combinations C(7,5)=21
    const seven = hole.concat(board);
    let best = null;
    for(let i=0;i<7;i++){
      for(let j=i+1;j<7;j++){
        const five = seven.filter((_,idx)=> idx!==i && idx!==j);
        const r = eval5(five);
        if(!best || compareRank(r,best)>0) best=r;
      }
    }
    return best;
  }
  function compareRank(a,b){
    for(let i=0;i<Math.max(a.length,b.length);i++){
      const av=a[i]??-1, bv=b[i]??-1;
      if(av!==bv) return av-bv;
    }
    return 0;
  }

  /* Strength proxy for GTO-like policy */
  function pfStrength(hole){
    const r1 = RANKS.indexOf(hole[0][0]), r2 = RANKS.indexOf(hole[1][0]);
    const pair = hole[0][0]===hole[1][0], suited = hole[0][1]===hole[1][1];
    const gap = Math.abs(r1-r2);
    let s = pair ? (100 - r1*3) : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?6:0);
    return s + rand()*2;
  }
  function postStrength(hole,board){
    const ranks = board.map(c=>c[0]);
    const hi = ranks.filter(r=>"AKQJT".includes(r)).length*2;
    const pair = ranks.some(r=>r===hole[0][0]||r===hole[1][0])?8:0;
    const suit = (hole[0][1]===hole[1][1])?3:0;
    return hi + pair + suit + rand()*2;
  }

  /* GTO-ish policy key */
  function policyKey(street, seat){
    if(street==="preflop"){
      const s = pfStrength(S.hands[seat]);
      if(s>92) return "raise_big";
      if(s>82) return "raise_med";
      if(s>70) return "call";
      return "fold";
    }
    const s = postStrength(S.hands[seat], S.board);
    if(s>16) return "bet_big";
    if(s>12) return "bet_med";
    if(s>8)  return "bet_small";
    return "check";
  }

  /* EV penalties -> score (simplified) */
  function evPenalty(street, heroActionKey, optimalKey){
    if(heroActionKey===optimalKey) return 0;
    const fam = a => a.includes("raise")?"Raise" : a.includes("bet")?"Bet" : (a[0].toUpperCase()+a.slice(1));
    const baseW = {
      preflop:{Fold:.9, Call:.55, Raise:.65, "All-in":1.25},
      flop:{Check:.22, Bet:.38, "All-in":.75},
      turn:{Check:.27, Bet:.5, "All-in":.9},
      river:{Check:.33, Bet:.62, "All-in":1.05}
    };
    let w = (baseW[street][fam(heroActionKey)] ?? .5);
    const strength = street==="preflop" ? pfStrength(S.hands[S.hero]) : postStrength(S.hands[S.hero], S.board);

    if(street==="preflop"){
      if(heroActionKey==="allin"){
        if(strength<78) w += 1.2;
        else if(strength<86) w += .7;
        else if(strength<92) w += .35;
        else w += .1;
      }
      if(heroActionKey==="fold" && strength<66) return 0; // junk fold perfect
    } else {
      if(heroActionKey==="allin" && strength<14) w += .8;
      if(fam(heroActionKey)==="Bet" && strength<8) w += .4;
    }
    if(fam(heroActionKey)!==fam(optimalKey)) w += .25;
    w += rand()*0.12;
    return +w.toFixed(2);
  }
  function scoreFromEV(totalEV){
    return Math.max(0, Math.min(100, Math.round(100 - totalEV*25)));
  }

  /* Min-raise logic helpers (CB/LRS) */
  const BB = 1.0, SB = 0.5;
  function toCall(pos){ return Math.max(0, S.currentBet - S.committed[pos]); }
  function minRaiseTo(){ // total to raise TO (not the add)
    const lrs = S.lastRaise || BB; // first raise uses BB
    return +(S.currentBet + lrs).toFixed(1);
  }
  function canRaise(pos){
    if(S.allin[pos] || !S.active[pos]) return false;
    const need = toCall(pos);
    const minTo = minRaiseTo();
    const maxTo = +(S.committed[pos]+S.stack[pos]).toFixed(1);
    return maxTo > Math.max(S.currentBet, minTo);
  }
  function payTo(pos, toTotal){
    const need = Math.max(0, toTotal - S.committed[pos]);
    const can  = S.stack[pos];
    const paid = Math.min(need, can);
    S.stack[pos] = +(S.stack[pos]-paid).toFixed(1);
    S.committed[pos] = +(S.committed[pos]+paid).toFixed(1);
    S.pot = +(S.pot + paid).toFixed(1);
    if(S.stack[pos]<=0){ S.stack[pos]=0; S.allin[pos]=true; }
    updateStacksUI(); updateHUD();
    return paid;
  }
  function equalizedBets(){
    const live = S.seats.filter(p=>S.active[p]);
    return live.every(p => S.committed[p] === S.currentBet || S.allin[p]);
  }

  /* Order of action per street */
  function orderPreflop(){ return POS_9.slice(0,7).concat(["SB","BB"]).filter(p=>S.seats.includes(p)); } // UTG→…→BB
  function orderPostflop(){
    // first active to left of BTN; but practically SB begins if present and active, else next
    const idx = S.seats.indexOf("SB");
    const arr = [];
    for(let i=0;i<S.seats.length;i++){
      const j = (idx + i) % S.seats.length;
      arr.push(S.seats[j]);
    }
    return arr;
  }
  /* ===== Offer hero actions (contextual) ===== */
  function clearActions(){ actionsEl.innerHTML=""; }
  function btn(label, cls, cb, disabled=false){
    const b=document.createElement("button");
    b.className=`btn ${cls}`; b.textContent=label; b.onclick = cb; b.disabled = !!disabled;
    actionsEl.appendChild(b); return b;
  }

  function offerHero(){
    clearActions();
    if(!S.active[S.hero]) return; // hero folded already
    const need = toCall(S.hero);
    const eff  = S.stack[S.hero];
    // Fold is ALWAYS available
    btn("Fold","ghost", ()=>heroAct("fold"));

    if(S.street!=="preflop" && need===0) btn("Check","ghost", ()=>heroAct("check"));

    if(need>0){
      btn(`Call ${Math.min(need, eff).toFixed(1)} BB`,"primary", ()=>heroAct("call"));
    }

    // Raise / Bet options obey min-raise rule
    if(canRaise(S.hero)){
      const minTo = Math.max(S.currentBet, minRaiseTo());
      const pot = Math.max(2, S.pot);
      const candidates = S.street==="preflop"
        ? [minTo, +(minTo+2).toFixed(1), +(minTo+4).toFixed(1)]
        : [Math.round(pot*0.33), Math.round(pot*0.5), Math.round(pot*0.66)]
            .map(v => Math.max(minTo, v));
      const maxTo = +(S.committed[S.hero]+eff).toFixed(1);

      candidates.forEach(to=>{
        const capped = Math.min(to, maxTo);
        const jam = capped >= maxTo - 1e-9;
        const label = (S.street==="preflop" ? "Raise to " : (toCall(S.hero)>0 ? "Raise to " : "Bet ")) + (jam?"All-in":`${capped.toFixed(1)} BB`);
        btn(label, jam?"danger":"primary", ()=> heroAct(jam ? "allin" : `raise_to:${capped}`));
      });
      if(eff>0) btn("All-in","danger", ()=>heroAct("allin"));
    } else if(need===0 && eff>0) {
      // allow jam even if not a proper raise (edge)
      btn("All-in","danger", ()=>heroAct("allin"));
    }
  }

  /* ===== Announce & chip plate ===== */
  function announce(pos, text){ chipPlate(pos, text); }

  /* ===== Villain decisions ===== */
  async function villainPreflop(pos){
    if(!S.active[pos] || pos===S.hero) return;
    setActing(pos,true);
    await sleep(400 + Math.floor(rand()*500));
    const need = toCall(pos);
    const pol = policyKey("preflop", pos);

    if(need===0){
      if(pol.startsWith("raise") && canRaise(pos) && rand()<0.45){
        const minTo = minRaiseTo();
        const target = pol==="raise_big" ? Math.max(minTo, 3.0) : Math.max(minTo, 2.5);
        const to = Math.min(S.committed[pos]+S.stack[pos], +target.toFixed(1));
        const prev = S.currentBet;
        S.currentBet = to;
        if(prev>0) S.lastRaise = +(S.currentBet - prev).toFixed(1); else S.lastRaise = BB;
        const paid = payTo(pos, S.currentBet);
        announce(pos, prev===0?`Open ${paid.toFixed(1)} BB`:`Raise ${(S.currentBet - prev).toFixed(1)} BB`);
      } else {
        announce(pos,"Check");
      }
      setActing(pos,false); return;
    }

    // facing a bet
    if(pol==="fold" && rand()<0.72){
      S.active[pos]=false; labelFold(pos); announce(pos,"Fold");
      setActing(pos,false); return;
    }

    if((pol==="raise_big" || pol==="raise_med") && canRaise(pos) && rand()<0.55){
      const minTo = minRaiseTo();
      const mult = pol==="raise_big" ? 2.6 : 2.1;
      const to = Math.min(S.committed[pos]+S.stack[pos], +(Math.max(minTo, S.currentBet*mult)).toFixed(1));
      const prev = S.currentBet;
      S.currentBet = to;
      S.lastRaise = +(S.currentBet - prev).toFixed(1);
      payTo(pos, S.currentBet);
      announce(pos, `Raise ${(S.currentBet - prev).toFixed(1)} BB`);
      setActing(pos,false); return;
    }

    // call as default
    const paid = payTo(pos, S.currentBet);
    announce(pos, paid >= S.stack[pos]+paid-1e-9 ? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
    setActing(pos,false);
  }

  async function villainPostflop(pos){
    if(!S.active[pos] || pos===S.hero) return;
    setActing(pos,true);
    await sleep(420 + Math.floor(rand()*520));
    const need = toCall(pos);
    const pol = policyKey(S.street, pos);

    if(need===0){
      // decide check or bet
      if(pol.startsWith("bet") && canRaise(pos) && rand()<0.35){
        const p = Math.max(2, S.pot);
        const add = pol==="bet_big" ? Math.round(p*0.66) : pol==="bet_med" ? Math.round(p*0.5) : Math.round(p*0.33);
        const minTo = Math.max(S.currentBet, minRaiseTo()); // for first bet, minRaiseTo() uses BB
        let to = Math.max(minTo, add);
        const maxTo = +(S.committed[pos]+S.stack[pos]).toFixed(1);
        to = Math.min(to, maxTo);
        const prev = S.currentBet;
        S.currentBet = to;
        S.lastRaise = prev>0 ? +(S.currentBet - prev).toFixed(1) : BB;
        payTo(pos, S.currentBet);
        announce(pos, prev===0?`Bet ${to.toFixed(1)} BB`:`Raise ${(S.currentBet - prev).toFixed(1)} BB`);
      } else {
        announce(pos, "Check");
      }
      setActing(pos,false); return;
    }

    // facing bet
    if(pol==="check" && rand()<0.30){
      S.active[pos]=false; labelFold(pos); announce(pos,"Fold");
      setActing(pos,false); return;
    }

    if(pol.startsWith("bet") && canRaise(pos) && rand()<0.28){
      const add = pol==="bet_big" ? Math.round(S.pot*0.66) : pol==="bet_med" ? Math.round(S.pot*0.5) : Math.round(S.pot*0.33);
      const minTo = minRaiseTo();
      let to = Math.max(minTo, S.currentBet + add);
      const maxTo = +(S.committed[pos]+S.stack[pos]).toFixed(1);
      to = Math.min(to, maxTo);
      const prev = S.currentBet;
      S.currentBet = to;
      S.lastRaise = +(S.currentBet - prev).toFixed(1);
      payTo(pos, S.currentBet);
      announce(pos, `Raise ${(S.currentBet - prev).toFixed(1)} BB`);
      setActing(pos,false); return;
    }

    // call default
    const paid = payTo(pos, S.currentBet);
    announce(pos, paid >= S.stack[pos]+paid-1e-9 ? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
    setActing(pos,false);
  }

  /* ===== Hero actions ===== */
  let heroEV = 0;
  function heroAct(action){
    if(!S.active[S.hero]) return;
    const optimal = policyKey(S.street, S.hero);
    const alias = action.startsWith("raise_to:")||action.startsWith("bet:")
      ? (S.street==="preflop" ? "raise_med" : "bet_med")
      : action;
    heroEV += evPenalty(S.street, alias, optimal);

    if(action==="fold"){
      S.active[S.hero] = false; labelFold(S.hero); announce(S.hero,"Fold");
      // Hand ends immediately with GTO score (hero is done)
      return finishHand();
    }
    if(action==="check"){
      announce(S.hero,"Check");
      // continue round
      return afterHeroAct();
    }
    if(action==="call"){
      const paid = payTo(S.hero, S.currentBet);
      announce(S.hero, paid >= S.stack[S.hero]+paid-1e-9 ? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
      if(S.allin[S.hero]) return runoutToSequence();
      return afterHeroAct();
    }
    if(action.startsWith("raise_to:")){
      const to = parseFloat(action.split(":")[1]);
      // enforce min-raise
      const minTo = minRaiseTo();
      const capped = Math.max(S.currentBet, Math.min(to, S.committed[S.hero]+S.stack[S.hero]));
      const finalTo = Math.max(minTo, capped);
      const prev = S.currentBet;
      S.currentBet = finalTo;
      S.lastRaise = +(S.currentBet - prev).toFixed(1);
      payTo(S.hero, S.currentBet);
      announce(S.hero, prev===0?`Bet ${finalTo.toFixed(1)} BB`:`Raise ${(S.currentBet - prev).toFixed(1)} BB`);
      if(S.allin[S.hero]) return runoutToSequence();
      return afterHeroAct();
    }
    if(action==="allin"){
      const to = +(S.committed[S.hero]+S.stack[S.hero]).toFixed(1);
      const prev = S.currentBet;
      S.currentBet = Math.max(S.currentBet, to);
      if(prev>0) S.lastRaise = +(S.currentBet - prev).toFixed(1); else S.lastRaise = BB;
      payTo(S.hero, S.currentBet);
      announce(S.hero, "All-in");
      return runoutToSequence();
    }
  }

  /* After hero acts: remaining table finishes the street */
  async function afterHeroAct(){
    const order = (S.street==="preflop") ? orderPreflop() : orderPostflop();
    const startIdx = order.indexOf(S.hero)+1;
    for(let i=startIdx;i<order.length;i++){
      const pos = order[i];
      if(!S.active[pos]) continue;
      if(S.street==="preflop"){ await villainPreflop(pos); }
      else { await villainPostflop(pos); }
    }
    // Now, go back to earlier positions if not equalized (including UTG..hero-1)
    while(!equalizedBets()){
      for(const pos of order){
        if(!S.active[pos] || S.allin[pos]) continue;
        const need = toCall(pos);
        if(need>0){
          // default caller if not hero
          if(pos===S.hero) { offerHero(); return; }
          // villains call or fold minimally
          if(rand()<0.15){ S.active[pos]=false; labelFold(pos); announce(pos,"Fold"); }
          else {
            const paid = payTo(pos, S.currentBet);
            announce(pos, paid >= S.stack[pos]+paid-1e-9 ? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
          }
        }
      }
    }
    // betting round ended
    await nextStreetOrFinish();
  }

  /* Streets */
  function burnAndDeal(deck, count){
    // (Burn ignored visually but consumed)
    deck.pop();
    const d = dealFrom(deck, count);
    S.board.push(...d);
    renderBoard();
  }

  async function nextStreetOrFinish(){
    if(S.sequence==="preflop" && S.street==="preflop") return finishHand();

    if(S.street==="preflop"){ S.street="flop"; resetStreetAccounting(); clearChipsForStreet(); burnAndDeal(S._deck,3); }
    else if(S.street==="flop"){
      if(S.sequence==="turn") return finishHand();
      S.street="turn"; resetStreetAccounting(); clearChipsForStreet(); burnAndDeal(S._deck,1);
    }
    else if(S.street==="turn"){
      S.street="river"; resetStreetAccounting(); clearChipsForStreet(); burnAndDeal(S._deck,1);
    } else {
      return finishHand();
    }

    updateHUD();
    // Postflop street starts with first active left of BTN => SB normally
    // But hero must act when action reaches them. We'll cycle to villain actions until hero turn.
    await openStreetFlow();
  }

  async function openStreetFlow(){
    // If hero folded already and sequence says continue? We stop immediately by spec.
    if(!S.active[S.hero]) return finishHand();

    const order = orderPostflop();
    for(const pos of order){
      if(!S.active[pos]) continue;
      if(pos===S.hero){ offerHero(); return; }
      await villainPostflop(pos);
      if(!S.active[S.hero]) return finishHand();
      if(!S.active[pos]) continue;
      if(!equalizedBets()){
        // Others still owe; loop will continue in afterHeroAct once hero responds if needed
        continue;
      }
    }
    // Everyone checked? Move next
    if(equalizedBets()) await nextStreetOrFinish();
  }

  async function runoutToSequence(){
    // Hero all-in or hero called and got all-in: run remaining streets up to sequence end, then finish
    while(true){
      if(S.sequence==="preflop" && S.street==="preflop") break;
      if(S.street==="preflop"){ S.street="flop"; resetStreetAccounting(); clearChipsForStreet(); burnAndDeal(S._deck,3); updateHUD(); }
      else if(S.street==="flop"){
        if(S.sequence==="turn") break;
        S.street="turn"; resetStreetAccounting(); clearChipsForStreet(); burnAndDeal(S._deck,1); updateHUD();
      }
      else if(S.street==="turn"){ S.street="river"; resetStreetAccounting(); clearChipsForStreet(); burnAndDeal(S._deck,1); updateHUD(); }
      else break;
      await sleep(300);
    }
    finishHand();
  }

  /* Showdown reveal — only hero + villains who saw showdown vs hero */
  function showdownReveal(){
    // showdown against hero: anyone still active (not folded) reaches showdown with hero
    if(!S.active[S.hero]) return; // hero folded → no villain reveal
    const vs = S.seats.filter(p => p!==S.hero && S.active[p]);
    S.showdownSet = new Set(vs);
    revealSeatCards(S.hero);
    vs.forEach(p => revealSeatCards(p));
  }
  function revealSeatCards(pos){
    const n = S.nodes[pos]; if(!n) return;
    const holder = document.createElement("div");
    holder.style.position="absolute";
    holder.style.left=n.seat.style.left;
    holder.style.top=(parseFloat(n.seat.style.top)-110)+"px";
    holder.style.transform="translate(-50%,-50%)";
    holder.style.display="flex";
    holder.style.gap="6px";
    holder.style.zIndex="95";
    (S.hands[pos]||[]).forEach(c=>{
      const el = document.createElement("div");
      el.className = "card";
      el.style.width="68px"; el.style.height="98px";
      el.innerHTML = `<div class="rank ${SUITCLASS(c[1])}">${c[0]}</div><div class="suit ${SUITCLASS(c[1])}">${c[1]}</div>`;
      holder.appendChild(el);
    });
    floatLayer.appendChild(holder);
  }

  /* Finish & score */
  function finishHand(){
    // If river reached with >=2 active → showdown
    if(S.street==="river" && S.seats.filter(p=>S.active[p]).length>=2){
      showdownReveal();
    }
    const pct = computeHeroScore();
    resultScoreEl.textContent = `${pct}%`;
    resultScoreEl.classList.toggle("good", pct>=50);
    resultScoreEl.classList.toggle("bad", pct<50);
    resultVerdEl.textContent = pct>=85?"Excellent":pct>=70?"Strong":pct>=50?"Okay":"Needs Work";
    resultEl.style.display = "block";

    // Replace actions with Next Hand
    clearActions();
    btn("Next Hand","primary", startNewHand);
  }

  function computeHeroScore(){
    // If hero folded preflop with junk → 100
    if(S.street!=="preflop" && !S.active[S.hero]){
      // folded on flop/turn/river: score by accumulated EV
      return scoreFromEV(heroEV);
    }
    if(S.street==="preflop" && !S.active[S.hero]){
      const s = pfStrength(S.hands[S.hero]);
      return (s<66) ? 100 : scoreFromEV(heroEV+0.6);
    }
    // Otherwise use EV-based score
    return scoreFromEV(heroEV);
  }

  /* Posting blinds and initialize preflop */
  function postBlinds(){
    resetStreetAccounting();
    S.pot = 0;
    // Small blind
    if(S.seats.includes("SB")){
      S.currentBet = Math.max(S.currentBet, SB);
      payTo("SB", SB);
      chipPlate("SB", "SB 0.5 BB");
    }
    // Big blind
    if(S.seats.includes("BB")){
      S.currentBet = Math.max(S.currentBet, BB);
      payTo("BB", BB);
      chipPlate("BB", "BB 1.0 BB");
    }
    S.lastRaise = BB; // first raise size basis
  }

  /* Start a new hand (full reset) */
  async function startNewHand(){
    // Clear UI pieces
    resultEl.style.display="none";
    floatLayer.innerHTML="";
    clearBoard();
    clearActions();
    S.chipsOnTable = [];
    heroEV = 0;

    // Read controls
    S.players = parseInt(numPlayersSel.value, 10);
    S.seats = LAYOUTS[S.players].slice();
    S.stackBB = Math.max(10, Math.min(400, +stackBBSel.value||100));
    S.sequence = sequenceSel.value;

    // Scenario seating/filter
    applyScenario(scenarioSel.value);

    // Hero selection menu fill/update
    heroSel.innerHTML = S.seats.map(p=>`<option ${p===S.hero?'selected':''}>${p}</option>`).join("");
    if(!S.seats.includes(S.hero)) S.hero = S.seats.includes("BTN") ? "BTN" : S.seats[0];
    heroSel.value = S.hero;

    // Initialize stacks/flags
    S.active = {}; S.allin={}; S.stack={}; S.hands={}; S.board=[];
    S.seats.forEach(p => { S.active[p]=true; S.allin[p]=false; S.stack[p]=S.stackBB; });
    layoutSeats(); updateStacksUI();

    // Create and deal
    srand(Date.now() ^ (Math.random()*0xffffffff)|0);
    S._deck = shuffleDeck();
    S.seats.forEach(p => S.hands[p] = dealFrom(S._deck,2));
    placeHeroCards();

    // Preflop setup
    S.street="preflop"; updateHUD();
    postBlinds();

    // Action order preflop: UTG to BB
    const order = orderPreflop();
    // Villains before hero act first
    for(const pos of order){
      if(pos===S.hero) break;
      await villainPreflop(pos);
    }
    // Hero turn
    offerHero();
  }

  function applyScenario(key){
    // reset to base seats
    S.seats = LAYOUTS[S.players].slice();

    if(key==="none"){
      // no modifications
      return;
    }
    if(key==="standard"){
      // full ring untouched (just ensure hero is BTN if present)
      return;
    }
    if(key==="bvb"){
      S.seats = ["SB","BB"];
      S.hero = "BB"; // Hero in BB
      return;
    }
    if(key==="btnvbb"){
      S.seats = ["BTN","SB","BB"];
      S.hero = "BTN";
      return;
    }
    if(key==="covbb"){
      S.seats = ["CO","BTN","SB","BB"];
      S.hero = "CO";
      return;
    }
    if(key==="utgvbb"){
      S.seats = ["UTG","HJ","CO","BTN","SB","BB"];
      S.hero = "UTG";
      return;
    }
    if(key==="hjvbb"){
      S.seats = ["HJ","CO","BTN","SB","BB"];
      S.hero = "HJ";
      return;
    }
    if(key==="ljvbb"){
      S.seats = ["LJ","HJ","CO","BTN","SB","BB"];
      S.hero = "LJ";
      return;
    }
  }

  /* Utilities */
  const sleep = ms => new Promise(r=>setTimeout(r,ms));

  /* Wiring */
  newHandBtn.onclick = startNewHand;
  heroSel.onchange = () => { S.hero = heroSel.value; setHeroGlow(); placeHeroCards(); };
  numPlayersSel.onchange = () => startNewHand();
  scenarioSel.onchange = () => startNewHand();
  sequenceSel.onchange = () => S.sequence = sequenceSel.value;

  // Auto-boot
  (async function boot(){
    await startNewHand();
  })();
  </script>
</body>
</html>










