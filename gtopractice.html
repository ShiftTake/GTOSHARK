<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GTO Shark • Live Practice</title>
<style>
:root{
  --felt0:#071a22;
  --felt1:#0b2a34;
  --felt2:#0e3b46;
  --felt3:#10545e;
  --indigo:#5e6bff;
  --teal:#18e1c8;
  --ink:#d8e7f7;
  --muted:#93a7ba;
  --good:#23e6a6;
  --bad:#ff5972;
  --ring: rgba(88,120,255,.35);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  color:var(--ink);
  background: radial-gradient(1200px 900px at 50% -10%, var(--felt3), var(--felt0) 60%);
}

/* Header */
header{
  display:flex;align-items:center;justify-content:space-between;
  gap:12px;padding:10px 14px;border-bottom:1px solid #16283a;
  background:linear-gradient(180deg, rgba(12,26,38,.8), rgba(7,18,28,.55));
  backdrop-filter: blur(6px);
}
.h-left{display:flex;align-items:center;gap:14px}
.brand{
  font-weight:900;letter-spacing:.2px;
  background: linear-gradient(90deg, #7db9ff, #22e2cb);
  -webkit-background-clip:text;background-clip:text;color:transparent;
  font-size:1.1rem;white-space:nowrap
}
.controls{display:flex;gap:8px;flex-wrap:wrap}
select,button{
  background:#0c2233;border:1px solid #24415d;color:#e7f3ff;
  border-radius:10px;padding:7px 10px;font-weight:600
}
button.primary{
  background: linear-gradient(135deg, #5a6bff, #1fe4ce);
  color:#06222a;border:none
}

/* Layout */
.app{
  display:grid;grid-template-columns:minmax(860px,1fr) 330px;gap:16px;
  padding:16px;max-width:1600px;margin:0 auto
}
@media (max-width:1200px){ .app{grid-template-columns:1fr} .side{order:3} }

/* Table */
.table-wrap{display:flex;justify-content:center;align-items:center}
#table{
  width:min(1100px,92vw);aspect-ratio:1/1;border-radius:50%;
  position:relative;overflow:visible;
  background: radial-gradient(ellipse at center, var(--felt3) 0%, var(--felt2) 36%, var(--felt1) 64%, var(--felt0) 100%);
  border:8px solid var(--ring);
  box-shadow: inset 0 0 110px rgba(30,200,220,.15), 0 0 55px rgba(0,0,0,.55);
}

/* Seats */
.seat{
  position:absolute;width:86px;height:86px;border-radius:50%;
  background:#0d2131;border:2px solid #2a4a6b;color:#a9c4da;text-shadow:0 1px 0 #000;
  display:flex;align-items:center;justify-content:center;font-weight:900;font-size:12px;text-transform:uppercase;
  box-shadow:0 6px 20px rgba(0,0,0,.4);transition:.25s
}
.seat.hero{border-color:#1fe4ce;color:#eaffff;box-shadow:0 0 24px rgba(28,230,210,.45)}
.seat.folded{filter: grayscale(.95) brightness(.8); border-color:#2a3947;color:#708599}

.stack{
  position:absolute;left:50%;top:calc(100% + 16px);transform:translateX(-50%);
  background:#0b1a2a;border:1px solid #2b4664;border-radius:999px;padding:2px 9px;font-size:12px;color:#d0e5ff
}

/* Plates (bet/call amounts) */
.plate{
  position:absolute;transform:translate(-50%,-18px);
  background:#0d2336;border:1px solid #366089;color:#e1f1ff;padding:4px 8px;border-radius:9px;font-size:12px;
  box-shadow:0 8px 16px rgba(0,0,0,.35)
}

/* Cards */
.card{width:74px;height:104px;border-radius:12px;background:#fff;border:1px solid #2a2a2a;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  box-shadow:0 8px 16px rgba(0,0,0,.35);font-weight:900}
.card .rank{font-size:32px;line-height:1}
.card .suit{font-size:22px;margin-top:-2px}
.red{color:#e13b50}.black{color:#121212}
.board{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:10px;z-index:4}
.hero-hand{position:absolute;display:flex;gap:8px;z-index:6; transform: translate(-50%, -50%)}
.hud{
  position:absolute;left:50%;top:56%;transform:translate(-50%,-50%);
  background:rgba(7,18,28,.55);border:1px solid #2a4562;color:#cfe9ff;border-radius:10px;
  padding:6px 12px;font-weight:800;letter-spacing:.2px
}

/* Action bar */
.action-bar{display:flex;justify-content:center;flex-wrap:wrap;gap:10px;margin-top:12px}
.btn{border:none;border-radius:10px;padding:12px 16px;font-weight:800;color:#fff;cursor:pointer}
.btn.fold{background:#233a52}
.btn.call{background:#16d8be;color:#052}
.btn.raise{background:#5168ff}
.btn.allin{background:#d84040}

/* Panels */
.panel{background:#0b1a2a;border:1px solid #293f57;border-radius:14px;padding:12px}
.side{display:flex;flex-direction:column;gap:14px}
.result{display:none}
.result .big{font-size:40px;font-weight:900}
.good{color:var(--good)} .bad{color:var(--bad)}
.smallmuted{color:var(--muted);font-size:12px}
.muted{color:var(--muted)}
</style>
</head>
<body>
<header>
  <div class="h-left">
    <div class="brand">GTO Shark • Live Practice</div>
    <div class="smallmuted">Cinematic indigo/teal felt • Mixed-freq villains • Hero-centric ending</div>
  </div>
  <div class="controls">
    <label class="smallmuted">Hero</label>
    <select id="heroSel"></select>
    <label class="smallmuted">Play through</label>
    <select id="seqSel">
      <option value="preflop">Preflop only</option>
      <option value="turn">Play to Turn</option>
      <option value="river" selected>Play to River</option>
    </select>
    <label class="smallmuted">Start</label>
    <select id="startSel">
      <option value="preflop" selected>Preflop</option>
      <option value="flop">Flop</option>
      <option value="turn">Turn</option>
      <option value="river">River</option>
    </select>
    <button id="newBtn" class="primary">New Hand</button>
  </div>
</header>

<div class="app">
  <main>
    <div class="table-wrap">
      <div id="table">
        <div id="board" class="board"></div>
        <div id="hud" class="hud">Pot: <span id="hudPot">0.0</span> • Street: <span id="hudStreet">Preflop</span></div>
      </div>
    </div>
    <div id="actionBar" class="action-bar"></div>
    <div id="prompt" class="muted" style="text-align:center;margin-top:6px">Loading…</div>
  </main>

  <aside class="side">
    <div id="result" class="panel result">
      <div class="big" id="scoreTxt">—</div>
      <div id="verdictTxt" class="muted"></div>
      <div class="smallmuted" style="margin-top:6px">Shown only when the hero’s sequence is complete.</div>
    </div>
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:900;color:#9ec5ff">Hand Log</div>
        <button id="clearLog" style="padding:6px 10px;border-radius:8px;border:1px solid #2a4562;background:#102235;color:#d6eaff">Clear</button>
      </div>
      <div class="smallmuted" style="margin:6px 0">✅ ≥ 50% • ❌ &lt; 50%</div>
      <div id="logList" style="display:flex;flex-direction:column;gap:8px"></div>
    </div>
  </aside>
</div>
<script>
/* ============ CONSTANTS / SEATS / DOM ============ */
const SEATS = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"]; // action order preflop
const POSTFLOP_STARTER = "SB"; // first active left of BTN
const ranks = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const suits = ["♠","♥","♦","♣"];

const table   = document.getElementById("table");
const boardEl = document.getElementById("board");
const hudPot  = document.getElementById("hudPot");
const hudStreet = document.getElementById("hudStreet");
const actionBar = document.getElementById("actionBar");
const promptEl  = document.getElementById("prompt");
const heroSel   = document.getElementById("heroSel");
const seqSel    = document.getElementById("seqSel");
const startSel  = document.getElementById("startSel");
const resultCard= document.getElementById("result");
const scoreTxt  = document.getElementById("scoreTxt");
const verdictTxt= document.getElementById("verdictTxt");
const logList   = document.getElementById("logList");

/* ============ STATE ============ */
const S = {
  hero: "BTN",
  playThrough: "river",
  startStreet: "preflop",

  // per hand
  street: "preflop",
  board: [],
  pot: 0,
  stacks: {},
  committed: {},
  lastRaise: 1,         // difference between currentBet and previous
  currentBet: 1,        // sum required to call
  acted: {},            // who has acted this street
  folded: {},
  allin: {},
  hands: {},
  dealer: "BTN",        // for postflop starter
  showdownSet: new Set(),
  heroEVLoss: 0,
  logSnap: null,        // snapshot for replay
};

/* ============ RNG + DEAL ============ */
const rnd = (n)=> Math.floor(Math.random()*n);
const randEl = (arr)=> arr[rnd(arr.length)];
function dealCard(taken){
  let c; do {
    c = randEl(ranks) + randEl(suits);
  } while(taken.has(c));
  taken.add(c);
  return c;
}
function dealN(n, taken){ const out=[]; for(let i=0;i<n;i++) out.push(dealCard(taken)); return out; }

/* ============ RENDER HELPERS ============ */
function seatNode(name){ return document.querySelector(`[data-seat="${name}"]`); }
function seatXY(name){
  const el = seatNode(name); return { left: el.style.left, top: el.style.top };
}
function money(x){ return `${(+x).toFixed(1)} BB`; }
function cardEl(cc, small=false){
  const r=cc[0], s=cc[1];
  const el=document.createElement("div");
  el.className="card "+((s==="♥"||s==="♦")?"red":"black");
  if(small){ el.style.width="66px"; el.style.height="92px"; }
  el.innerHTML=`<div class="rank">${r}</div><div class="suit">${s}</div>`;
  return el;
}

/* ============ LAYOUT SEATS ============ */
function layoutSeats(){
  // clear seats/plates/hands
  [...table.querySelectorAll(".seat,.plate,.hero-hand")].forEach(n=>n.remove());

  const R = table.clientWidth*0.42;
  const C = table.clientWidth/2;
  SEATS.forEach((name,i)=>{
    const ang = (Math.PI*2*i/SEATS.length) - Math.PI/2; // 12 o'clock start
    const x = C + R*Math.cos(ang);
    const y = C + R*Math.sin(ang);
    const seat = document.createElement("div");
    seat.className = "seat"+(name===S.hero?" hero":"");
    seat.dataset.seat = name;
    seat.style.left = `${x}px`; seat.style.top = `${y}px`;
    seat.textContent = name;
    const stk = document.createElement("div"); stk.className="stack"; stk.dataset.stack=name;
    stk.textContent = money(S.stacks?.[name] ?? 100);
    seat.appendChild(stk);
    table.appendChild(seat);
  });
}

/* ============ HUD / BOARD / HERO CARDS ============ */
function renderHUD(){ hudPot.textContent = S.pot.toFixed(1); hudStreet.textContent = S.street[0].toUpperCase()+S.street.slice(1); }
function renderBoard(){
  boardEl.innerHTML=""; S.board.forEach(c=> boardEl.appendChild(cardEl(c,true)));
}
function renderHeroCards(){
  // remove prior
  [...table.querySelectorAll(".hero-hand")].forEach(n=>n.remove());
  const node = seatNode(S.hero); if(!node) return;
  const holder = document.createElement("div");
  holder.className="hero-hand";
  holder.style.left = node.style.left;
  holder.style.top  = (parseFloat(node.style.top) + 88) + "px";
  S.hands[S.hero].forEach(c=> holder.appendChild(cardEl(c,false)));
  table.appendChild(holder);
}

/* ============ PLATES / STACKS UI ============ */
const streetPlates = new Map(); // seat -> plate node
function setPlate(seat, label){
  const node = seatNode(seat); if(!node) return;
  if(streetPlates.has(seat)) streetPlates.get(seat).remove();
  const p = document.createElement("div"); p.className="plate";
  p.style.left = node.style.left; p.style.top = (parseFloat(node.style.top) - 32) + "px";
  p.textContent = label; table.appendChild(p); streetPlates.set(seat,p);
}
function clearPlates(){ streetPlates.forEach(n=>n.remove()); streetPlates.clear(); }
function setFolded(seat, on=true){ seatNode(seat)?.classList.toggle("folded", on); }
function updateStacksUI(){ SEATS.forEach(s=>{ const el=document.querySelector(`.stack[data-stack="${s}"]`); if(el) el.textContent = money(S.stacks[s]); }); }

/* ============ PROMPT + ACTIONS ============ */
function prompt(txt){ promptEl.textContent = txt; }
function clearActions(){ actionBar.innerHTML=""; }
function addBtn(label, cls, cb, disabled=false){
  const b=document.createElement("button"); b.className=`btn ${cls}`; b.textContent=label; b.disabled=!!disabled;
  b.onclick=cb; actionBar.appendChild(b);
  return b;
}

/* ============ UTIL ACCOUNTING ============ */
function toCall(seat){ return Math.max(0, S.currentBet - S.committed[seat]); }
function payTo(seat, targetTo){
  const want = Math.max(0, targetTo - S.committed[seat]);
  const can = Math.max(0, S.stacks[seat]);
  const pay = Math.min(want, can);
  S.stacks[seat] -= pay;
  S.committed[seat] += pay;
  S.pot += pay;
  if(S.stacks[seat] <= 0){ S.stacks[seat]=0; S.allin[seat]=true; }
  updateStacksUI(); renderHUD();
  return pay;
}
function resetStreetAccounting(){
  S.currentBet = (S.street==="preflop") ? 1 : 0;  // BB posted in init
  S.lastRaise  = 1;
  S.acted = {};
  clearPlates();
}

/* ============ INIT NEW HAND ============ */
function initHand(){
  resultCard.style.display="none"; scoreTxt.textContent="—"; verdictTxt.textContent="";
  S.showdownSet = new Set();
  // seed stacks (100BB each fresh hand)
  S.stacks={}; S.committed={}; S.folded={}; S.allin={}; S.hands={};
  SEATS.forEach(s=>{ S.stacks[s]=100; S.committed[s]=0; S.folded[s]=false; S.allin[s]=false; });
  layoutSeats();

  // deal
  const taken=new Set();
  SEATS.forEach(s=> S.hands[s]=dealN(2, taken));

  // board by start
  S.board=[];
  if(S.startStreet==="flop") S.board = dealN(3, taken);
  if(S.startStreet==="turn") S.board = [...dealN(3, taken), ...dealN(1, taken)];
  if(S.startStreet==="river") S.board = [...dealN(3, taken), ...dealN(2, taken)];
  renderBoard();

  // pot + blinds
  S.pot=0;
  if(S.startStreet!=="preflop"){ // start later -> no blinds logic; treat like clean postflop street
    S.currentBet=0; S.lastRaise=0;
  } else {
    // post blinds
    S.committed["SB"]=0.5; S.stacks["SB"]-=0.5; S.pot+=0.5;
    S.committed["BB"]=1.0; S.stacks["BB"]-=1.0; S.pot+=1.0;
    S.currentBet=1; S.lastRaise=1;
  }

  renderHUD(); updateStacksUI(); renderHeroCards();
  S.street = S.startStreet;
  hudStreet.textContent = S.street[0].toUpperCase()+S.street.slice(1);
  // clear plates (fresh street) but show blind plates if preflop
  clearPlates();
  if(S.startStreet==="preflop"){ setPlate("SB","SB 0.5"); setPlate("BB","BB 1.0"); }

  // street actors reset
  S.acted={}; SEATS.forEach(s=>S.acted[s]=false);

  // kick off action up to hero seat (others act first where appropriate)
  scheduleToHeroStart().then(()=> offerHero());
}

/* Move action before the hero if others must act first given start and order */
async function scheduleToHeroStart(){
  // preflop order: UTG -> ... -> BTN -> SB -> BB
  // postflop order: starts at SB (if still in), then BB, UTG, ..., BTN
  const order = actionOrderForStreet(S.street);
  // act until hero turn (stop just before hero)
  for(const seat of order){
    if(seat===S.hero) break;
    if(S.folded[seat]) continue;
    await villainAct(seat);
    if(endEarlyBecauseStreetFinished()) break;
  }
}

/* Who acts first/next for current street */
function actionOrderForStreet(street){
  const pre = SEATS.slice(); // UTG..BB
  if(street==="preflop") return pre;
  // postflop start left of BTN -> SB then BB then UTG..BTN
  const idx = SEATS.indexOf("SB");
  return [...SEATS.slice(idx), ...SEATS.slice(0,idx)];
}
/* ============ STRENGTH & GTO-ish POLICY ============ */
function pfStrength(cards){
  const [a,b]=cards; const r1=ranks.indexOf(a[0]), r2=ranks.indexOf(b[0]);
  const pair=a[0]===b[0], suited=a[1]===b[1], gap=Math.abs(r1-r2);
  let s = pair ? (100 - r1*3) : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?6:0);
  return s + Math.random()*2;
}
function postStrength(cards, board){
  const ranksOnBoard = board.map(c=>c[0]);
  const hi = ranksOnBoard.some(r=>["A","K","Q","J","T"].includes(r)) ? 6 : 0;
  const pair = ranksOnBoard.includes(cards[0][0]) || ranksOnBoard.includes(cards[1][0]) ? 8 : 0;
  const suit = cards[0][1]===cards[1][1] ? 3 : 0;
  return hi+pair+suit + Math.random()*2;
}
/* Decide a policy key for a seat on a street */
function policyKey(street, seat){
  if(S.folded[seat]) return "fold";
  const s = (street==="preflop") ? pfStrength(S.hands[seat]) : postStrength(S.hands[seat], S.board);
  const need = toCall(seat);
  if(street==="preflop"){
    if(need===0){
      if(s>90 && Math.random()<0.65) return "raise_big";
      if(s>80 && Math.random()<0.55) return "raise_med";
      if(s>70) return "call";
      return "check"; // allowed in BB only actually; others will be folded earlier by schedule
    } else {
      if(s>88 && Math.random()<0.6) return "raise_big";
      if(s>78 && Math.random()<0.5) return "raise_med";
      if(s>66 || Math.random()<0.55) return "call";
      return "fold";
    }
  } else {
    if(need>0){
      if(s>15 && Math.random()<0.3) return "raise";
      if(s>7 || Math.random()<0.7) return "call";
      return "fold";
    } else { // facing no bet
      if(s>16 && Math.random()<0.35) return "bet_big";
      if(s>12 && Math.random()<0.45) return "bet_med";
      if(s>8  && Math.random()<0.5)  return "bet_small";
      return "check";
    }
  }
}

/* ============ HERO SCORING (simplified EV penalties) ============ */
function actionFamily(k){
  if(k.startsWith("raise")||k.startsWith("bet")) return "Bet";
  if(k==="allin") return "All-in";
  if(k==="call") return "Call";
  if(k==="check") return "Check";
  if(k==="fold") return "Fold";
  return k;
}
function optimalAlias(street, seat){
  return policyKey(street, seat);
}
function evPenalty(street, seat, heroKey){
  const opt = optimalAlias(street, seat);
  if(heroKey===opt) return 0;

  // Preflop: Allow 100% score for junk folds
  if(street==="preflop" && heroKey==="fold" && pfStrength(S.hands[seat])<66) return 0;

  const famH = actionFamily(heroKey), famO = actionFamily(opt);
  const weight = (fam)=>{
    if(street==="preflop") return {Fold:.9, Check:.2, Call:.55, Bet:.65, "All-in":1.2}[fam] ?? .6;
    if(street==="flop")   return {Fold:.8, Check:.2, Call:.4,  Bet:.5,  "All-in":.9}[fam] ?? .5;
    if(street==="turn")   return {Fold:.9, Check:.25,Call:.45, Bet:.55, "All-in":1.0}[fam] ?? .55;
    return                   {Fold:1.0,Check:.33,Call:.6,  Bet:.7,  "All-in":1.1}[fam] ?? .6;
  };
  let w = weight(famH);
  if(famH!==famO) w += .25;
  return +(w + Math.random()*.12).toFixed(2);
}
function gtoPercent(){ return Math.max(0, Math.min(100, Math.round(100 - S.heroEVLoss*25))); }

/* ============ ACTING ENGINE ============ */
async function villainAct(seat){
  if(S.folded[seat] || S.allin[seat]) return;
  const need = toCall(seat);
  const key = policyKey(S.street, seat);

  if(S.street==="preflop"){
    if(key==="fold" && need>0){ S.folded[seat]=true; setFolded(seat,true); setPlate(seat,"Fold"); return; }
    if(key==="check" && need===0){ setPlate(seat,"Check"); return; } // BB only
    if(key==="call" || (key==="fold" && need===0)){ // just call when no fold pressure
      const paid = payTo(seat, S.currentBet);
      setPlate(seat, paid>=S.stacks[seat]+paid ? "Call all-in" : `Call ${money(paid)}`);
      return;
    }
    if(key==="raise_big" || key==="raise_med"){
      const minTo = Math.max(S.currentBet + S.lastRaise, 2); // at least a min-raise
      const mult  = key==="raise_big" ? 3.2 : 2.2;
      const to    = Math.max(minTo, Math.round(mult*1)); // base on BB
      const capTo = S.committed[seat] + S.stacks[seat];  // jam ceiling
      const target= Math.min(to, capTo);
      S.lastRaise = target - S.currentBet;
      S.currentBet= target;
      const paid = payTo(seat, S.currentBet);
      setPlate(seat, (paid>=S.stacks[seat]+paid) ? "All-in" : `Raise to ${money(S.currentBet)}`);
      return;
    }
  } else {
    // Postflop
    if(need>0){
      if(key==="fold"){ S.folded[seat]=true; setFolded(seat,true); setPlate(seat,"Fold"); return; }
      if(key==="raise"){
        const minTo = Math.max(S.currentBet + S.lastRaise, S.currentBet + Math.max(2, Math.round(S.pot*0.33)));
        const capTo = S.committed[seat] + S.stacks[seat];
        const target = Math.min(minTo, capTo);
        S.lastRaise = target - S.currentBet;
        S.currentBet = target;
        const paid = payTo(seat, S.currentBet);
        setPlate(seat, paid>=S.stacks[seat]+paid ? "Jam" : `Raise to ${money(S.currentBet)}`);
        return;
      }
      // call path
      const paid = payTo(seat, S.currentBet);
      setPlate(seat, paid>=S.stacks[seat]+paid ? "Call all-in" : `Call ${money(paid)}`);
      return;
    } else {
      if(key.startsWith("bet")){
        const size = key==="bet_big" ? Math.max(3, Math.round(S.pot*0.75))
                    : key==="bet_med" ? Math.max(2, Math.round(S.pot*0.5))
                    : Math.max(2, Math.round(S.pot*0.33));
        const to   = S.committed[seat] + Math.min(size, S.stacks[seat]);
        // first bet sets currentBet relative to others’ committed (0)
        S.lastRaise = Math.max(size, 2);
        S.currentBet = to;
        const paid = payTo(seat, S.currentBet);
        setPlate(seat, paid>=S.stacks[seat]+paid ? "All-in" : `Bet ${money(paid)}`);
        return;
      }
      setPlate(seat,"Check");
      return;
    }
  }
}

/* Offer hero actions (always includes Fold) */
function offerHero(){
  clearActions();
  const need = toCall(S.hero);
  const eff  = S.stacks[S.hero];
  addBtn("Fold","fold", ()=>heroAct("fold"));
  if(S.street!=="preflop" && need===0) addBtn("Check","fold", ()=>heroAct("check"));
  if(need>0) addBtn(`Call ${money(Math.min(need,eff))}`,"call", ()=>heroAct("call"));
  // Raise options
  const sizes = (S.street==="preflop")
    ? [Math.max(S.currentBet + S.lastRaise, 2), Math.max(S.currentBet + S.lastRaise + 1, 3)]
    : [Math.max(2, Math.round(S.pot*0.33)), Math.max(2, Math.round(S.pot*0.5)), Math.max(2, Math.round(S.pot*0.75))];
  sizes.forEach(sz=>{
    const target = (S.street==="preflop" && need>0)
      ? Math.max(S.currentBet + S.lastRaise, sz)          // ensure min-raise
      : (S.street==="preflop" && need===0) ? sz : S.currentBet + sz;
    const cap = S.committed[S.hero] + S.stacks[S.hero];
    const to  = Math.min(target, cap);
    const label = (to>=cap) ? "All-in" : (need>0 ? `Raise to ${money(to)}` : `Bet ${money(to - S.currentBet)}`);
    addBtn(label, (to>=cap)?"allin":"raise", ()=> heroAct((to>=cap)?"allin":((need>0)?`raise:${to}`:`bet:${to}`)));
  });
  if(eff>0) addBtn("All-in","allin", ()=>heroAct("allin"));
  prompt(`Your action as ${S.hero}.`);
}

async function heroAct(key){
  // Score EV penalty
  S.heroEVLoss += evPenalty(S.street, S.hero, key);

  const need = toCall(S.hero);
  if(key==="fold"){
    S.folded[S.hero]=true; setFolded(S.hero,true); setPlate(S.hero,"Fold");
    return heroSequenceDone(); // End hero sequence immediately
  }
  if(key==="check" && need===0){ setPlate(S.hero,"Check"); return heroAfterHeroActs(); }
  if(key==="call"){
    const paid = payTo(S.hero, S.currentBet);
    setPlate(S.hero, (paid>=S.stacks[S.hero]+paid)?"Call all-in":`Call ${money(paid)}`);
    if(S.allin[S.hero]) return heroSequenceDone();
    return heroAfterHeroActs();
  }
  if(key.startsWith("bet:") || key.startsWith("raise:") || key==="allin"){
    const capTo = S.committed[S.hero] + S.stacks[S.hero];
    const target = (key==="allin") ? capTo : parseFloat(key.split(":")[1]);
    const prev = S.currentBet;
    S.lastRaise = Math.max(target - S.currentBet, S.lastRaise);
    S.currentBet = Math.max(S.currentBet, target);
    const paid = payTo(S.hero, S.currentBet);
    const label = (paid>=S.stacks[S.hero]+paid) ? "All-in" : (prev===0? `Bet ${money(paid)}` : `Raise to ${money(S.currentBet)}`);
    setPlate(S.hero, label);
    if(S.allin[S.hero]) return heroSequenceDone();
    return heroAfterHeroActs();
  }
}

/* After hero acts, cycle other players for the rest of this street, then either next street or finish */
async function heroAfterHeroActs(){
  const order = actionOrderForStreet(S.street);
  // continue from player after hero, wrap around until everyone matched or folded
  let idx = order.indexOf(S.hero);
  for(let t=1;t<order.length;t++){
    const seat = order[(idx+t)%order.length];
    if(S.folded[seat] || S.allin[seat]) continue;
    const need = toCall(seat);
    // if no bet to call and everyone acted (no one raises), break
    await villainAct(seat);
  }
  // If any seat not equalized, let hero act again
  const needsMore = order.some(s=> !S.folded[s] && !S.allin[s] && toCall(s)>0 );
  if(needsMore){ offerHero(); return; }

  // Street ends -> next street unless hero's play-through was reached
  if( (S.playThrough==="preflop" && S.street==="preflop") ||
      (S.playThrough==="turn"    && S.street==="turn") ||
      (S.playThrough==="river"   && S.street==="river") ){
    return heroSequenceDone();
  }
  await nextStreet();
  // On next street: prior to hero’s turn, run villain openers up to hero then offer hero
  await scheduleToHeroStart();
  offerHero();
}

/* Early street end check during pre-hero scheduling */
function endEarlyBecauseStreetFinished(){
  const order = actionOrderForStreet(S.street);
  return order.every(s=> S.folded[s] || S.allin[s] || toCall(s)===0 );
}

/* ============ STREET TRANSITIONS ============ */
async function nextStreet(){
  // move all committed to pot already done; reset accounting
  S.street = (S.street==="preflop") ? "flop" : (S.street==="flop") ? "turn" : (S.street==="turn") ? "river" : "river";
  hudStreet.textContent = S.street[0].toUpperCase()+S.street.slice(1);
  // deal board
  const taken=new Set(SEATS.flatMap(s=>S.hands[s]).concat(S.board));
  if(S.street==="flop")  S.board = dealN(3,taken);
  if(S.street==="turn")  S.board = [...S.board, ...dealN(1,taken)];
  if(S.street==="river") S.board = [...S.board, ...dealN(1,taken)];
  renderBoard();
  // clear plates (fresh street), reset currentBet/lastRaise/acted
  resetStreetAccounting();
}

/* ============ HERO SEQUENCE END / SHOWDOWN / RESULT ============ */
function heroSequenceDone(){
  // Determine showdown set (villains that didn’t fold and were engaged)
  const liveVillains = SEATS.filter(s=> s!==S.hero && !S.folded[s]);
  S.showdownSet = new Set(liveVillains); // simple: reveal only those still in (not everyone)
  return finishHand();
}
function revealShowdown(){
  // Reveal hero + showdown villains
  // hero already visible
  S.showdownSet.forEach(seat=>{
    const node = seatNode(seat); if(!node) return;
    const holder=document.createElement("div");
    holder.className="hero-hand";
    holder.style.left=node.style.left;
    holder.style.top = (parseFloat(node.style.top)-92)+"px";
    S.hands[seat].forEach(c=> holder.appendChild(cardEl(c,true)));
    table.appendChild(holder);
  });
}
function finishHand(){
  clearActions();
  revealShowdown();
  const pct = gtoPercent();
  scoreTxt.textContent = pct+"%";
  scoreTxt.className = "big " + (pct>=50?"good":"bad");
  verdictTxt.textContent = pct>=85 ? "Excellent" : pct>=70 ? "Strong" : pct>=50 ? "Okay" : "Needs work";
  resultCard.style.display="block";

  // log
  const row=document.createElement("div");
  row.style.display="flex";row.style.justifyContent="space-between";row.style.alignItems="center";
  row.style.background="#0b1a2a";row.style.border="1px solid #293f57";row.style.borderRadius="10px";row.style.padding="8px 10px";
  row.innerHTML=`<div><b>${S.hero}</b> • ${S.playThrough.toUpperCase()} • ${S.startStreet.toUpperCase()}</div>
                 <div style="font-weight:900; ${pct>=50?'color:#23e6a6':'color:#ff5972'}">${pct}% ${pct>=50?'✅':'❌'}</div>`;
  logList.prepend(row);

  // next hand button
  addBtn("Next Hand","raise", startHandNow);
}

/* ============ PUBLIC CONTROLS / BOOT ============ */
function startHandNow(){
  // read selectors
  S.hero = heroSel.value;
  S.playThrough = seqSel.value;
  S.startStreet = startSel.value;
  initHand();
}

document.getElementById("newBtn").onclick = startHandNow;
document.getElementById("clearLog").onclick = ()=>{ logList.innerHTML=""; };

(function boot(){
  heroSel.innerHTML = SEATS.map(s=>`<option value="${s}">${s}</option>`).join("");
  heroSel.value = S.hero;
  startHandNow(); // immediate hand
  prompt("Preflop: your action below.");
})();
</script>
</body>
</html>















