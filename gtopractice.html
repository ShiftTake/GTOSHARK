  /* ---------- villain action engines with legal raise math ---------- */
  async function vPre(seat){
    if(S.folded[seat] || S.allin[seat]) return;
    setActing(seat,true); await sleep(700+Math.floor(sran()*450));

    const need = toCall(seat);
    const pol = policyKey("preflop", seat);

    // possible fold decision (only if facing bet)
    if(need>0 && pol==="fold" && sran()<0.75){
      S.folded[seat]=true; setFoldedVisual(seat); chipTag(seat,"Fold"); setActing(seat,false); return;
    }

    // raise (legal min raise)
    if((pol==="raise_big"||pol==="raise_med") && sran()<0.55){
      const mult = pol==="raise_big" ? 3.0 : 2.2;
      let target = Math.max(S.currentTo*mult, S.currentTo + S.lastRaise); // must be >= CB + LRS
      const maxTo = S.committed[seat] + S.stacks[seat]; // all-in cap
      if(target >= maxTo - 1e-9){ // jam
        S.currentTo = maxTo;
        S.lastRaise = Math.max(S.lastRaise, Math.max(1.0, maxTo - S.currentTo)); // irrelevant post-jam
        payTo(seat, S.currentTo); chipTag(seat,"All-in"); S.allin[seat]=true; setActing(seat,false); return;
      } else {
        const prev=S.currentTo;
        S.currentTo = +target.toFixed(1);
        S.lastRaise = Math.max(1.0, +(S.currentTo - prev).toFixed(1));
        payTo(seat, S.currentTo); chipTag(seat, `Raise ${(S.currentTo - S.committed[seat] + (S.committed[seat]-S.currentTo)).toFixed(1)} BB`); // visual text not too important
        S.interacted.add(seat);
        setActing(seat,false); return;
      }
    }

    // call or check
    if(need>0){
      const paid=payTo(seat,S.currentTo);
      chipTag(seat, paid >= S.stacks[seat]+paid ? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
      S.interacted.add(seat);
    } else {
      chipTag(seat,"Check");
    }
    setActing(seat,false);
  }

  async function vPost(seat){
    if(S.folded[seat] || S.allin[seat]) return;
    setActing(seat,true); await sleep(700+Math.floor(sran()*450));

    const need = toCall(seat);
    const pol  = policyKey(S.street, seat);

    if(need>0){
      // sometimes raise (legal min)
      if(pol.startsWith("bet") && sran()<0.25 && S.stacks[seat]>need){
        const raiseTo = Math.max(S.currentTo + Math.max(1.0, S.lastRaise), S.currentTo + Math.round(Math.max(2, S.pot*0.4)));
        const maxTo = S.committed[seat] + S.stacks[seat];
        if(raiseTo >= maxTo - 1e-9){
          S.currentTo = maxTo; payTo(seat,S.currentTo); chipTag(seat,"All-in"); S.allin[seat]=true; setActing(seat,false); return;
        } else {
          const prev=S.currentTo;
          S.currentTo=+raiseTo.toFixed(1);
          S.lastRaise=Math.max(1.0, +(S.currentTo-prev).toFixed(1));
          payTo(seat,S.currentTo); chipTag(seat,`Raise ${(S.currentTo-prev).toFixed(1)} BB`); S.interacted.add(seat); setActing(seat,false); return;
        }
      }
      // call or fold
      if(sran()<0.8 || S.stacks[seat]<=need){
        const paid=payTo(seat,S.currentTo); chipTag(seat, paid >= S.stacks[seat]+paid ? "Call all-in" : `Call ${paid.toFixed(1)} BB`); S.interacted.add(seat);
      } else {
        S.folded[seat]=true; setFoldedVisual(seat); chipTag(seat,"Fold");
      }
    } else {
      // open bet option
      if(pol.startsWith("bet") && sran()<0.35 && S.stacks[seat]>0){
        // open to a size (1/2 pot) minimum 1bb
        const open = Math.max(1.0, Math.round(Math.max(2, S.pot*0.5)));
        const maxTo = S.committed[seat] + S.stacks[seat];
        const to = Math.min(S.currentTo + open, maxTo);
        const prev=S.currentTo;
        S.currentTo = to;
        S.lastRaise = Math.max(1.0, +(S.currentTo-prev).toFixed(1));
        payTo(seat, S.currentTo); chipTag(seat, to>=maxTo? "All-in" : `Bet ${(S.currentTo-prev).toFixed(1)} BB`); S.interacted.add(seat);
      } else {
        chipTag(seat,"Check");
      }
    }
    setActing(seat,false);
  }

  /* ---------- hero actions & buttons ---------- */
  function clearActions(){ actionsEl.innerHTML=""; }
  function a(label,cls,fn,disabled=false){ const b=document.createElement('button'); b.className=`aBtn ${cls}`; b.textContent=label; b.onclick=fn; b.disabled=!!disabled; actionsEl.appendChild(b); return b;}

  function offerHero(){
    clearActions();
    const need = toCall(S.hero), eff=S.stacks[S.hero];
    // Fold always allowed
    a("Fold","aGhost", ()=>heroAct("fold"));
    if(S.street!=="preflop" || S.currentTo===0) a("Check","aGhost", ()=>heroAct("check"), need>0);
    if(need>0 && eff>0) a(`Call ${Math.min(need,eff).toFixed(1)} BB`,"aPrimary",()=>heroAct("call"));
    // Sizes
    const sizes = betSizes();
    sizes.forEach(sz=>{
      const label = (need>0) ? (sz>=eff+S.committed[S.hero] ? "All-in" : `Raise to ${sz.toFixed(1)} BB`) : `Bet ${Math.min(sz,eff).toFixed(1)} BB`;
      const cls = (need>0 && sz>=eff+S.committed[S.hero]) ? "aDanger" : "aPrimary";
      a(label,cls, ()=> heroAct( (need>0) ? (sz>=eff+S.committed[S.hero] ? "allin" : `raise_to:${sz}`) : `bet_to:${Math.min(sz,eff)}`), eff<=0);
    });
    if(eff>0) a("All-in","aDanger",()=>heroAct("allin"));
    setPrompt(`${S.street.toUpperCase()}: Your action as ${S.hero}.`);
  }

  function betSizes(){
    const eff=S.stacks[S.hero], bb=1.0;
    if(S.street==="preflop"){
      // present legal totals (to amounts)
      const minRaiseTotal = Math.max(S.currentTo + S.lastRaise, 2.0);
      return [minRaiseTotal, minRaiseTotal+1.5, minRaiseTotal+3].map(x=>Math.min(x, S.committed[S.hero]+eff));
    } else {
      const p=Math.max(2, S.pot);
      const adds=[Math.round(p*0.33), Math.round(p*0.5), Math.round(p*0.66)];
      return adds.map(add => Math.min(S.currentTo + add, S.committed[S.hero]+eff));
    }
  }

  async function heroAct(kind){
    const optimal=policyKey(S.street,S.hero);
    const fam = (()=>{
      if(kind==="allin") return "allin";
      if(kind==="fold"||kind==="call"||kind==="check") return kind;
      if(kind.startsWith("raise_to")) return "raise_med";
      if(kind.startsWith("bet_to")) return "bet_med";
      return "check";
    })();
    S.evLoss += evPenalty(S.street, fam, optimal);
    updatePotHud();

    // perform
    if(kind==="fold"){
      S.folded[S.hero]=true; setFoldedVisual(S.hero); chipTag(S.hero,"Fold");
      return endOrContinue(true); // hero finished
    }
    if(kind==="check"){
      chipTag(S.hero,"Check");
    }
    if(kind==="call"){
      const need=toCall(S.hero); const paid=payTo(S.hero,S.currentTo);
      chipTag(S.hero, paid >= S.stacks[S.hero]+paid ? "Call all-in" : `Call ${Math.min(need,paid).toFixed(1)} BB`);
      if(S.stacks[S.hero]<=0){ S.allin[S.hero]=true; return allInRunout(); }
    }
    if(kind.startsWith("raise_to")){
      const to=parseFloat(kind.split(":")[1]);
      // enforce legal min: to >= CB + LRS
      const legalMin = S.currentTo + Math.max(S.lastRaise, (S.street==="preflop"?1.0:Math.max(1.0,S.lastRaise)));
      const target = Math.max(to, legalMin);
      const prev = S.currentTo;
      S.currentTo = Math.min(target, S.committed[S.hero] + S.stacks[S.hero]);
      S.lastRaise = Math.max(1.0, +(S.currentTo - prev).toFixed(1));
      payTo(S.hero, S.currentTo);
      chipTag(S.hero, S.currentTo >= S.committed[S.hero]+S.stacks[S.hero] ? "All-in" : `Raise ${(S.currentTo-prev).toFixed(1)} BB`);
      S.interacted.add(S.hero);
      if(S.stacks[S.hero]<=0){ S.allin[S.hero]=true; return allInRunout(); }
    }
    if(kind.startsWith("bet_to")){
      const to=parseFloat(kind.split(":")[1]);
      const prev=S.currentTo; S.currentTo = Math.min(Math.max(prev + 1.0, to), S.committed[S.hero]+S.stacks[S.hero]); // min 1bb
      S.lastRaise = Math.max(1.0, +(S.currentTo - prev).toFixed(1));
      payTo(S.hero,S.currentTo); chipTag(S.hero, S.currentTo>=S.committed[S.hero]+S.stacks[S.hero] ? "All-in" : `Bet ${(S.currentTo-prev).toFixed(1)} BB`);
      S.interacted.add(S.hero);
      if(S.stacks[S.hero]<=0){ S.allin[S.hero]=true; return allInRunout(); }
    }
    if(kind==="allin"){
      const maxTo = S.committed[S.hero] + S.stacks[S.hero];
      const prev = S.currentTo; S.currentTo = Math.max(S.currentTo, maxTo);
      S.lastRaise = Math.max(1.0, +(S.currentTo - prev).toFixed(1));
      payTo(S.hero,S.currentTo); chipTag(S.hero,"All-in"); S.allin[S.hero]=true;
      return allInRunout();
    }

    // villains act after hero
    await villainsAfterHero();
    endOrContinue(false);
  }

  async function villainsBeforeHero(){
    const idx=S.seats.indexOf(S.hero);
    // preflop order starts UTG→…→BB; postflop starts SB→…→BB
    const order = S.street==="preflop" ? S.seats : rotateFrom(S.seats,"SB");
    for(const p of order){
      if(p===S.hero) break;
      if(S.street==="preflop") await vPre(p); else await vPost(p);
    }
  }
  async function villainsAfterHero(){
    const order = S.street==="preflop" ? S.seats : rotateFrom(S.seats,"SB");
    let seenHero=false;
    for(const p of order){
      if(p===S.hero){ seenHero=true; continue; }
      if(!seenHero) continue;
      if(S.street==="preflop") await vPre(p); else await vPost(p);
    }
  }

  function rotateFrom(list, start){
    const i=list.indexOf(start); if(i<0) return list.slice();
    return list.slice(i).concat(list.slice(0,i));
  }

  /* ---------- streets & end conditions ---------- */
  async function endOrContinue(heroEnded){
    if(heroEnded){
      // hero finished per "play through" selection
      return finish();
    }
    if(!isRoundClosed()){ offerHero(); return; }

    if(S.street==="preflop"){
      if(S.range==="preflop") return finish();
      await dealFlop(); await villainsBeforeHero(); offerHero(); return;
    }
    if(S.street==="flop"){
      if(S.range==="turn") return finish();
      await dealTurn(); await villainsBeforeHero(); offerHero(); return;
    }
    if(S.street==="turn"){
      await dealRiver(); await villainsBeforeHero(); offerHero(); return;
    }
    if(S.street==="river"){ return finish(); }
  }

  async function allInRunout(){
    if(S.street==="preflop"){ await dealFlop(); }
    if(S.street!=="river"){ await dealTurn(); }
    if(S.street!=="river"){ await dealRiver(); }
    return finish();
  }

  async function dealFlop(){
    const taken=new Set(Object.values(S.hands).flat().concat(S.board));
    S.board = dealUnique(3,taken); S.street="flop"; initStreetAccounting(); renderBoard(); updatePotHud(); await sleep(400);
  }
  async function dealTurn(){
    const taken=new Set(Object.values(S.hands).flat().concat(S.board));
    S.board = [...S.board, ...dealUnique(1,taken)]; S.street="turn"; initStreetAccounting(); renderBoard(); updatePotHud(); await sleep(350);
  }
  async function dealRiver(){
    const taken=new Set(Object.values(S.hands).flat().concat(S.board));
    S.board = [...S.board, ...dealUnique(1,taken)]; S.street="river"; initStreetAccounting(); renderBoard(); updatePotHud(); await sleep(350);
  }

  /* ---------- reveal (showdown-only) ---------- */
  function showdownReveal(){
    // showdownSet = villains who engaged vs hero and didn’t fold
    S.showdownSet = new Set(S.seats.filter(p=> p!==S.hero && !S.folded[p] && (S.interacted.has(p) || S.allin[p])));
    // place compact cards near their seat
    const revealSeat = (p)=>{
      const n=S.seatNodes[p]; if(!n) return;
      const holder=document.createElement('div'); holder.style.position='absolute'; holder.style.zIndex=7;
      holder.style.left=n.root.style.left; holder.style.top=`calc(${n.root.style.top} - 64px)`; holder.style.transform='translate(-50%,-50%)';
      holder.style.display='flex'; holder.style.gap='6px';
      S.hands[p].forEach(c=>{ const d=cardDiv(c); d.style.width="72px"; d.style.height="100px"; holder.appendChild(d); });
      floatLayer.appendChild(holder);
    };
    revealSeat(S.hero);
    S.showdownSet.forEach(revealSeat);
  }

  /* ---------- scoring, result, log ---------- */
  function computeScore(){ // 0…100
    const pct = Math.max(0,Math.min(100,Math.round(100 - S.evLoss*25)));
    return pct;
  }
  function verdict(p){ return p>=85?"Excellent":p>=70?"Strong":p>=50?"Okay":"Needs work"; }

  function finish(){
    clearActions();
    showdownReveal();

    const pct=computeScore();
    scorePct.textContent=`${pct}%`; scoreVerd.textContent=verdict(pct);
    resultBox.style.display='block'; resultBox.classList.toggle('good', pct>=50); resultBox.classList.toggle('bad', pct<50);

    const row=document.createElement('div'); row.className='logItem';
    row.innerHTML=`<div>${S.hero} • ${S.players}-max • ${S.range.toUpperCase()}</div>
                   <div class="${pct>=50?'scoreGood':'scoreBad'}">${pct}% ${pct>=50?'✅':'❌'}</div>`;
    logList.prepend(row);
    const store = JSON.parse(localStorage.getItem(S.logKey)||"[]"); store.push({ts:Date.now(), hero:S.hero, players:S.players, range:S.range, pct}); localStorage.setItem(S.logKey, JSON.stringify(store));

    const next=document.createElement('div'); next.style.textAlign='center'; next.style.marginTop='12px';
    const b=document.createElement('button'); b.className='aBtn aPrimary'; b.textContent='Next Hand'; b.onclick=startHand;
    next.appendChild(b); actionsEl.appendChild(next);
    setPrompt("Hand complete.");
  }

  /* ---------- hand bootstrap ---------- */
  async function startHand(){
    resultBox.style.display='none'; scorePct.textContent=""; scoreVerd.textContent="";
    floatLayer.innerHTML=""; boardEl.innerHTML=""; heroCardsEl.innerHTML="";
    S.evLoss=0; S.pot=0; S.folded={}; S.allin={}; S.interacted=new Set(); S.showdownSet=new Set();

    // seed
    srand(Date.now() ^ (Math.random()*1e9)|0);

    // prefs
    S.players=parseInt(selPlayers.value,10);
    S.seats=TEMPLATES[S.players].slice();
    seatsLayer.innerHTML=""; layoutSeats();

    if(!S.seats.includes(selHero.value)) selHero.value="BTN";
    S.hero=selHero.value;
    setHeroHighlight();

    S.range = selRange.value;
    S.start = selStart.value;

    // stacks
    S.stacks={}; S.seats.forEach(p=> S.stacks[p]=100.0);
    stacksUI();

    // hands
    const taken=new Set();
    S.hands={}; S.seats.forEach(p=> S.hands[p]=dealUnique(2,taken));
    // starting board by mode
    if(S.start==="preflop") S.board=[];
    if(S.start==="flop")   S.board=dealUnique(3,taken);
    if(S.start==="turn")   S.board=[...dealUnique(3,taken), ...dealUnique(1,taken)];
    if(S.start==="river")  S.board=[...dealUnique(3,taken), ...dealUnique(2,taken)];
    renderBoard(); renderHeroCards();

    S.street=S.start; initStreetAccounting(); updatePotHud();

    // automatic open: villains before hero for starting street
    await villainsBeforeHero();
    offerHero();
  }

  /* ---------- util ---------- */
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  /* ---------- wiring & restore ---------- */
  btnNew.onclick = startHand;
  btnClearLog.onclick = ()=>{ localStorage.removeItem(S.logKey); logList.innerHTML=""; };
  selPlayers.onchange = ()=>{ localStorage.setItem("gto_players_pref", selPlayers.value); startHand(); };
  selRange.onchange   = ()=> localStorage.setItem("gto_range_pref", selRange.value);
  selStart.onchange   = ()=> localStorage.setItem("gto_start_pref", selStart.value);
  selHero.onchange    = ()=>{ S.hero=selHero.value; localStorage.setItem("gto_hero_pref", S.hero); setHeroHighlight(); renderHeroCards(); };

  function restore(){
    const p=localStorage.getItem("gto_players_pref"); if(p && TEMPLATES[+p]) selPlayers.value=p;
    const r=localStorage.getItem("gto_range_pref"); if(r) selRange.value=r;
    const s=localStorage.getItem("gto_start_pref"); if(s) selStart.value=s;
  }

  // initial seat list for hero selector
  function refreshHeroOptions(){
    selHero.innerHTML = S.seats.map(p=>`<option value="${p}">${p}</option>`).join('');
    const h=localStorage.getItem("gto_hero_pref"); selHero.value = (h && S.seats.includes(h))? h : "BTN";
  }

  // initial boot
  (function boot(){
    S.players=parseInt(selPlayers.value,10);
    S.seats=TEMPLATES[S.players].slice();
    layoutSeats(); refreshHeroOptions(); restore();
    // build saved log view
    JSON.parse(localStorage.getItem(S.logKey)||"[]").slice(-20).reverse().forEach(e=>{
      const row=document.createElement('div'); row.className='logItem';
      row.innerHTML=`<div>${e.hero} • ${e.players}-max • ${e.range.toUpperCase()}</div>
                     <div class="${e.pct>=50?'scoreGood':'scoreBad'}">${e.pct}% ${e.pct>=50?'✅':'❌'}</div>`;
      logList.appendChild(row);
    });
    // auto start
    startHand();
  })();
})();
</script>
</body>
</html>
<script>
/* === Utility functions === */
const RANKS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];
const SUITS = ['♠','♥','♦','♣'];

function randomCard() {
  const r = RANKS[Math.floor(Math.random()*13)];
  const s = SUITS[Math.floor(Math.random()*4)];
  const isRed = (s==='♥'||s==='♦');
  return {r,s,color:isRed?'red':'black'};
}

function dealHand() {
  return [randomCard(), randomCard()];
}

function cardHTML(c) {
  return `<div class="card"><div class="rank ${c.color}">${c.r}</div><div class="suit ${c.color}">${c.s}</div></div>`;
}

function rand(min,max){return Math.random()*(max-min)+min}

/* === State === */
let S = {
  numPlayers:9,
  heroIndex:8,
  stage:"idle", // preflop, flop, turn, river
  pot:0,
  currentTo:1, // current bet to call
  lastRaise:1,
  stacks:[],
  hands:[],
  folded:[],
  committed:{},
  seats:[],
  seatNodes:{},
  board:[],
  streetCards:[],
  activeCount:0,
  heroActing:false,
  heroAllIn:false,
};

/* === DOM === */
const table = document.getElementById('table');
const hudStreet = document.getElementById('hudStreet');
const hudPot = document.getElementById('hudPot');
const hudSPR = document.getElementById('hudSPR');
const board = document.getElementById('board');
const heroCards = document.getElementById('heroCards');
const floatLayer = document.getElementById('floatLayer');
const seatsLayer = document.getElementById('seatsLayer');
const prompt = document.getElementById('prompt');
const actions = document.getElementById('actions');
const result = document.getElementById('result');
const scorePct = document.getElementById('scorePct');
const scoreVerdict = document.getElementById('scoreVerdict');
const logList = document.getElementById('logList');
const btnNew = document.getElementById('btnNew');
const selPlayers = document.getElementById('selPlayers');
const selHero = document.getElementById('selHero');
const selRange = document.getElementById('selRange');
const btnClearLog = document.getElementById('btnClearLog');

/* === Setup hero options === */
function populateHeroSelect(){
  const labels = ['SB','BB','UTG','UTG+1','UTG+2','LJ','HJ','CO','BTN'];
  selHero.innerHTML='';
  for(let i=0;i<S.numPlayers;i++){
    const opt=document.createElement('option');
    opt.value=i; opt.textContent=labels[i]||('P'+(i+1));
    if(i===S.heroIndex) opt.selected=true;
    selHero.appendChild(opt);
  }
}

/* === Table Layout === */
function seatCoords(i,n){
  const angle = (Math.PI*2*i/n) - Math.PI/2;
  const radius = 42; // %
  return {left:50+radius*Math.cos(angle), top:50+radius*Math.sin(angle)};
}

function buildSeats(){
  seatsLayer.innerHTML='';
  S.seatNodes={};
  for(let i=0;i<S.numPlayers;i++){
    const seat=document.createElement('div');
    seat.className='seat';
    const {left,top}=seatCoords(i,S.numPlayers);
    seat.style.left=`${left}%`;
    seat.style.top=`${top}%`;
    seat.textContent=posName(i);
    const stack=document.createElement('div');
    stack.className='stack';
    stack.textContent='100 BB';
    seat.appendChild(stack);
    seatsLayer.appendChild(seat);
    S.seatNodes[i]={root:seat,stack};
  }
}

function posName(i){
  const labels9=['SB','BB','UTG','UTG+1','UTG+2','LJ','HJ','CO','BTN'];
  return labels9[i]||('P'+(i+1));
}

/* === Initialize hand === */
function newHand(){
  result.style.display='none';
  heroCards.innerHTML='';
  board.innerHTML='';
  floatLayer.innerHTML='';
  S.stage='preflop';
  S.pot=0; S.currentTo=1; S.lastRaise=1;
  S.stacks=new Array(S.numPlayers).fill(100);
  S.hands=new Array(S.numPlayers).fill(0).map(dealHand);
  S.folded=new Array(S.numPlayers).fill(false);
  S.committed={};
  S.heroIndex=parseInt(selHero.value);
  S.numPlayers=parseInt(selPlayers.value);
  buildSeats();
  populateHeroSelect();
  drawHeroCards();
  updateHUD();
  autoStartPreflop();
}

function drawHeroCards(){
  heroCards.innerHTML='';
  const h=S.hands[S.heroIndex];
  heroCards.innerHTML=cardHTML(h[0])+cardHTML(h[1]);
  const node=S.seatNodes[S.heroIndex].root;
  const {left,top}=node.style;
  heroCards.style.left=left;
  heroCards.style.top=top;
}

/* === HUD === */
function updateHUD(){
  hudStreet.textContent=S.stage.toUpperCase();
  hudPot.textContent=`Pot ${S.pot.toFixed(1)} BB`;
  const effStack=Math.min(...S.stacks.filter(x=>x>0));
  hudSPR.textContent=`SPR ${(effStack/(S.pot||1)).toFixed(1)}`;
}

/* === Chips Visual Tag === */
function chipTag(p,label){
  const n=S.seatNodes[p];
  if(!n)return;
  const tag=document.createElement('div');
  tag.className='chipTag';
  tag.innerHTML=`<span class="chipDot"></span>${label}`;
  tag.style.left=n.root.style.left;
  tag.style.top=`calc(${n.root.style.top} - 40px)`;
  floatLayer.appendChild(tag);
  setTimeout(()=>tag.style.opacity='0.6',2500);
  setTimeout(()=>tag.style.opacity='0.2',4000);
  setTimeout(()=>tag.remove(),5000);
}

/* === Betting Flow Helpers === */
function legalRaiseTarget(){
  const minInc=Math.max(1.0,S.lastRaise);
  return S.currentTo+minInc;
}

/* === Auto Preflop === */
function autoStartPreflop(){
  prompt.textContent="Dealing… Preflop starting.";
  // Post blinds
  S.committed[0]=0.5; S.committed[1]=1.0;
  S.stacks[0]-=0.5; S.stacks[1]-=1.0;
  S.pot=1.5;
  updateStacks();
  updateHUD();
  setTimeout(()=>villainAct(2),1200);
}

/* === Villain Acting === */
function villainAct(i){
  if(i>=S.numPlayers){
    heroTurn();
    return;
  }
  if(S.folded[i]){villainAct(i+1);return;}
  if(i===S.heroIndex){villainAct(i+1);return;}

  const n=S.seatNodes[i].root;
  n.classList.add('acting');
  setTimeout(()=>{
    n.classList.remove('acting');
    // Randomized simple GTO mimic
    const hand=S.hands[i];
    const strength=RANKS.indexOf(hand[0].r)+RANKS.indexOf(hand[1].r);
    let act;
    if(strength>20 && Math.random()>0.4){act='raise'}
    else if(strength>14 && Math.random()>0.4){act='call'}
    else act='fold';

    if(act==='fold'){
      S.folded[i]=true;
      n.classList.add('folded');
      n.textContent='Fold';
    }else if(act==='call'){
      const toCall=Math.max(0,S.currentTo-(S.committed[i]||0));
      S.stacks[i]-=toCall;
      S.pot+=toCall;
      S.committed[i]=(S.committed[i]||0)+toCall;
      chipTag(i,`Call ${toCall.toFixed(1)} BB`);
    }else if(act==='raise'){
      const target=legalRaiseTarget();
      const toPut=Math.min(target-(S.committed[i]||0),S.stacks[i]);
      if(toPut<=0){S.folded[i]=true;n.textContent='Fold';}
      else{
        S.stacks[i]-=toPut;
        S.pot+=toPut;
        S.committed[i]=(S.committed[i]||0)+toPut;
        S.lastRaise=toPut;
        S.currentTo=(S.committed[i]);
        chipTag(i,`Raise ${(toPut).toFixed(1)} BB`);
      }
    }
    updateStacks();
    updateHUD();
    villainAct(i+1);
  },rand(900,1400));
}

function updateStacks(){
  for(let i=0;i<S.numPlayers;i++){
    const st=S.stacks[i];
    const n=S.seatNodes[i];
    if(n) n.stack.textContent=`${st.toFixed(1)} BB`;
  }
}
<script>
/* ===========================
   HERO TURN + ACTIONS
   =========================== */
function clearActions(){ actions.innerHTML=''; }
function addBtn(lbl, cls, on){ 
  const b=document.createElement('button'); 
  b.className=`btn ${cls}`; b.textContent=lbl; 
  b.onclick=on; actions.appendChild(b); 
  return b;
}

function toCall(player){
  return Math.max(0, S.currentTo - (S.committed[player]||0));
}

function raiseTargets() {
  // strict no-limit minimum raise rule:
  // next total must be >= currentTo + lastRaise
  const minTotal = Math.max(1, S.currentTo + Math.max(1, S.lastRaise));
  const hStack = S.stacks[S.heroIndex];
  const maxTotal = (S.committed[S.heroIndex]||0) + hStack; // all-in ceiling

  if(maxTotal <= S.currentTo) return []; // no legal raises (short / all-in)

  // offer a couple of raise totals between minTotal and maxTotal
  const options = [];
  const add = (t)=>{ if(t> S.currentTo && t<=maxTotal) options.push(+t.toFixed(1)); };

  // preflop: offer ~2.2x open / 3x / jam when possible
  if(S.stage==='preflop'){
    add(Math.max(minTotal, Math.round((S.currentTo||1)*2.2*10)/10));
    add(Math.max(minTotal, Math.round((S.currentTo||1)*3.0*10)/10));
  } else {
    // postflop: offer pot fractions relative to pot pressure
    const potBase = Math.max(2, Math.round(S.pot*0.5));
    add(Math.max(minTotal, S.currentTo + potBase));        // raise add ~1/2 pot
    add(Math.max(minTotal, S.currentTo + Math.round(S.pot)));// raise add ~pot
  }
  // ensure uniqueness + sorted + maybe add jam
  const uniq = [...new Set(options)].sort((a,b)=>a-b);
  if(maxTotal - (S.committed[S.heroIndex]||0) > 0) uniq.push(maxTotal); // all-in
  return uniq;
}

function heroTurn(){
  // If hero is already folded/all-in, end now per “stop once hero is done”
  if(S.folded[S.heroIndex] || S.stacks[S.heroIndex] <= 0){
    finishHand(); 
    return;
  }

  prompt.textContent = `Your action (${posName(S.heroIndex)}) — ${S.stage.toUpperCase()}`;
  clearActions();

  const need = toCall(S.heroIndex);
  const eff  = S.stacks[S.heroIndex];

  // Always allow Fold
  addBtn('Fold','btn-ghost', ()=>heroDo('fold'));

  if(need===0){
    // may Check or Bet/Raise
    addBtn('Check','btn-ghost', ()=>heroDo('check'));
  }else{
    // may Call if has chips
    if(eff>0){
      addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`,'btn-primary', ()=>heroDo('call'));
    }else{
      // all-in forced call is handled by heroDo('call')
      addBtn(`Call (all-in)`,'btn-primary', ()=>heroDo('call'));
    }
  }

  // Offer legal raises (strict)
  const targets = raiseTargets();
  for(const total of targets){
    const addAmt = total - (S.committed[S.heroIndex]||0);
    const isJam  = Math.abs(total - ((S.committed[S.heroIndex]||0)+S.stacks[S.heroIndex]))<1e-9;
    const label  = isJam ? 'All-in' : (need===0 ? `Bet ${addAmt.toFixed(1)} BB` : `Raise to ${total.toFixed(1)} BB`);
    addBtn(label, isJam?'btn-danger':'btn-primary', ()=>heroDo(isJam?'allin':`raise_to:${total}`));
  }
}

function heroDo(action){
  // compute a simple “policy” to score against
  const optimal = heroOptimal();
  const alias   = actionAlias(action);
  S.evLoss = (S.evLoss||0) + evPenalty(alias, optimal);

  // apply action
  if(action==='fold'){
    S.folded[S.heroIndex]=true;
    flashFold(S.heroIndex);
    // hand stops for hero immediately (per spec)
    finishHand();
    return;
  }

  if(action==='check'){
    chipEcho(S.heroIndex,'Check');
    // move street ONLY when hero acts (per spec)
    advanceAfterHero();
    return;
  }

  if(action==='call'){
    const need = toCall(S.heroIndex);
    const can  = S.stacks[S.heroIndex];
    const pay  = Math.min(need, can);
    commitChips(S.heroIndex, (S.committed[S.heroIndex]||0) + pay);
    chipTag(S.heroIndex, pay>=can ? 'Call all-in' : `Call ${pay.toFixed(1)} BB`);
    if(S.stacks[S.heroIndex]<=0){
      // hero all-in: hand ends for hero
      finishHand(); 
      return;
    }
    advanceAfterHero();
    return;
  }

  if(action.startsWith('raise_to:') || action==='allin'){
    let target;
    if(action==='allin'){
      target = (S.committed[S.heroIndex]||0) + S.stacks[S.heroIndex];
    }else{
      target = parseFloat(action.split(':')[1]);
    }
    // Enforce minimum legal raise:
    const minTotal = Math.max(1, S.currentTo + Math.max(1, S.lastRaise));
    if(target < minTotal){
      // sanitize to min legal
      target = minTotal;
    }
    const before = S.currentTo;

    // Put chips to reach target
    commitChips(S.heroIndex, target);
    // Update current and lastRaise
    S.lastRaise = before===0 ? Math.max(1, target - before) : Math.max(1, target - before);
    S.currentTo = target;

    const addAmt = target - (S.committed[S.heroIndex]||0); // (after commit this is 0)
    chipTag(S.heroIndex, action==='allin' ? 'All-in' : (toCall(S.heroIndex)>0?`Raise ${(target-before).toFixed(1)} BB`:`Bet ${(target-before).toFixed(1)} BB`));

    if(S.stacks[S.heroIndex]<=0){
      finishHand(); 
      return;
    }
    advanceAfterHero();
    return;
  }
}

/* ===========================
   POLICY & SCORING (simplified)
   =========================== */
function heroOptimal(){
  // crude strength metric by ranks; suited bonus
  const h=S.hands[S.heroIndex];
  const v = RANKS.indexOf(h[0].r)+RANKS.indexOf(h[1].r) + (h[0].s===h[1].s?2:0);
  if(S.stage==='preflop'){
    if(v>=20) return 'raise';
    if(v>=15) return 'call';
    return 'fold';
  }else{
    if(v>=22) return 'bet';
    if(v>=17) return 'check';
    return 'check';
  }
}

function actionAlias(a){
  if(a==='fold'||a==='check'||a==='call'||a==='allin') return a;
  if(a.startsWith('raise_to:')) return 'raise';
  return a;
}

function evPenalty(actionKey, optimalKey){
  if(actionKey===optimalKey) return 0;
  const fam = (x)=> x==='raise'||x==='allin' ? 'Agg' : x;
  const w = {
    preflop: {fold:.6, check:.8, call:.5, Agg:.6},
    postflop:{fold:.8, check:.3, call:.4, Agg:.55}
  };
  const bucket = (S.stage==='preflop')?'preflop':'postflop';
  let base = (w[bucket][fam(actionKey)] ?? .5);
  // Reward good folds with garbage preflop
  if(bucket==='preflop' && actionKey==='fold'){
    const h=S.hands[S.heroIndex], v=RANKS.indexOf(h[0].r)+RANKS.indexOf(h[1].r);
    if(v<13) return 0;
  }
  return +(base + Math.random()*0.12).toFixed(2);
}

/* ===========================
   CHIP / POT ACCOUNTING
   =========================== */
function commitChips(player, targetTotal){
  const had = (S.committed[player]||0);
  const need = Math.max(0, targetTotal - had);
  const can  = S.stacks[player];
  const pay  = Math.min(need, can);

  S.stacks[player] -= pay;
  S.pot            += pay;
  S.committed[player] = +(had + pay).toFixed(1);
  updateStacks(); updateHUD();
}

function chipEcho(p, text){
  // small floating label for simple actions
  const n=S.seatNodes[p]; if(!n) return;
  const tag=document.createElement('div');
  tag.className='float-chip';
  tag.style.left=n.root.style.left;
  tag.style.top=n.root.style.top;
  tag.textContent = `${posName(p)}: ${text}`;
  floatLayer.appendChild(tag);
  setTimeout(()=>tag.remove(),1800);
}

function flashFold(p){
  const n=S.seatNodes[p]?.root; if(!n) return;
  n.classList.add('folded');
  const old = n.textContent;
  n.textContent = 'Fold';
  setTimeout(()=>{ n.textContent = old; }, 1400);
}

/* ===========================
   STREETS (hero-gated flow)
   =========================== */
function advanceAfterHero(){
  // The next street should never start unless the hero has acted.
  // If the sequence specifies deeper, we deal; otherwise we finish now.
  if(S.stage==='preflop'){
    if(selRange.value==='preflop'){ finishHand(); return; }
    dealFlop();
    heroTurn(); // hero acts on flop
    return;
  }
  if(S.stage==='flop'){
    if(selRange.value==='turn'){ finishHand(); return; }
    dealTurn();
    heroTurn();
    return;
  }
  if(S.stage==='turn'){
    if(selRange.value==='river'){ finishHand(); return; }
    dealRiver();
    heroTurn();
    return;
  }
  if(S.stage==='river'){
    finishHand();
  }
}

function uniqueCardString(c){ return c.r + c.s; }
function alreadyUsed(set, c){ return set.has(uniqueCardString(c)); }

function dealUnique(n){
  const out=[]; const used=new Set(S.board.map(uniqueCardString));
  // include hole cards too
  for(let i=0;i<S.numPlayers;i++){
    (S.hands[i]||[]).forEach(card=> used.add(uniqueCardString(card)));
  }
  while(out.length<n){
    const c = randomCard();
    if(!alreadyUsed(used,c)){ out.push(c); used.add(uniqueCardString(c)); }
  }
  return out;
}

function renderBoard(){
  board.innerHTML = S.board.map(c=>cardHTML(c)).join('');
}

function dealFlop(){
  S.stage='flop';
  // cleanup per-street chip tags so amounts remain visible during the street only
  // (do not clear here; we keep them until next street per spec)
  const three = dealUnique(3);
  S.board = three;
  renderBoard();
  // reset street contributions (everyone equalized to currentTo already for hero-gated)
  streetReset();
  updateHUD();
}

function dealTurn(){
  S.stage='turn';
  const one = dealUnique(1);
  S.board = S.board.concat(one);
  renderBoard();
  streetReset();
  updateHUD();
}

function dealRiver(){
  S.stage='river';
  const one = dealUnique(1);
  S.board = S.board.concat(one);
  renderBoard();
  streetReset();
  updateHUD();
}

function streetReset(){
  // At each new street: the live bet is zeroed; committed resets to 0 for the *street*;
  // pot already contains previous contributions. BB minimum for postflop open = 1 BB.
  // Keep chip tags from prior street visible a little longer, then fade out.
  // Soft clear older tags:
  document.querySelectorAll('.chipTag').forEach(tag=>{
    tag.style.opacity='0.35';
    setTimeout(()=>tag.remove(), 1600);
  });
  S.currentTo = 0;
  // DO NOT wipe total commitments behind the pot; we only reset street view:
  for(const k in S.committed){ S.committed[k]=0; }
  // On flop/turn/river, min “bet” is 1 BB (first wager), but currentTo is 0 until someone bets.
  S.lastRaise = 1;
}

/* ===========================
   SHOWDOWN / RESULT
   =========================== */
function gtoPercent(){
  // Convert accumulated evLoss to score (0–100)
  const p = Math.max(0, Math.min(100, Math.round(100 - (S.evLoss||0)*25)));
  return p;
}
function verdict(p){
  return p>=85?'Excellent': p>=70?'Strong': p>=50?'Okay':'Needs Work';
}

function finishHand(){
  // Show only hero result panel (do NOT reveal all hole cards)
  const pct = gtoPercent();
  result.style.display='block';
  scorePct.textContent = `${pct}%`;
  scorePct.classList.toggle('score-good', pct>=50);
  scorePct.classList.toggle('score-bad',  pct<50);
  scoreVerdict.textContent = verdict(pct);

  // Add to sidebar log
  const row=document.createElement('div');
  row.className='log-item';
  row.innerHTML = `<div><strong>${posName(S.heroIndex)}</strong> • ${S.numPlayers}-max • ${S.stage.toUpperCase()}</div>
                   <div class="${pct>=50?'score-good':'score-bad'}">${pct}% ${pct>=50?'✅':'❌'}</div>`;
  logList.prepend(row);

  clearActions();
  addBtn('Next Hand','btn-primary', ()=>newHand());
}

/* ===========================
   CONTROLS & BOOT
   =========================== */
btnNew.onclick = ()=>newHand();
btnClearLog.onclick = ()=>{ logList.innerHTML=''; };

selPlayers.onchange = ()=>{
  S.numPlayers = parseInt(selPlayers.value,10);
  populateHeroSelect();
  buildSeats();
  drawHeroCards();
};

selHero.onchange = ()=>{
  S.heroIndex = parseInt(selHero.value,10);
  drawHeroCards();
};

selRange.onchange = ()=>{ /* respected during advanceAfterHero() */ };

// Auto-start a hand on load
window.addEventListener('load', ()=>{
  S.numPlayers = parseInt(selPlayers.value,10);
  S.heroIndex  = parseInt(selHero.value,10);
  buildSeats();
  populateHeroSelect();
  drawHeroCards();
  newHand();
});
</script>
</body>
</html>








