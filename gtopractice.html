<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>

  <title>GTO Shark • Live Practice (GTO Engine)</title>

  <style>
    :root{
      --bg:#0b1220;
      --ink:#e2e8f0;
      --felt:#0f3d37;
      --felt-hi:#13574f;
      --rail:#162239;
      --rail-glow: rgba(79,70,229,.35);

      --indigo:#4f46e5;
      --teal:#14b8a6;
      --good:#22c55e;
      --warn:#fbbf24;
      --bad:#ef4444;

      --table-size: 900px;
      --seat: 84px;
      --card-w: 88px;
      --card-h: 124px;
      --board-w: 80px;
      --board-h: 112px;
      --rail-width: 12px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      padding:16px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,"Helvetica Neue",Arial;
      color:var(--ink);
      background:var(--bg);
    }

    .app{
      display:grid;
      grid-template-columns: minmax(760px, 1fr) 360px;
      gap:16px;
      align-items:start;
      max-width:1400px;
      margin:0 auto;
    }
    @media (max-width:1200px){
      .app{grid-template-columns:1fr}
      .sidebar{order:3}
    }

    header{
      max-width:1400px;
      margin:0 auto 10px auto;
      display:flex;
      gap:12px;
      align-items:end;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-weight:900;
      letter-spacing:.2px;
      color:#c7d2fe;
    }
    .sub{
      margin:4px 0 0 0;
      color:#94a3b8;
      font-size:13px;
    }
    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .lbl{
      font-size:12px;
      color:#9fb2cc;
      margin-right:4px;
    }
    select,
    button,
    input[type=number]{
      background:#0f172a;
      color:#e2e8f0;
      border:1px solid #334155;
      border-radius:10px;
      padding:8px 10px;
      font-weight:600;
    }
    button.primary{
      background:var(--indigo);
      border-color:transparent;
      color:#fff;
      font-weight:800;
    }
    button.ghost{
      background:#0f172a;
      border:1px solid #2a3a52;
      color:#9be2d6;
    }
    button.danger{
      background:linear-gradient(135deg,#ef4444,#dc2626);
      color:#fff;
      border:none;
    }
    button:disabled{
      opacity:.6;
      cursor:not-allowed;
    }

    .table-wrap{
      display:flex;
      justify-content:center;
    }
    .table{
      width:var(--table-size);
      height:var(--table-size);
      position:relative;
      border-radius:50%;
      background:
        radial-gradient(ellipse at 50% 45%, rgba(18,93,84,.9), rgba(11,61,54,.85) 60%, rgba(6,31,28,.8) 78%, rgba(5,22,20,.8) 88%),
        radial-gradient(circle at 35% 35%, rgba(255,255,255,.06) 0 6%, transparent 7% 100%),
        radial-gradient(circle at 68% 62%, rgba(255,255,255,.05) 0 7%, transparent 8% 100%),
        radial-gradient(circle at 28% 78%, rgba(255,255,255,.05) 0 5%, transparent 6% 100%),
        linear-gradient(145deg, var(--felt-hi), var(--felt));
      outline: var(--rail-width) solid var(--rail);
      box-shadow:
        inset 0 0 48px rgba(0,0,0,.35),
        0 0 0 3px var(--rail-glow),
        0 14px 40px rgba(20,184,166,.15);
    }

    .hud{
      position:absolute;
      left:50%;
      top:45%;
      transform:translate(-50%,-50%);
      display:flex;
      gap:10px;
      align-items:center;
      border:1px solid #34435b;
      background:rgba(15,23,42,.65);
      padding:6px 10px;
      border-radius:10px;
      font-weight:800;
      color:#c7d2fe;
      z-index:40;
      backdrop-filter: blur(2px);
    }
    .hud .sep{opacity:.5}

    .board{
      position:absolute;
      left:50%;
      top:52%;
      transform:translate(-50%,-50%);
      display:flex;
      gap:8px;
      z-index:35;
    }

    .float-layer{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:50;
    }

    .seat{
      position:absolute;
      transform:translate(-50%,-50%);
      width:var(--seat);
      height:var(--seat);
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#142034;
      border:2px solid #2a3a52;
      color:#9fb2cc;
      font-weight:900;
      font-size:12px;
      box-shadow:0 6px 18px rgba(0,0,0,.35);
      transition:.25s;
    }
    .seat.hero{
      border-color:#1dbd72;
      color:#d1ffe2;
      box-shadow:0 0 22px rgba(29,189,114,.65);
    }
    .seat.acting{
      border-color:var(--warn);
      color:#fde68a;
      box-shadow:0 0 26px rgba(251,191,36,.65);
    }
    .seat.folded{
      color:#64748b;
      border-color:#3a4a63;
      filter:grayscale(.6);
    }
    .stack{
      position:absolute;
      top:calc(100% + 14px);
      left:50%;
      transform:translateX(-50%);
      background:#0b1220;
      border:1px solid rgba(99,102,241,.5);
      color:#c7d2fe;
      padding:2px 10px;
      border-radius:9999px;
      font-size:12px;
      white-space:nowrap;
    }

    .hero-cards{
      position:absolute;
      transform:translate(-50%,-50%);
      display:flex;
      gap:8px;
      z-index:60;
    }

    .bet-plate{
      position:absolute;
      transform:translate(-50%,0);
      background:linear-gradient(135deg,#19263c,#0e1729);
      border:1px solid rgba(99,102,241,.55);
      color:#c7d2fe;
      padding:.3rem .55rem;
      border-radius:.6rem;
      font-weight:900;
      font-size:12px;
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      display:flex;
      align-items:center;
      gap:.35rem;
      opacity:0;
      animation:chiprise 0.6s ease-out forwards;
      z-index:55;
    }
    .chip-icon{
      width:14px;
      height:14px;
      border-radius:9999px;
      background: radial-gradient(
        circle at 50% 50%,
        #f59e0b 0 26%,
        #7c3aed 28% 32%,
        #f59e0b 35% 60%,
        #7c3aed 63% 67%,
        #f59e0b 70%
      );
      border:1px solid rgba(245,158,11,.85);
      box-shadow:0 0 0 1px rgba(124,58,237,.75) inset;
    }
    @keyframes chiprise{
      0%{opacity:0; transform:translate(-50%,8px)}
      20%{opacity:1; transform:translate(-50%,0)}
      100%{opacity:1; transform:translate(-50%,-8px)}
    }

    .card{
      width:var(--card-w);
      height:var(--card-h);
      border-radius:16px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background:linear-gradient(160deg,#fff 0%,#f3f5ff 55%,#e5e9ff 100%);
      border:2px solid rgba(79,70,229,.9);
      box-shadow:0 10px 22px rgba(0,0,0,.35);
    }
    .board .card{
      width:var(--board-w);
      height:var(--board-h);
      border-radius:14px;
    }
    .rank{
      font-size:46px;
      font-weight:900;
      line-height:1;
    }
    .suit{
      font-size:36px;
      line-height:1;
      margin-top:2px;
    }
    .red{color:#ef4444}
    .black{color:#0f172a}

    .panel{
      background:#0b1220;
      border:1px solid #2b3647;
      border-radius:16px;
      padding:14px;
    }
    .panel h3{
      margin:0 0 8px 0;
    }
    .prompt{
      color:#94a3b8;
      font-size:14px;
    }
    .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
    }
    .btn{
      background:#0f172a;
      color:#e2e8f0;
      border:1px solid #334155;
      border-radius:12px;
      padding:12px 14px;
      font-weight:800;
      transition:.15s;
    }
    .btn.primary{
      background:var(--indigo);
      color:#fff;
      border-color:transparent;
    }
    .btn.ghost{
      background:#0f172a;
      color:#9be2d6;
      border:1px solid #2b3647;
    }
    .btn.danger{
      background:linear-gradient(135deg,#ef4444,#dc2626);
      color:#fff;
      border:none;
    }
    .btn:disabled{
      opacity:.6;
      cursor:not-allowed;
    }

    .sidebar .box{
      background:#0b1220;
      border:1px solid #2b3647;
      border-radius:16px;
      padding:14px;
    }
    .result{
      background:linear-gradient(135deg,var(--indigo),var(--teal));
      color:#fff;
      border-radius:16px;
      padding:14px;
      display:none;
    }
    .big-score{
      font-size:48px;
      font-weight:900;
    }
    .log-head{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:6px;
    }
    .log{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height:260px;
      overflow:auto;
    }
    .item{
      display:flex;
      justify-content:space-between;
      align-items:center;
      background:#0f172a;
      border:1px solid #2b3647;
      border-radius:12px;
      padding:8px 10px;
      font-size:12px;
    }
    .ok{
      color:var(--good);
      font-weight:900;
    }
    .bad{
      color:var(--bad);
      font-weight:900;
    }

    .node-box{
      margin-top:12px;
      background:#0b1220;
      border:1px solid #2b3647;
      border-radius:16px;
      padding:14px;
      font-size:12px;
      color:#9ca3af;
    }

    .hidden{display:none}
  </style>
</head>
<body>

<header>
  <div>
    <h1>GTO Shark – Live Practice</h1>
    <div class="sub">Real-time GTO training with GTO-based NPC decisions & solver scoring</div>
  </div>

  <div class="controls">
    <div class="lbl">Players:</div>
    <select id="playerCount">
      <option value="6">6-max</option>
      <option value="7">7 players</option>
      <option value="8">8 players</option>
      <option value="9" selected>9 players</option>
    </select>

    <div class="lbl">Hero Position:</div>
    <select id="heroPosition"></select>

    <button id="newHand" class="primary">New Hand</button>
    <button id="reset" class="danger">Reset</button>
  </div>
</header>

<div class="app">
  <div class="table-wrap">
    <div class="table" id="table">

      <div class="float-layer" id="floatLayer"></div>

      <div class="hud" id="hud">
        <span id="streetDisplay">Preflop</span>
        <span class="sep">•</span>
        <span id="potDisplay">Pot: 0</span>
        <span class="sep">•</span>
        <span id="sprDisplay">SPR: —</span>
      </div>

      <div class="board" id="board"></div>

      <div id="seatContainer"></div>

      <div class="hero-cards" id="heroCards"></div>

    </div>
  </div>

  <div class="sidebar">
    <div class="box">
      <h3>Current Decision</h3>
      <div class="prompt" id="actionPrompt">Start a hand to begin.</div>

      <div class="btn-row">
        <button class="btn primary" id="btnFold">Fold</button>
        <button class="btn primary" id="btnCall">Call</button>
        <button class="btn primary" id="btnRaiseSmall">Raise Small</button>
        <button class="btn primary" id="btnRaiseBig">Raise Big</button>
      </div>

    </div>

    <div class="box" style="margin-top:14px;">
      <h3>Scenario Tools</h3>

      <div style="margin-bottom:6px;">
        <div class="lbl">Force Board:</div>
        <input id="forceFlop" placeholder="Flop (e.g. Ah Kd 2s)" style="width:100%; margin:4px 0;">
        <input id="forceTurn" placeholder="Turn (e.g. 9c)" style="width:100%; margin:4px 0;">
        <input id="forceRiver" placeholder="River (e.g. Qh)" style="width:100%; margin:4px 0;">
      </div>

      <button id="applyForcedBoard" class="btn ghost" style="width:100%;">Apply Forced Board</button>
      <button id="clearForcedBoard" class="btn ghost" style="width:100%; margin-top:6px;">Clear</button>
    </div>

    <div class="result" id="resultBox" style="margin-top:14px;">
      <div class="big-score" id="scoreDisplay"></div>
      <div id="scoreText"></div>
    </div>

    <div class="box" style="margin-top:14px;">
      <div class="log-head">
        <h3>Hand Log</h3>
        <button id="clearLog" class="btn ghost" style="padding:6px 8px; font-size:11px;">Clear</button>
      </div>
      <div class="log" id="log"></div>
    </div>

    <div class="node-box hidden" id="nodeInspector"></div>

  </div>
</div>
<script>
// ============================================================================
//  GLOBALS
// ============================================================================
let seats = [];
let heroIndex = 0;
let playerCount = 9;

let deck = [];
let board = [];
let heroHand = [];
let pot = 0;
let street = "preflop";
let forcedFlop = null;
let forcedTurn = null;
let forcedRiver = null;

let actingIndex = 0;
let actionPending = false;
let logEl;
let boardEl;
let heroCardsEl;
let seatContainer;

// ============================================================================
//  CARD DEFINITIONS
// ============================================================================
const SUITS = ["♠","♥","♦","♣"];
const VALUES = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];

function createDeck() {
  deck = [];
  for (let s = 0; s < 4; s++) {
    for (let v = 0; v < 13; v++) {
      deck.push({
        value: VALUES[v],
        suit: SUITS[s],
        id: VALUES[v] + SUITS[s]
      });
    }
  }
}

function shuffleDeck() {
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
}

function dealCard() {
  return deck.pop();
}

// ============================================================================
//  SEAT / TABLE SETUP
// ============================================================================
function createSeats() {
  seats = [];
  const container = seatContainer;
  container.innerHTML = "";

  const radius = 350;
  const cx = 450;
  const cy = 450;

  for (let i = 0; i < playerCount; i++) {
    const angle = (Math.PI * 2 * i) / playerCount - Math.PI / 2;
    const x = cx + radius * Math.cos(angle);
    const y = cy + radius * Math.sin(angle);

    const seat = {
      index: i,
      x,
      y,
      hand: [],
      active: true,
      folded: false,
      bet: 0,
      stack: 100
    };
    seats.push(seat);

    const el = document.createElement("div");
    el.className = "seat";
    el.style.left = x + "px";
    el.style.top = y + "px";
    el.id = "seat-" + i;
    el.textContent = positionName(i, playerCount);

    const stack = document.createElement("div");
    stack.className = "stack";
    stack.id = "stack-" + i;
    stack.textContent = "$100";
    el.appendChild(stack);

    container.appendChild(el);
  }
}

function positionName(i, n) {
  if (n === 9) {
    const map9 = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"];
    return map9[i];
  }
  if (n === 8) {
    return ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","BB"][i] || "";
  }
  if (n === 7) {
    return ["UTG","UTG+1","UTG+2","LJ","HJ","BTN","BB"][i] || "";
  }
  if (n === 6) {
    return ["UTG","HJ","CO","BTN","SB","BB"][i] || "";
  }
  return "P" + (i + 1);
}

// ============================================================================
//  BOARD RENDERING
// ============================================================================
function renderBoard() {
  boardEl.innerHTML = "";
  for (let c of board) {
    boardEl.appendChild(makeCardElement(c, true));
  }
}

function makeCardElement(card, small=false) {
  const el = document.createElement("div");
  el.className = "card";
  if (small) el.style.width = "80px";

  const rank = document.createElement("div");
  rank.className = "rank";
  rank.textContent = card.value;
  rank.classList.add(card.suit === "♥" || card.suit === "♦" ? "red" : "black");

  const suit = document.createElement("div");
  suit.className = "suit";
  suit.textContent = card.suit;

  el.appendChild(rank);
  el.appendChild(suit);
  return el;
}

// ============================================================================
//  HERO CARDS
// ============================================================================
function renderHeroCards() {
  heroCardsEl.innerHTML = "";
  for (let c of heroHand) {
    heroCardsEl.appendChild(makeCardElement(c));
  }
}

// ============================================================================
//  LOGGING
// ============================================================================
function logAction(text, ok=false) {
  const row = document.createElement("div");
  row.className = "item";
  const left = document.createElement("div");
  left.textContent = text;
  const right = document.createElement("div");
  right.textContent = ok ? "OK" : "";
  if (ok) right.className = "ok";
  row.appendChild(left);
  row.appendChild(right);
  logEl.appendChild(row);
  logEl.scrollTop = logEl.scrollHeight;
}

// ============================================================================
//  RESET UI
// ============================================================================
function resetUI() {
  board = [];
  heroHand = [];
  pot = 0;
  street = "preflop";

  document.getElementById("streetDisplay").textContent = "Preflop";
  document.getElementById("potDisplay").textContent = "Pot: 0";
  document.getElementById("sprDisplay").textContent = "SPR: —";
  boardEl.innerHTML = "";
  heroCardsEl.innerHTML = "";
}
<script>
// ============================================================================
//  FIXED HAND EVALUATOR (7-CARD, COMPLETE, CORRECT)
//  Replaces the previous broken evaluator
// ============================================================================

function evaluateHand(cards) {
    // cards = array of card objects: {value:'A', suit:'♠'}

    const rankMap = {
        "2":2, "3":3, "4":4, "5":5, "6":6, "7":7, "8":8, "9":9,
        "T":10, "J":11, "Q":12, "K":13, "A":14
    };

    // Extract numeric ranks and suits
    const ranks = cards.map(c => rankMap[c.value]).sort((a,b)=>a-b);
    const suits = cards.map(c => c.suit);

    // Count occurrences of ranks
    const count = {};
    const suitCount = {};
    for (let i = 0; i < ranks.length; i++) {
        count[ranks[i]] = (count[ranks[i]] || 0) + 1;
        suitCount[suits[i]] = (suitCount[suits[i]] || 0) + 1;
    }

    // Detect flush suit if any
    let flushSuit = null;
    for (let s in suitCount) {
        if (suitCount[s] >= 5) flushSuit = s;
    }

    // Gather flush cards
    let flushCards = [];
    if (flushSuit) {
        flushCards = cards
            .filter(c => c.suit === flushSuit)
            .map(c => rankMap[c.value])
            .sort((a,b)=>b-a)
            .slice(0, 5);
    }

    // Straight detection helper
    function straightHigh(r) {
        let u = [...new Set(r)].sort((a,b)=>a-b);

        // wheel case A-2-3-4-5
        if (u.includes(14) && u.includes(5) &&
            u.includes(4) && u.includes(3) && u.includes(2)) {
            return 5;
        }

        for (let i = u.length - 1; i >= 4; i--) {
            if (u[i] - u[i-4] === 4) {
                return u[i];
            }
        }
        return null;
    }

    const straight = straightHigh(ranks);

    // Straight flush detection
    let straightFlush = null;
    if (flushSuit) {
        const suitedRanks = cards
            .filter(c => c.suit === flushSuit)
            .map(c => rankMap[c.value]);
        straightFlush = straightHigh(suitedRanks);
    }

    // Group ranks by count
    const groups = {};
    for (let r in count) {
        let n = count[r];
        if (!groups[n]) groups[n] = [];
        groups[n].push(Number(r));
    }
    if (groups[4]) groups[4].sort((a,b)=>b-a);
    if (groups[3]) groups[3].sort((a,b)=>b-a);
    if (groups[2]) groups[2].sort((a,b)=>b-a);

    // RETURN FORMAT:
    // { rank: 1..9, kickers: [numbers...] }
    //
    // Where:
    // 9 = Straight flush
    // 8 = Quads
    // 7 = Full house
    // 6 = Flush
    // 5 = Straight
    // 4 = Trips
    // 3 = Two pair
    // 2 = Pair
    // 1 = High card

    // 9. Straight Flush
    if (straightFlush) {
        return { rank: 9, kickers: [straightFlush] };
    }

    // 8. Four of a Kind
    if (groups[4] && groups[4].length) {
        const quad = groups[4][0];
        const kicker = ranks.filter(r => r !== quad).pop();
        return { rank: 8, kickers: [quad, kicker] };
    }

    // 7. Full House
    if (groups[3] && groups[3].length &&
        (groups[2] && groups[2].length || groups[3].length > 1)) {
        const trips = groups[3][0];
        const pair = groups[2]?.[0] || groups[3][1];
        return { rank: 7, kickers: [trips, pair] };
    }

    // 6. Flush
    if (flushCards.length >= 5) {
        return { rank: 6, kickers: flushCards };
    }

    // 5. Straight
    if (straight) {
        return { rank: 5, kickers: [straight] };
    }

    // 4. Trips
    if (groups[3] && groups[3].length) {
        const t = groups[3][0];
        const k = ranks.filter(r => r !== t).slice(-2).reverse();
        return { rank: 4, kickers: [t, ...k] };
    }

    // 3. Two Pair
    if (groups[2] && groups[2].length >= 2) {
        const [hi, lo] = groups[2].slice(0,2);
        const k = ranks.filter(r => r !== hi && r !== lo).pop();
        return { rank: 3, kickers: [hi, lo, k] };
    }

    // 2. One Pair
    if (groups[2] && groups[2].length >= 1) {
        const p = groups[2][0];
        const k = ranks.filter(r => r !== p).slice(-3).reverse();
        return { rank: 2, kickers: [p, ...k] };
    }

    // 1. High Card
    return { rank: 1, kickers: ranks.slice(-5).reverse() };
}
<script>
// ============================================================================
//  BOARD TEXTURE CLASSIFICATION ENGINE
//  Used to select correct JSON ranges for flop/turn/river
// ============================================================================

function classifyBoardTexture(board) {
    if (board.length < 3) return "unknown";

    const rankMap = {
        "2":2,"3":3,"4":4,"5":5,"6":6,"7":7,
        "8":8,"9":9,"T":10,"J":11,"Q":12,"K":13,"A":14
    };

    const suits = board.map(c => c.suit);
    const ranks = board.map(c => rankMap[c.value]).sort((a,b)=>a-b);

    // Suit counts
    const suitCount = {};
    suits.forEach(s => suitCount[s] = (suitCount[s] || 0) + 1);

    // Rank counts
    const rankCount = {};
    ranks.forEach(r => rankCount[r] = (rankCount[r] || 0) + 1);

    const pairs = Object.values(rankCount).filter(n => n === 2).length;
    const trips = Object.values(rankCount).filter(n => n === 3).length;

    // ============================================================
    // SUIT TEXTURE
    // ============================================================
    const isMonotone = Object.values(suitCount).some(n => n >= 3);
    const isTwoTone = Object.values(suitCount).some(n => n === 2);
    const isRainbow = !isMonotone && !isTwoTone;

    // ============================================================
    // PAIRING TEXTURE
    // ============================================================
    const isPaired = pairs === 1;
    const isDoublePaired = pairs >= 2;
    const isTrips = trips === 1;

    // ============================================================
    // HIGH / MID / LOW TEXTURE
    // ============================================================
    const highCards = ranks.filter(r => r >= 11).length; // J or higher
    const lowCards = ranks.filter(r => r <= 7).length;

    let highStructure = "";
    if (highCards >= 2) highStructure = "high";
    else if (ranks[2] <= 9) highStructure = "low";
    else highStructure = "mid";

    // ============================================================
    // CONNECTEDNESS
    // ============================================================
    function isConnected(r) {
        // Example: 9-8-7 or Q-J-T etc
        return (r[2] - r[0] <= 4);
    }
    const connected = isConnected(ranks);

    // ============================================================
    // OVERRIDE SPECIAL CASES
    // ============================================================
    if (isMonotone) {
        return highStructure + "_monotone";
    }
    if (isTrips) {
        return "trips";
    }
    if (isDoublePaired) {
        return "double_paired";
    }
    if (isPaired) {
        return highStructure + "_paired";
    }
    if (connected) {
        return highStructure + "_connected";
    }

    // ============================================================
    // DEFAULTS
    // ============================================================
    if (isRainbow) return highStructure + "_rainbow";
    if (isTwoTone) return highStructure + "_twotone";

    return "generic";
}
</script>
<script>
// ============================================================================
//  SOLVER ACTION ENGINE — Reads JSON/GTO Files & Makes NPC Decisions
// ============================================================================

// MASTER: Which JSON folder to load based on board texture
function getSolverTextureFolder(board) {
    if (board.length < 3) return "preflop";

    const tag = classifyBoardTexture(board); // from Part 4.2

    // Map texture → folder name
    const map = {
        // High card A/K/Q boards
        "high_connected": "high_connected",
        "high_rainbow": "high_rainbow",
        "high_twotone": "high_twotone",
        "high_paired": "high_paired",
        "high_monotone": "high_monotone",

        // Middle card boards
        "mid_connected": "mid_connected",
        "mid_rainbow": "mid_rainbow",
        "mid_twotone": "mid_twotone",
        "mid_paired": "mid_paired",
        "mid_monotone": "mid_monotone",

        // Baby boards
        "low_connected": "low_connected",
        "low_rainbow": "low_rainbow",
        "low_twotone": "low_twotone",
        "low_paired": "low_paired",
        "low_monotone": "low_monotone",

        // Special shapes
        "double_paired": "double_paired",
        "trips": "trips"
    };

    return map[tag] || "generic";
}

// MASTER: Which JSON file to load based on position + hero hole cards
function getSolverNodeFile(st, idx) {
    const p = st.players[idx];

    // Position groupings
    const pos = p.position;
    let posGroup = "";

    if (["UTG", "UTG+1", "UTG+2"].includes(pos)) posGroup = "early";
    else if (["LJ", "HJ"].includes(pos)) posGroup = "mid";
    else if (["CO"].includes(pos)) posGroup = "co";
    else if (["BTN"].includes(pos)) posGroup = "btn";
    else if (["SB"].includes(pos)) posGroup = "sb";
    else if (["BB"].includes(pos)) posGroup = "bb";

    // Hand code: AKo, AQo, T8s, 55, etc.
    function holeCode(hole) {
        const r = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
        const sorted = hole.slice().sort(
          (a,b) => r.indexOf(a.rank) - r.indexOf(b.rank)
        );
        const A = sorted[0], B = sorted[1];

        let code = A.rank + B.rank;

        if (A.rank === B.rank) return code; // Pairs

        if (A.suit === B.suit) return code + "s";
        return code + "o";
    }

    const code = holeCode(p.hole);

    // Preflop → use preflop folder
    if (st.street === 0) {
        return `ranges/preflop/${posGroup}/${code}.json`;
    }

    // Postflop → need texture + file
    const folder = getSolverTextureFolder(st.board);
    return `ranges/${folder}/${posGroup}/${code}.json`;
}

// ================================================================
//  JSON FILE LOADER (ASYNC CACHE)
// ================================================================
const RangeCache = {};

async function loadRangeJSON(path) {
    if (RangeCache[path]) return RangeCache[path];

    try {
        const res = await fetch(path);
        if (!res.ok) throw new Error("Missing file");
        const json = await res.json();
        RangeCache[path] = json;
        return json;
    } catch (e) {
        console.warn("⚠ Solver file missing:", path);
        RangeCache[path] = null;
        return null;
    }
}

// ============================================================================
// NPC ACTION SELECTOR (GTO-Driven)
// ============================================================================
async function npcSolverAction(st, idx) {
    const p = st.players[idx];

    const path = getSolverNodeFile(st, idx);
    const data = await loadRangeJSON(path);

    if (!data) {
        // Fallback heuristic if no file exists
        return fallbackHeuristic(st, idx);
    }

    // Data structure:
    // {
    //   "texture": "ace_high",
    //   "position": "BTN",
    //   "strategy": {
    //      "check": { frequency: 0.40, hands_check_raise:[], hands_call_vs_small_bet:[] },
    //      "bet_small": { frequency: 0.30 },
    //      "bet_big": { frequency: 0.10 },
    //      "check_raise": { frequency: 0.20 }
    //   }
    // }

    const strat = data.strategy;
    if (!strat) return fallbackHeuristic(st, idx);

    // Total frequency mass
    const entries = Object.entries(strat); // [ ["check", {...}], ["bet_small",{...}] ... ]

    const weights = entries.map(([move,obj]) => obj.frequency || 0);
    const sum = weights.reduce((a,b)=>a+b,0) || 1;

    const rand = Math.random();
    let accum = 0;

    for (let i = 0; i < entries.length; i++) {
        accum += weights[i] / sum;
        if (rand <= accum) {
            return mapSolverMoveToEngine(st, idx, entries[i][0], entries[i][1]);
        }
    }

    // fallback last
    const last = entries[entries.length-1];
    return mapSolverMoveToEngine(st, idx, last[0], last[1]);
}

// ============================================================================
// MAP SOLVER TAG → ENGINE ACTION
// ============================================================================
function mapSolverMoveToEngine(st, idx, tag, obj) {
    const pot = Math.max(1, st.pot);
    const current = st.currentBet;

    switch(tag) {
        case "check":
            return { type:"check" };

        case "call":
            return { type:"call" };

        case "fold":
            return { type:"fold" };

        case "bet_small":
            return { type:"bet", size: pot * 0.33 };

        case "bet_big":
            return { type:"bet", size: pot * 0.66 };

        case "bet_over":
            return { type:"bet", size: pot * 1.25 };

        case "raise_small":
            return { type:"raise", size: current + (pot * 0.5) };

        case "raise_big":
            return { type:"raise", size: current + pot };

        case "jam":
        case "allin":
            return { type:"jam" };

        case "check_raise":
            return { type:"raise", size: current + pot };

        default:
            console.warn("Unknown solver tag:", tag);
            return { type:"check" };
    }
}

// ============================================================================
// FALLBACK HEURISTIC IF NO SOLVER FILE EXISTS
// ============================================================================
function fallbackHeuristic(st, idx) {
    const need = GTOS.Engine.toCall(st, idx);
    const pot = st.pot;

    // super simple fallback
    if (need > 0) {
        if (Math.random() < 0.25) return { type:"fold" };
        if (Math.random() < 0.70) return { type:"call" };
        return { type:"raise", size: need + pot * 0.5 };
    }

    if (Math.random() < 0.25) return { type:"bet", size: pot * 0.33 };
    return { type:"check" };
}

// ============================================================================
// PATCH NPC ENGINE TO USE SOLVER
// ============================================================================
GTOS.Engine.npcChooseAction = function(st, idx) {
    return npcSolverAction(st, idx);
};
</script>
<script>
// ============================================================================
// PART 5 — TRUE SOLVER-BASED HERO EV LOSS CALCULATION
// ============================================================================
//
// For nodeId and position, we:
//   1. Load solver JSON file (same as NPCs)
//   2. Identify which solver action bucket matches hero's chosen action
//   3. Compare EV(heroAction) - EV(optimalAction)
//   4. Add to cumulative EV loss
//   5. Convert final EV loss → percentage score
//
// ============================================================================

// Convert engine action → solver bucket tags
function mapHeroActionToSolverTag(action, st) {
    const pot = Math.max(1, st.pot);
    const curr = st.currentBet;

    switch(action.type) {
        case "fold":
            return "fold";

        case "check":
            return "check";

        case "call":
            return "call";

        case "bet":
            const frac = action.size / pot;
            if (frac <= 0.4) return "bet_small";
            if (frac <= 0.9) return "bet_big";
            return "bet_over";

        case "raise":
            const diff = action.size - curr;
            if (diff <= pot * 0.6) return "raise_small";
            return "raise_big";

        case "jam":
            return "jam";
    }
    return "check";
}

// Find the solver's best EV action
function solverBestActionTag(strategy) {
    let bestTag = null;
    let bestEV = -999;

    for (const [tag, obj] of Object.entries(strategy)) {
        const ev = obj.EV ?? obj.ev ?? 0;
        if (ev > bestEV) {
            bestEV = ev;
            bestTag = tag;
        }
    }
    return bestTag;
}

// Get solver EV value for hero action
function solverEVForTag(strategy, tag) {
    if (!strategy[tag]) return null;
    return strategy[tag].EV ?? strategy[tag].ev ?? null;
}

// Load solver node file for hero
async function loadHeroSolverFile(st) {
    const idx = st.heroIndex;
    const path = getSolverNodeFile(st, idx);
    return await loadRangeJSON(path);
}

// ============================================================================
// MAIN: Compute EV penalty from solver ranges
// ============================================================================
async function computeSolverEVLoss(st, heroAction) {
    const solverData = await loadHeroSolverFile(st);

    if (!solverData || !solverData.strategy) {
        // fallback small heuristic penalty
        return 0.15;
    }

    const strat = solverData.strategy;

    const heroTag = mapHeroActionToSolverTag(heroAction, st);
    const bestTag = solverBestActionTag(strat);

    const heroEV = solverEVForTag(strat, heroTag);
    const bestEV = solverEVForTag(strat, bestTag);

    if (heroEV == null || bestEV == null) {
        return 0.25; // fallback mild penalty
    }

    const diff = bestEV - heroEV;

    // Normalize penalty
    const penalty = Math.max(0, Math.min(1.5, diff));

    return penalty;
}

// ============================================================================
// Convert EV loss → score %
function computeFinalScore(evLoss) {
    // Commercial trainers: EV loss commonly 0–1.5 range
    const pct = Math.max(0, Math.min(100, Math.round(100 - evLoss * 65)));

    let verdict = "Needs Work";
    if (pct >= 90) verdict = "Excellent";
    else if (pct >= 75) verdict = "Strong";
    else if (pct >= 50) verdict = "Okay";

    return {
        pct,
        verdict,
        detail: `Total EV loss ≈ ${evLoss.toFixed(2)}`
    };
}

// Expose globally for heroAct usage
GTOS.Eval.computeSolverEVLoss = computeSolverEVLoss;
GTOS.Eval.computeFinalScore   = computeFinalScore;

</script>
<script>
// ============================================================================
// PART 6 — Updated heroAct() using TRUE SOLVER EV grading
// ============================================================================

GTOS.Engine.heroAct = async function(st, action) {
    const idx = st.heroIndex;
    const seatNode = st.seatNodes[idx];

    // Highlight hero acting
    if (seatNode) {
        seatNode.classList.add("acting");
        setTimeout(() => seatNode.classList.remove("acting"), 400);
    }

    // ===========================================
    // 1. Compute solver EV loss for hero's action
    // ===========================================
    let penalty = 0;
    try {
        penalty = await GTOS.Eval.computeSolverEVLoss(st, action);
    } catch (e) {
        console.log("Solver EV calc error:", e);
        penalty = 0.20; // mild fallback
    }

    st.evLoss = (st.evLoss || 0) + penalty;

    // ===========================================
    // 2. Apply the hero's action
    // ===========================================
    switch(action.type) {
        case GTOS.ACTION.FOLD:
            st.heroFolded = true;
            GTOS.Engine.applyFold(st, idx);
            GTOS.Render.updateStacks(st);
            GTOS.Render.renderHUD(st);
            return GTOS.Engine.finishHandEarly(st);

        case GTOS.ACTION.CHECK:
            GTOS.Render.betPlate(seatNode, "CHECK");
            GTOS.Render.setSeatLabel(st, idx, "CHECK");
            break;

        case GTOS.ACTION.CALL:
            GTOS.Engine.applyCall(st, idx);
            break;

        case GTOS.ACTION.BET:
        case GTOS.ACTION.RAISE:
            GTOS.Engine.applyBetOrRaise(st, idx, action.size);
            break;

        case GTOS.ACTION.JAM:
            GTOS.Engine.applyJam(st, idx);
            break;
    }

    GTOS.Render.updateStacks(st);
    GTOS.Render.renderHUD(st);

    st.actedThisStreet.add(idx);
    st.interacted.add(idx);

    // ===========================================
    // 3. Move to next active player
    // ===========================================
    st.actionIndex = st.nextActive(idx);

    // ===========================================
    // 4. Continue action flow
    // ===========================================
    GTOS.Engine.continueActionFlow(st);
};
</script>
<div id="result" class="result">
  <div class="big-score" id="scorePct"></div>
  <div id="scoreVerdict" style="font-weight:800;margin-top:4px"></div>
  <div id="scoreDetail" style="font-size:12px;margin-top:6px;opacity:.9"></div>

  <div id="evBreakdown" style="font-size:12px;margin-top:12px;line-height:1.45;display:none">
    <div><b>Your Action:</b> <span id="heroActionTxt"></span></div>
    <div><b>Solver Best:</b> <span id="solverBestActionTxt"></span></div>
    <div><b>EV (Hero Action):</b> <span id="heroEvTxt"></span></div>
    <div><b>EV (Optimal):</b> <span id="bestEvTxt"></span></div>
    <div><b>EV Loss:</b> <span id="evLossTxt"></span></div>

    <button id="viewSolverBtn" class="ghost" 
      style="margin-top:10px;padding:8px 10px">
      View Solver Recommendation
    </button>
  </div>
</div>
<div id="solverPopup" 
     style="display:none;position:fixed;left:50%;top:50%;
            transform:translate(-50%,-50%);
            background:#0f172a;border:1px solid #334155;
            padding:20px;border-radius:16px;z-index:9999;
            width:340px;max-height:420px;overflow:auto;
            color:#e2e8f0">
  <div style="font-weight:900;margin-bottom:10px;color:#c7d2fe">
    Solver Recommendation
  </div>

  <div id="solverPopupBody" style="font-size:13px;line-height:1.4"></div>

  <button id="closeSolverBtn" style="margin-top:14px"
          class="ghost">Close</button>
</div>
<script>
// ============================================================================
// PART 7 — Solver Recommendation Viewer / EV Breakdown Module
// ============================================================================

GTOS.UI = GTOS.UI || {};

GTOS.UI.showEvBreakdown = function(data) {
  document.getElementById("evBreakdown").style.display = "block";
  document.getElementById("heroActionTxt").textContent = data.heroAction;
  document.getElementById("solverBestActionTxt").textContent = data.bestAction;
  document.getElementById("heroEvTxt").textContent = data.heroEV.toFixed(3);
  document.getElementById("bestEvTxt").textContent = data.bestEV.toFixed(3);
  document.getElementById("evLossTxt").textContent = data.evLoss.toFixed(3);

  // Store full solver node for popup
  GTOS.UI._lastSolverNode = data.node;
};

GTOS.UI.renderSolverPopup = function() {
  const node = GTOS.UI._lastSolverNode;
  if (!node) return;

  let html = "";
  for (const [tag, obj] of Object.entries(node.strategy)) {
    const ev = obj.EV ?? obj.ev ?? 0;
    const freq = obj.freq ?? obj.frequency ?? 0;

    html += `
      <div style="border-bottom:1px solid #334155;padding:6px 0">
        <div><b>${tag}</b> — EV ${ev.toFixed(3)}</div>
        <div>Freq: ${(freq * 100).toFixed(1)}%</div>
        ${obj.size ? `<div>Size: ${obj.size} BB</div>` : ""}
      </div>
    `;
  }

  document.getElementById("solverPopupBody").innerHTML = html;
  document.getElementById("solverPopup").style.display = "block";
};

document.getElementById("viewSolverBtn").onclick = () => {
  GTOS.UI.renderSolverPopup();
};

document.getElementById("closeSolverBtn").onclick = () => {
  document.getElementById("solverPopup").style.display = "none";
};

// ============================================================================
// Modify Result Display to Use Solver EV Breakdown
// ============================================================================
GTOS.Render.showResult = function(pct, verdict, detail, evData) {
  const box = GTOS.dom.result;
  box.style.display = "block";

  GTOS.dom.scorePct.textContent = pct + "%";
  GTOS.dom.scoreVerd.textContent = verdict;
  GTOS.dom.scoreDetail.textContent = detail;

  if (evData) GTOS.UI.showEvBreakdown(evData);

  GTOS.dom.scorePct.style.color = pct >= 50 ? "var(--good)" : "var(--bad)";
};

// ============================================================================
// Hook solver data into heroAct’s finish step
// ============================================================================
GTOS.Engine.finalizeHeroResult = function(st, lastAction, solverResult) {
  const score = GTOS.Eval.computeFinalScore(st.evLoss);

  const evBestTag = solverResult.bestTag || "N/A";
  const evHeroTag = solverResult.heroTag || "N/A";
  const heroEV    = solverResult.heroEV ?? 0;
  const bestEV    = solverResult.bestEV ?? 0;

  GTOS.Render.showResult(score.pct, score.verdict, score.detail, {
    heroAction: evHeroTag,
    bestAction: evBestTag,
    heroEV: heroEV,
    bestEV: bestEV,
    evLoss: score.detail ? st.evLoss : 0,
    node: solverResult.node
  });
};

</script>
<script>
// ============================================================================
// PART 8 — FULL SOLVER TREE INTEGRATION
// Node path builder for preflop → flop → turn → river
// ============================================================================

GTOS.SolverPath = {};

/* --------------------------------------------------------------
   1. Preflop Position → Directory Name
-------------------------------------------------------------- */
GTOS.SolverPath.preflopDir = function(pos) {
  // Already matches your folder names exactly
  return pos.replace("+", "");
};

/* --------------------------------------------------------------
   2. Flop Texture Bucket Determination
-------------------------------------------------------------- */
GTOS.SolverPath.getFlopBucket = function(board) {
  if (!board || board.length < 3) return "unknown";

  const ranks = board.map(c=>c.rank);
  const suits = board.map(c=>c.suit);

  const uniqueSuits = new Set(suits).size;
  const highCount = ranks.filter(r => ["A","K","Q","J","T"].includes(r)).length;

  // SUITEDNESS
  if (uniqueSuits === 1) return "monotone";
  if (uniqueSuits === 2) return "two_tone";
  if (uniqueSuits === 3) return "rainbow";

  // HIGH CARD HEAVY
  if (highCount >= 2) return "highcard";
  if (highCount === 1) return "mid";

  return "low";
};

/* --------------------------------------------------------------
   3. Turn Bucket — based on flop bucket + turn rank/suit
-------------------------------------------------------------- */
GTOS.SolverPath.getTurnBucket = function(board) {
  if (board.length < 4) return "unknown";

  const turn = board[3];
  const ranks = board.map(c=>c.rank);
  const suits = board.map(c=>c.suit);

  const uniqueSuits = new Set(suits).size;
  const highCount = ranks.filter(r => ["A","K","Q","J","T"].includes(r)).length;

  if (uniqueSuits === 1) return "mono_turn";
  if (uniqueSuits === 2) return "two_tone_turn";

  if (highCount >= 3) return "ace_high";
  if (highCount === 2) return "high";
  if (highCount === 1) return "mid";

  return "low";
};

/* --------------------------------------------------------------
   4. River Bucket — rank density + draws completed
-------------------------------------------------------------- */
GTOS.SolverPath.getRiverBucket = function(board) {
  if (board.length < 5) return "unknown";

  const ranks = board.map(c=>c.rank);
  const suits = board.map(c=>c.suit);

  const uniqueSuits = new Set(suits).size;

  // Flush complete?
  if (uniqueSuits === 1) return "flush_complete";

  // Paired?
  const count = {};
  ranks.forEach(r=>count[r]=(count[r]||0)+1);
  if (Object.values(count).includes(3)) return "trip_board";
  if (Object.values(count).includes(2)) return "paired_board";

  // Broadway heavy?
  const highCount = ranks.filter(r=>["A","K","Q","J","T"].includes(r)).length;
  if (highCount >= 3) return "broadway";
  if (highCount === 2) return "high";

  return "low";
};

/* --------------------------------------------------------------
   5. MAIN MAPPER — Returns solver file path for this node
-------------------------------------------------------------- */
window.getSolverNodeFile = function(st, idx) {
  const pos = st.players[idx].position;
  const street = st.street;

  if (street === GTOS.STREET.PREFLOP) {
    const dir = GTOS.SolverPath.preflopDir(pos);
    return `solver/preflop/${dir}/node.json`;
  }

  if (street === GTOS.STREET.FLOP) {
    const bucket = GTOS.SolverPath.getFlopBucket(st.board);
    return `solver/flop/${pos}/${bucket}/node.json`;
  }

  if (street === GTOS.STREET.TURN) {
    const bucket = GTOS.SolverPath.getTurnBucket(st.board);
    return `solver/turn/${pos}/${bucket}/node.json`;
  }

  if (street === GTOS.STREET.RIVER) {
    const bucket = GTOS.SolverPath.getRiverBucket(st.board);
    return `solver/river/${pos}/${bucket}/node.json`;
  }

  return null;
};

/* --------------------------------------------------------------
   6. Load the JSON file for the node (async)
-------------------------------------------------------------- */
window.loadRangeJSON = async function(path) {
  try {
    const res = await fetch(path);
    if (!res.ok) throw new Error("File not found: " + path);
    return await res.json();
  } catch (e) {
    console.warn("Solver file load error:", e);
    return null;
  }
};

</script>
<script>
// ============================================================================
// PART 9 — FULL ACTION-SEQUENCE SOLVER TREE MAPPING
// ============================================================================
//
// This system tracks: street → texture bucket → action history
// and maps to a true solver node folder path.
//
// Example final path:
//   solver/flop/UTG/high/check/bet_small/call/node.json
//
// ============================================================================

// Track action sequence for each street
GTOS.SolverPath.actionHistory = {
    preflop: [],
    flop: [],
    turn: [],
    river: []
};

// Reset at new hand
GTOS.SolverPath.resetHistory = function() {
    this.preflop = [];
    this.flop = [];
    this.turn = [];
    this.river = [];
};

// Called inside heroAct and npcAct
GTOS.SolverPath.recordAction = function(street, tag) {
    switch(street) {
        case GTOS.STREET.PREFLOP: this.preflop.push(tag); break;
        case GTOS.STREET.FLOP:    this.flop.push(tag); break;
        case GTOS.STREET.TURN:    this.turn.push(tag); break;
        case GTOS.STREET.RIVER:   this.river.push(tag); break;
    }
};

// Convert action history into a folder structure
GTOS.SolverPath.actionsToPath = function(list) {
    if (!list || list.length === 0) return "";
    return list.join("/") + "/";
};

// Override solver file mapping to include history
window.getSolverNodeFile = function(st, idx) {
    const pos = st.players[idx].position;

    // NEW: history
    const hist = GTOS.SolverPath;

    // Determine bucket per street
    let bucket = "unknown";
    let base = "solver";

    if (st.street === GTOS.STREET.PREFLOP) {
        const dir = GTOS.SolverPath.preflopDir(pos);
        const actionPath = GTOS.SolverPath.actionsToPath(hist.preflop);
        return `${base}/preflop/${dir}/${actionPath}node.json`;
    }

    if (st.street === GTOS.STREET.FLOP) {
        bucket = GTOS.SolverPath.getFlopBucket(st.board);
        const actionPath = GTOS.SolverPath.actionsToPath(hist.flop);
        return `${base}/flop/${pos}/${bucket}/${actionPath}node.json`;
    }

    if (st.street === GTOS.STREET.TURN) {
        bucket = GTOS.SolverPath.getTurnBucket(st.board);
        const actionPath = GTOS.SolverPath.actionsToPath(hist.turn);
        return `${base}/turn/${pos}/${bucket}/${actionPath}node.json`;
    }

    if (st.street === GTOS.STREET.RIVER) {
        bucket = GTOS.SolverPath.getRiverBucket(st.board);
        const actionPath = GTOS.SolverPath.actionsToPath(hist.river);
        return `${base}/river/${pos}/${bucket}/${actionPath}node.json`;
    }

    return null;
};

</script>
<script>
// ============================================================================
// PART 10A — Extract Solver Action Sizes
// ============================================================================
//
// Input: node.strategy
// Output: size in chips (converted from fraction or multiplier)
// ============================================================================

GTOS.Solver = GTOS.Solver || {};

GTOS.Solver.getActionSize = function(st, obj) {
    if (!obj) return null;

    const pot = Math.max(1, st.pot);
    const curr = st.currentBet;

    // If solver gives exact chip count
    if (obj.chips) return obj.chips;

    // If solver provides percentage of pot
    if (obj.size && obj.size <= 3 &&
        obj.size > 0 && obj.size < 3) 
    {
        return pot * obj.size;
    }

    // If solver gives multiplier for raises
    if (obj.mult && obj.mult > 0) {
        return curr + obj.mult * pot;
    }

    // If solver gives absolute BB size
    if (obj.bb_size) {
        return obj.bb_size * st.bb;
    }

    return null;
};
</script>
<script>
function mapSolverMoveToEngine(st, idx, tag, obj) {

    const size = GTOS.Solver.getActionSize(st, obj);
    const pot = Math.max(1, st.pot);
    const curr = st.currentBet;

    switch(tag) {

        case "check":
            return { type:"check" };

        case "call":
            return { type:"call" };

        case "fold":
            return { type:"fold" };

        case "bet_33":
        case "bet_50":
        case "bet_66":
        case "bet_75":
        case "bet_100":
        case "bet_pot":
            return { type:"bet", size: size ?? pot * 0.33 };

        case "raise_small":
        case "raise_big":
        case "raise_over":
            return { type:"raise", size: size ?? curr + pot };

        case "jam":
        case "allin":
            return { type:"jam" };

        case "check_raise":
            return { type:"raise", size: size ?? curr + pot };

        default:
            console.warn("Unknown solver tag:", tag);
            return { type:"check" };
    }
}
</script>
<script>
// ============================================================================
// PART 10C — Dynamic Solver-Based Hero Buttons
// ============================================================================

GTOS.UI.updateHeroButtons = function(st, node) {
    const bar = document.getElementById("actionBar");
    if (!bar || !node || !node.strategy) return;

    const strat = node.strategy;
    const pot   = Math.max(1, st.pot);
    const curr  = st.currentBet;

    // Clear bar
    bar.innerHTML = "";

    for (const [tag, obj] of Object.entries(strat)) {
        const btn = document.createElement("button");
        btn.className = "actionBtn";

        let label = tag;
        let action = null;
        const size = GTOS.Solver.getActionSize(st, obj);

        // Map to actual engine actions
        if (tag === "check") {
            label = "Check";
            action = { type:"check" };

        } else if (tag === "call") {
            label = "Call";
            action = { type:"call" };

        } else if (tag.startsWith("bet")) {
            label = `Bet ${Math.round((size/pot)*100)}%`;
            action = { type:"bet", size };

        } else if (tag.startsWith("raise")) {
            label = `Raise ${Math.round(size)}`;
            action = { type:"raise", size };

        } else if (tag === "jam" || tag === "allin") {
            label = "Jam";
            action = { type:"jam" };
        }

        if (action) {
            btn.textContent = label;
            btn.onclick = () => {
                GTOS.Engine.heroAct(st, action);
            };
            bar.appendChild(btn);
        }
    }
};
</script>
  </script>
</body>
</html>



