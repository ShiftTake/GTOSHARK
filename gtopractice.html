<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>GTO Shark • Live Practice v8.5</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#0b1020; --ink:#e2e8f0; --muted:#94a3b8;
      --indigo:#4f46e5; --teal:#14b8a6;
      --hero-glow:rgba(34,197,94,.9);
      --act-glow:rgba(251,191,36,.95);
      --ring:rgba(79,70,229,.42);
      --glass:rgba(2,6,23,.65);
    }
    body {
      margin:0; font-family:"Inter",sans-serif; color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% -10%, rgba(79,70,229,.25), transparent 60%),
        radial-gradient(1200px 800px at 120% 10%, rgba(20,184,166,.20), transparent 60%),
        #0b1020;
    }
    body::before {
      content:""; position:fixed; inset:0; pointer-events:none; z-index:-1;
      opacity:.18; mix-blend-mode:soft-light;
      background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsSAAALEgHS3X78AAABmElEQVRoge2ZzU7CMBjGf0c8XrY8b7Rs2QkYkGq4b0Gq1mVw9Xgqk4o5wC4WmG9m8rJgIh2S2g6M6dD9q3Q2Eo2WwVb7v9WQK7rHcKf8Lw+1yX9q0y0K4z3lK0kz5p7gkq1gS9o1M7wZkX4gQq3g3l1e2N5v2S8J7Q2o8g4o8RkJ9p8a8x0Wwqg1s0w2WgH4w0yqJx1Jw4y/6c0CwJYwY7cCkM6c2C2JgJ2oS8z0H2Zl3J2g5g8G2n6gG9w8nQKv2hK3sH7mX2Xw3f0s3mVJQ1l5l3Vtsq7bZpO1o6H1o4S6Uj0J3Y0/0c4Aqzv3p5KJ9GQY6Ww6kqzJ9lM6OaXoV4QF6xgq6m5z+6M9zqfC0t2Sx4GvYzN1o6L2E5Wm8z7Gk2b5zqV6v4D5G8Qxk9Qyq9wS9r9e9sGxk0f3v6wZcU1b3e6sAq8Y3S9Q9M6KJfYbJ6a9K4eGkq8Xj8s8h1Y1E3p7a7r4yXv8p7Kj0oXk7g5Yg0Ww4cZ9M1v8i6c2q2pQmSYQmSYQmSYQmSYQmSYQmSYQmScJ/0C0r7N4M2zq9oAAAAASUVORK5CYII=");
      background-size:256px 256px;
    }

    .app{display:grid;grid-template-columns:minmax(820px,1fr)380px;gap:16px;align-items:start;padding:16px}
    @media(max-width:1200px){.app{grid-template-columns:1fr}.sidebar{order:3}}
    .table-wrap{display:flex;justify-content:center}

    .table-ring{
      width:960px; height:960px; border-radius:50%; position:relative;
      background:
        radial-gradient(ellipse at 50% 45%, rgba(10,20,35,.9) 0%, rgba(9,18,32,.82) 54%, rgba(8,16,30,.72) 74%, rgba(7,14,28,.56) 100%),
        radial-gradient(900px 600px at 45% 35%, rgba(79,70,229,.08), transparent 65%),
        radial-gradient(900px 600px at 60% 60%, rgba(20,184,166,.08), transparent 65%);
      border:10px solid var(--ring);
      box-shadow:
        inset 0 0 46px rgba(79,70,229,.33),
        inset 0 0 90px rgba(20,184,166,.20),
        0 0 36px rgba(20,184,166,.14);
    }

    .seat {
      position:absolute; transform:translate(-50%,-50%);
      width:102px; height:102px; border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      background:linear-gradient(145deg,#122038,#0b1628);
      border:2px solid #2a3a52; color:#b7c9df; font-size:11px; font-weight:900;
      text-transform:uppercase;
      transition:.25s ease all;
    }
    .seat.hero{border-color:#22c55e;color:#d1fae5;box-shadow:0 0 22px var(--hero-glow)}
    .seat.acting{border-color:#fbbf24;color:#fde68a;box-shadow:0 0 28px var(--act-glow)}
    .stack{position:absolute;top:calc(100% + 16px);left:50%;transform:translateX(-50%);
      background:#0b1220;border:1px solid rgba(99,102,241,.55);color:#c7d2fe;
      padding:3px 10px;border-radius:9999px;font-size:12px;white-space:nowrap;
    }

    .card{width:110px;height:155px;border-radius:18px;display:flex;flex-direction:column;
      align-items:center;justify-content:center;background:linear-gradient(160deg,#fff,#e7eaff);
      border:2px solid rgba(79,70,229,.95);
    }
    .rank{font-size:60px;font-weight:900;line-height:1}
    .suit{font-size:50px;margin-top:4px}
    .red{color:#ef4444}.black{color:#0f172a}
    .board-card{width:98px;height:138px;border-radius:16px}
    .hero-cards{position:absolute;display:flex;gap:14px;z-index:60;transform:translate(-50%,-50%)}

    .hud{position:absolute;left:50%;top:44%;transform:translate(-50%,-50%);
      background:var(--glass);border:1px solid rgba(99,102,241,.35);padding:.5rem .8rem;
      border-radius:.9rem;font-weight:900;font-size:14px;color:#c7d2fe;
      display:flex;gap:.6rem;backdrop-filter:blur(2px)
    }

    .panel{background:#0b1220;border:1px solid #2c3a4f;border-radius:1rem;padding:1rem}
    .btn{font-weight:900;padding:.95rem 1.15rem;border-radius:.9rem;transition:.15s}
    .btn-primary{background:var(--indigo);color:#fff}
    .btn-ghost{background:rgba(20,184,166,.12);color:#5eead4;border:1px solid rgba(45,212,191,.35)}
    .btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);color:#fff}

    .result-panel{background:linear-gradient(135deg,var(--indigo),var(--teal));border-radius:1rem;padding:1rem;color:#fff;}
    .result-score{font-size:52px;font-weight:900}
    .score-good{color:#22c55e}.score-bad{color:#ef4444}
    .log-item{display:flex;justify-content:space-between;align-items:center;background:#0b1220;border:1px solid #2b3647;border-radius:.9rem;padding:.65rem .85rem;margin-bottom:.55rem}
  </style>
</head>
<body>
  <header class="flex flex-col gap-4 md:flex-row md:items-end md:justify-between px-4 pt-4">
    <div>
      <h1 class="text-3xl font-extrabold text-indigo-400">GTO Shark • Live Practice v8.5</h1>
      <p class="text-slate-400 text-sm">Cinematic felt table • 100% GTO-style villains • Always-on hero actions</p>
    </div>
    <div class="flex flex-wrap items-center gap-3 px-2">
      <label class="text-xs text-slate-400">Table</label>
      <select id="numPlayers" class="bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm">
        <option value="9" selected>9-max</option>
        <option value="6">6-max</option>
      </select>
      <label class="text-xs text-slate-400 ml-1">Hero</label>
      <select id="heroPos" class="bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm"></select>
      <button id="newHand" class="btn btn-primary">♻ New Hand</button>
    </div>
  </header>

  <div class="app">
    <main class="px-2">
      <section class="table-wrap mt-3">
        <div id="table" class="table-ring">
          <div id="hud" class="hud">
            <span id="hudStreet">—</span><span>|</span><span id="hudPot">Pot —</span><span>|</span><span id="hudSPR">SPR —</span>
          </div>
          <div id="board" class="absolute top-[48%] left-1/2 -translate-x-1/2 flex gap-3 z-40"></div>
          <div id="seatsLayer" class="absolute inset-0"></div>
        </div>
      </section>

      <section class="mt-5 panel">
        <h3 class="text-lg text-white mb-1">Your move</h3>
        <p id="prompt" class="text-slate-400 text-sm">Shuffling…</p>
        <div id="actions" class="flex flex-wrap gap-3 mt-3"></div>
      </section>
    </main>

    <aside class="sidebar flex flex-col gap-4 pr-2">
      <div id="resultPanel" class="result-panel hidden">
        <div class="result-score" id="resultScore"></div>
        <div id="resultVerdict" class="text-white/90 font-semibold"></div>
      </div>
      <div class="panel">
        <div class="flex justify-between items-center mb-1">
          <h3 class="text-indigo-300 font-bold">Hand Log</h3>
          <button id="clearLog" class="text-xs bg-slate-700 px-2 py-1 rounded">Clear</button>
        </div>
        <p class="text-xs text-slate-500 mb-2">✅ ≥ 50% ❌ &lt; 50%</p>
        <div id="logList"></div>
      </div>
    </aside>
  </div>
  <!-- ===== Part 2 / 4 — Core Engine & Layout (v8.5 functional) ===== -->
  <script>
  /* ---------- RNG (Google entropy) ---------- */
  const API_KEY="AIzaSyBZh4GD0KX691kfF3eU45a71o1IHf5iL4U";
  let _seed = Date.now()|0;
  function xsSeed(n){ _seed = n>>>0; }
  function xsRand(){ _seed^=_seed<<13; _seed^=_seed>>>17; _seed^=_seed<<5; return ((_seed>>>0)%1e5)/1e5; }
  async function seedFromAPI(){
    try{
      const r=await fetch(`https://www.googleapis.com/books/v1/volumes?q=poker&maxResults=5&key=${API_KEY}`,{cache:"no-store"});
      const j=await r.json(); xsSeed(JSON.stringify(j).length ^ Date.now());
    }catch{ xsSeed(Date.now() ^ 0x9e3779b9); }
  }
  const sleep=(ms)=>new Promise(res=>setTimeout(res,ms)); // cinematic pacing

  /* ---------- DOM ---------- */
  const table=document.getElementById("table");
  const seatsLayer=document.getElementById("seatsLayer");
  const boardEl=document.getElementById("board");
  const hudStreet=document.getElementById("hudStreet");
  const hudPot=document.getElementById("hudPot");
  const hudSPR=document.getElementById("hudSPR");
  const actionsEl=document.getElementById("actions");
  const promptEl=document.getElementById("prompt");
  const resultPanel=document.getElementById("resultPanel");
  const resultScore=document.getElementById("resultScore");
  const resultVerdict=document.getElementById("resultVerdict");
  const logList=document.getElementById("logList");
  const newBtn=document.getElementById("newHand");
  const clearLog=document.getElementById("clearLog");
  const heroSel=document.getElementById("heroPos");
  const numSel=document.getElementById("numPlayers");

  /* ---------- Cards ---------- */
  const RANKS=["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
  const SUITS=["♠","♥","♦","♣"];
  const SUITCLASS=(s)=>(s==="♥"||s==="♦")?"red":"black";
  function deal(n,taken=new Set()){
    const out=[]; while(out.length<n){ const c=RANKS[Math.floor(xsRand()*13)]+SUITS[Math.floor(xsRand()*4)]; if(!taken.has(c)){taken.add(c); out.push(c);} }
    return out;
  }
  function cardEl(card,isBoard=false){
    const r=card[0], s=card[1];
    const el=document.createElement("div");
    el.className=isBoard?"card board-card":"card";
    el.innerHTML=`<div class="rank ${SUITCLASS(s)}">${r}</div><div class="suit ${SUITCLASS(s)}">${s}</div>`;
    return el;
  }

  /* ---------- Seat templates ---------- */
  const TEMPLATES={
    9:["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"],
    6:["UTG","HJ","CO","BTN","SB","BB"],
  };

  /* ---------- State ---------- */
  const state={
    players:9, seats:[], hero:"UTG",
    street:"preflop", sequence:"river",
    board:[], pot:0, currentBet:0,
    hands:{}, stacks:{}, committed:{}, committedTotal:{},
    folded:{}, allin:{}, interacted:new Set(), showdown:[],
    nodes:{}, evLoss:0, lastSnapshot:null
  };

  /* ---------- Layout & HUD ---------- */
  function layoutSeats(){
    seatsLayer.innerHTML=""; state.nodes={};
    const N=state.players, R=(table.clientWidth/2)-120, offset=-90;
    for(let i=0;i<N;i++){
      const name=state.seats[i];
      const ang=(offset + (360/N)*i)*Math.PI/180;
      const x=50+(R*Math.cos(ang))/(table.clientWidth/100);
      const y=50+(R*Math.sin(ang))/(table.clientHeight/100);

      const seat=document.createElement("div");
      seat.className="seat"; seat.style.left=x+"%"; seat.style.top=y+"%"; seat.textContent=name;

      const st=document.createElement("span");
      st.className="stack"; st.id=`stack-${name}`; st.textContent="—";
      seat.appendChild(st);

      seatsLayer.appendChild(seat);
      state.nodes[name]={seat,stack:st,pos:{x,y},label:name,chipPlate:null};
    }
  }
  function markHero(){
    Object.values(state.nodes).forEach(n=>n.seat.classList.remove("hero"));
    const n=state.nodes[state.hero]; if(n) n.seat.classList.add("hero");
  }
  function setActing(seat,on){ const n=state.nodes[seat]; if(!n) return; n.seat.classList.toggle("acting", !!on); }
  function foldSeat(seat){ const n=state.nodes[seat]; if(!n) return; state.folded[seat]=true; n.seat.textContent="FOLD"; n.seat.classList.add("folded"); n.stack.style.opacity=.55; }

  function clearBoard(){ boardEl.innerHTML=""; }
  function renderBoard(){ boardEl.innerHTML=""; state.board.forEach(c=>boardEl.appendChild(cardEl(c,true))); }
  function renderHeroCards(){
    // remove old
    document.querySelectorAll(".hero-cards").forEach(n=>n.remove());
    const n=state.nodes[state.hero]; if(!n) return;
    const box=document.createElement("div");
    box.className="hero-cards";
    box.style.left=n.pos.x+"%"; box.style.top=`calc(${n.pos.y}% - 24px)`;
    const h=state.hands[state.hero]||[];
    h.forEach(c=>box.appendChild(cardEl(c,false)));
    table.appendChild(box);
  }
  function updateStacksUI(){ state.seats.forEach(s=>{const n=state.nodes[s]; if(n) n.stack.textContent=`${(state.stacks[s]??0).toFixed(1)} BB`;}); }
  function renderHUD(){
    hudStreet.textContent=state.street[0].toUpperCase()+state.street.slice(1);
    hudPot.textContent=`Pot ${state.pot.toFixed(1)} BB`;
    const live=state.seats.filter(s=>!state.folded[s]);
    const eff=live.length?Math.min(...live.map(s=>Math.max(0.1,state.stacks[s]))):100;
    const spr=(eff/Math.max(1,state.pot)).toFixed(1); hudSPR.textContent=`SPR ${spr}`;
  }
  function setPrompt(txt){ promptEl.textContent = txt || `${state.street[0].toUpperCase()+state.street.slice(1)}: Your action as ${state.hero}.`; }

  /* ---------- Commit/stack accounting ---------- */
  function resetCommitted(){ state.committed={}; state.seats.forEach(s=>state.committed[s]=0); }
  function resetCommittedTotal(){ state.committedTotal={}; state.seats.forEach(s=>state.committedTotal[s]=0); }
  function toCall(seat){ return Math.max(0, state.currentBet - state.committed[seat]); }
  function payTo(seat, target){
    const need=Math.max(0, target - state.committed[seat]);
    if(need<=0) return 0;
    const pay=Math.min(need, state.stacks[seat]);
    state.stacks[seat]=+(state.stacks[seat]-pay).toFixed(1);
    state.committed[seat]=+(state.committed[seat]+pay).toFixed(1);
    state.committedTotal[seat]=+(state.committedTotal[seat]+pay).toFixed(1);
    state.pot=+(state.pot+pay).toFixed(1);
    if(state.stacks[seat]<=0){ state.stacks[seat]=0; state.allin[seat]=true; }
    updateCommitPlate(seat);
    updateStacksUI(); renderHUD();
    return pay;
  }
  function equalized(){
    const live=state.seats.filter(s=>!state.folded[s]);
    return live.every(s=> state.committed[s]===state.currentBet );
  }

  /* ---------- Chip plates (total committed per seat) ---------- */
  const floatPlates=new Map();
  function updateCommitPlate(seat){
    const n=state.nodes[seat]; if(!n) return;
    const key=`plate-${seat}`;
    let plate=floatPlates.get(key);
    const y=parseFloat(n.seat.style.top);
    if(!plate){
      plate=document.createElement("div");
      plate.style.position="absolute"; plate.style.left=n.seat.style.left;
      plate.style.top=`calc(${y}% - 56px)`; plate.style.transform="translate(-50%,0)";
      plate.style.background="#0b1220"; plate.style.border="1px solid rgba(99,102,241,.55)";
      plate.style.color="#c7d2fe"; plate.style.padding=".3rem .6rem";
      plate.style.borderRadius=".7rem"; plate.style.fontWeight="900"; plate.style.fontSize="12px";
      plate.style.boxShadow="0 8px 18px rgba(0,0,0,.35)"; plate.style.zIndex=70;
      table.appendChild(plate);
      floatPlates.set(key,plate);
    }
    plate.textContent=`${(state.committedTotal[seat]||0).toFixed(1)} BB`;
    if(state.folded[seat]) plate.style.opacity=.25;
  }
  function clearPlates(){ floatPlates.forEach(p=>p.remove()); floatPlates.clear(); }

  /* ---------- Utilities ---------- */
  function clearActions(){ actionsEl.innerHTML=""; }
  function addBtn(label,cls,cb){ const b=document.createElement("button"); b.className=`btn ${cls}`; b.textContent=label; b.onclick=cb; actionsEl.appendChild(b); return b; }
  function ensureHeroButtons(){
    // show buttons if it's hero's turn
    if(state.folded[state.hero] || state.stacks[state.hero]<=0) return;
    offerHero(); // defined in Part 3; this call is safe (function hoisted across tags)
  }

  </script>
  <!-- ===== Part 3 / 4 — Gameplay Flow, Hero Actions & Turn Logic ===== -->
  <script>
  /*********************
   * GTO POLICY & SCORING
   *********************/
  function handStrength(cards){
    const [a,b]=cards; const r1=RANKS.indexOf(a[0]); const r2=RANKS.indexOf(b[0]);
    const pair=a[0]===b[0], suited=a[1]===b[1], gap=Math.abs(r1-r2);
    let score = 100 - (r1+r2)*2; if(pair) score+=20; if(suited) score+=5; if(gap<=1) score+=5;
    return Math.max(0,Math.min(100,score));
  }

  function gtoDecision(heroCards,stage){
    const s=handStrength(heroCards)+xsRand()*5;
    if(stage==="preflop"){
      if(s>90) return "Raise 3BB";
      if(s>75) return "Raise 2.5BB";
      if(s>60) return "Call";
      return "Fold";
    }else{
      if(s>80) return "Bet (Big)";
      if(s>60) return "Bet (Small)";
      if(s>40) return "Check";
      return "Fold";
    }
  }

  function gtoScore(heroAction,heroCards,stage){
    const opt=gtoDecision(heroCards,stage);
    if(heroAction===opt) return 100;
    if(heroAction.includes("Fold") && opt.includes("Fold")) return 100;
    if(heroAction.includes("Fold") && !opt.includes("Fold")) return 70;
    if(!heroAction.includes("Fold") && opt.includes("Fold")) return 30;
    if(heroAction.includes("Bet") && opt.includes("Bet")) return 90;
    return 50 + (xsRand()*40-20); // range
  }

  /*********************
   * GAMEPLAY ENGINE
   *********************/
  async function startHand(){
    clearPlates(); clearBoard(); clearActions(); resultPanel.classList.add("hidden");
    state.folded={}; state.allin={}; state.interacted.clear();
    resetCommitted(); resetCommittedTotal(); state.pot=0; state.currentBet=0;
    state.street="preflop";

    // deal
    const taken=new Set();
    state.seats.forEach(s=>{state.hands[s]=deal(2,taken); state.folded[s]=false;});
    renderBoard(); renderHeroCards(); updateStacksUI(); renderHUD();
    setPrompt("Preflop: Your action as "+state.hero);

    await villainRoundBeforeHero();
    offerHero(); // hero buttons appear here
  }

  async function villainRoundBeforeHero(){
    const idx=state.seats.indexOf(state.hero);
    for(let i=0;i<idx;i++){
      const pos=state.seats[i]; if(state.folded[pos]) continue;
      const dec=gtoDecision(state.hands[pos],"preflop");
      setActing(pos,true); await sleep(800);
      if(dec.includes("Fold")){ foldSeat(pos); }
      else if(dec.includes("Call")){ const to=state.currentBet||1; payTo(pos,to); state.currentBet=to; }
      else if(dec.includes("Raise")){
        const amt=parseInt(dec.match(/\d+/)?.[0]||3); const to=amt;
        state.currentBet=to; payTo(pos,to);
      }
      setActing(pos,false); updateStacksUI(); renderHUD();
    }
  }

  async function villainRoundAfterHero(){
    const idx=state.seats.indexOf(state.hero);
    for(let i=idx+1;i<state.seats.length;i++){
      const pos=state.seats[i]; if(state.folded[pos]) continue;
      const dec=gtoDecision(state.hands[pos],state.street);
      setActing(pos,true); await sleep(1000);
      if(dec.includes("Fold")){ foldSeat(pos); }
      else if(dec.includes("Call")){
        const to=state.currentBet||1; payTo(pos,to); 
      }else if(dec.includes("Raise")){
        const amt=parseInt(dec.match(/\d+/)?.[0]||3); state.currentBet=amt; payTo(pos,amt);
      }
      setActing(pos,false);
      updateStacksUI(); renderHUD();
    }
  }

  async function nextStreet(){
    clearActions();
    const stages=["preflop","flop","turn","river"];
    const idx=stages.indexOf(state.street);
    if(idx<stages.length-1){
      state.street=stages[idx+1];
      if(state.street==="flop") state.board=deal(3,new Set(Object.values(state.hands).flat()));
      else if(state.street==="turn"||state.street==="river") state.board.push(...deal(1,new Set(Object.values(state.hands).flat().concat(state.board))));
      renderBoard(); renderHUD(); resetCommitted(); state.currentBet=0;
      await sleep(900);
      await villainRoundBeforeHero();
      offerHero();
    }else finishHand();
  }

  function finishHand(){
    clearActions();
    const score=gtoScore(state.lastAction||"Fold",state.hands[state.hero],state.street);
    resultScore.textContent=`${Math.round(score)}%`;
    resultScore.className="result-score "+(score>=50?"score-good":"score-bad");
    resultVerdict.textContent=score>=50?"Good Decision":"Mistake";
    resultPanel.classList.remove("hidden");

    const item=document.createElement("div");
    item.className="log-item";
    item.innerHTML=`<span>${state.hands[state.hero].join(" ")}</span><span>${score>=50?"✅":"❌"} ${Math.round(score)}%</span>`;
    logList.prepend(item);
  }

  /*********************
   * HERO ACTIONS
   *********************/
  function offerHero(){
    clearActions();
    const toCall=state.currentBet-state.committed[state.hero];
    const bbSizes=[2,3,5];
    if(state.street==="preflop"){
      addBtn("Fold","btn-ghost",()=>heroActs("Fold"));
      if(toCall>0) addBtn(`Call ${toCall} BB`,"btn-primary",()=>heroActs("Call"));
      else addBtn("Check","btn-primary",()=>heroActs("Check"));
      bbSizes.forEach(bb=> addBtn(`Raise ${bb} BB`,"btn-primary",()=>heroActs(`Raise ${bb}`)));
      addBtn("All-in","btn-danger",()=>heroActs("All-in"));
    } else {
      addBtn("Fold","btn-ghost",()=>heroActs("Fold"));
      addBtn("Check","btn-primary",()=>heroActs("Check"));
      bbSizes.forEach(bb=> addBtn(`Bet ${bb} BB`,"btn-primary",()=>heroActs(`Bet ${bb}`)));
      addBtn("All-in","btn-danger",()=>heroActs("All-in"));
    }
  }

  async function heroActs(label){
    state.lastAction=label;
    if(label==="Fold"){ foldSeat(state.hero); finishHand(); return; }
    if(label.includes("Call")){
      payTo(state.hero,state.currentBet);
    }else if(label.includes("Raise")||label.includes("Bet")){
      const amt=parseInt(label.match(/\d+/)?.[0]||3); state.currentBet=amt; payTo(state.hero,amt);
    }else if(label.includes("All-in")){
      payTo(state.hero,state.stacks[state.hero]); state.allin[state.hero]=true;
    }
    updateStacksUI(); renderHUD();
    await villainRoundAfterHero();
    const live=state.seats.filter(s=>!state.folded[s]);
    if(live.length<=1){ finishHand(); return; }
    await nextStreet();
  }

  /*********************
   * EVENT HOOKS
   *********************/
  newBtn.onclick=()=>startHand();
  clearLog.onclick=()=>{logList.innerHTML="";};
  window.addEventListener("load",async()=>{
    await seedFromAPI();
    state.seats=TEMPLATES[9]; state.players=9; state.hero="UTG";
    layoutSeats(); markHero();
    state.seats.forEach(s=>{state.stacks[s]=100;});
    updateStacksUI(); renderHUD(); startHand();
  });
  </script>
  <!-- ===== Part 4 / 4 — Visual polish + closing ===== -->
  <script>
  /*********************
   * CHIP TOSS ANIMATION
   *********************/
  function showChipToss(seat, amount) {
    const n = state.nodes[seat];
    if (!n) return;
    const chip = document.createElement("div");
    chip.className = "bet-chip";
    chip.style.left = n.seat.style.left;
    chip.style.top = n.seat.style.top;
    chip.innerHTML = `<span class="chip-icon"></span>${amount} BB`;
    table.appendChild(chip);
    setTimeout(() => chip.remove(), 1800);
  }

  // Patch payTo() to animate chip movement
  const _payTo = payTo;
  payTo = function (seat, target) {
    const paid = _payTo(seat, target);
    if (paid > 0) showChipToss(seat, paid);
    return paid;
  };

  /*********************
   * QUALITY-OF-LIFE HELPERS
   *********************/
  // persist table size & hero
  numSel.onchange = () => {
    state.players = +numSel.value;
    state.seats = TEMPLATES[state.players];
    heroSel.innerHTML = state.seats.map(p => `<option value="${p}">${p}</option>`).join("");
    state.hero = state.seats[0];
    layoutSeats(); markHero();
    state.seats.forEach(s => state.stacks[s] = 100);
    updateStacksUI(); renderHUD(); startHand();
  };

  heroSel.onchange = () => {
    state.hero = heroSel.value;
    markHero();
    renderHeroCards();
  };

  // populate hero selector
  heroSel.innerHTML = TEMPLATES[9].map(p => `<option value="${p}">${p}</option>`).join("");
  heroSel.value = "UTG";

  // simple local persistence
  window.addEventListener("beforeunload", () => {
    localStorage.setItem("gtohero", state.hero);
    localStorage.setItem("gtoplayers", state.players);
  });
  window.addEventListener("load", () => {
    const h = localStorage.getItem("gtohero");
    const p = localStorage.getItem("gtoplayers");
    if (h && TEMPLATES[p || 9].includes(h)) {
      state.hero = h;
      state.players = +p || 9;
      numSel.value = p || 9;
    }
  });
  </script>

  <style>
    /* smooth fade for toss chips */
    .bet-chip {
      position:absolute;
      transform:translate(-50%,-30%);
      background:#0b1220;
      border:1px solid rgba(99,102,241,.55);
      color:#c7d2fe;
      padding:.3rem .55rem;
      border-radius:.6rem;
      font-weight:900;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:.35rem;
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      opacity:0;
      animation:toss 1.8s ease-out forwards;
    }
    .chip-icon {
      width:14px;height:14px;border-radius:50%;
      background:radial-gradient(circle at 50% 50%,#f59e0b 0 25%,#7c3aed 26% 35%,#f59e0b 36% 60%,#7c3aed 61% 70%,#f59e0b 71%);
      border:1px solid rgba(245,158,11,.85);
    }
    @keyframes toss {
      0% { opacity:0; transform:translate(-50%,10px); }
      20% { opacity:1; transform:translate(-50%,0); }
      80% { opacity:1; transform:translate(-50%,-8px); }
      100% { opacity:0; transform:translate(-50%,-12px); }
    }
  </style>
</body>
</html>










