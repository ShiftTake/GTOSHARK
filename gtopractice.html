<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GTO Shark • Live Practice (Indigo/Teal Felt)</title>
<style>
:root{
  --felt:#0e172a;
  --felt-dark:#091122;
  --ring:#14b8a6;
  --indigo:#6366f1;
  --teal:#14b8a6;
  --good:#22c55e;
  --bad:#ef4444;
  --warn:#f59e0b;
  --ink:#e5e7eb;
  --ink-d:#9ca3af;
}
*{box-sizing:border-box}
body{
  margin:0;
  background:
    radial-gradient(1200px 800px at 50% -100px,#14213d 0%,transparent 65%),
    linear-gradient(180deg,#0b1020 0%,#0a0f1d 100%);
  color:var(--ink);
  font-family:'Inter',ui-sans-serif,system-ui;
  overflow-x:hidden;
}

header{
  display:flex;justify-content:space-between;align-items:center;
  padding:16px 24px;
}
.title{font-weight:900;font-size:22px;color:var(--ink)}
.subtitle{font-size:12px;color:var(--ink-d)}

.controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
select,button{font:inherit}
select{
  background:#0e172b;color:#d1d5db;border:1px solid #2a3b5e;
  border-radius:10px;padding:6px 10px
}
.btn{border:0;border-radius:10px;padding:10px 14px;cursor:pointer;font-weight:700}
.btn-primary{background:var(--indigo);color:#fff}
.btn-ghost{background:#14213d;border:1px solid #2a3b5e;color:#a5f3fc}
.btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);color:white}

/* ================= Table & Seats ================= */
.table-wrap{display:flex;justify-content:center;align-items:center;width:100%;min-height:calc(100vh - 120px)}
.table{
  position:relative;width:880px;height:880px;border-radius:50%;
  background:radial-gradient(70% 70% at 50% 45%,var(--felt) 0%,var(--felt-dark) 100%);
  box-shadow:
    inset 0 0 80px #000c,
    0 0 40px var(--ring),
    0 0 80px #14b8a633;
  overflow:visible;
}
.rim{position:absolute;inset:8px;border-radius:50%;
  box-shadow:inset 0 0 100px #14b8a628, inset 0 0 200px #4f46e533;
}

.seat{
  position:absolute;transform:translate(-50%,-50%);
  width:84px;height:84px;border-radius:50%;
  background:#14213d;border:2px solid #243b55;
  display:flex;align-items:center;justify-content:center;
  color:#a9bdd6;font-weight:900;text-transform:uppercase;
  transition:.2s filter ease,.2s box-shadow ease;
}
.seat.hero{border-color:var(--good);color:#bbf7d0;box-shadow:0 0 22px #22c55e77}
.seat.acting{border-color:var(--warn);color:#fde68a;box-shadow:0 0 26px #f59e0b66}
.seat.folded{filter:grayscale(.8) brightness(.7);color:#64748b;border-color:#2a3b5e}

.stack{
  position:absolute;left:50%;top:calc(100% + 14px);transform:translateX(-50%);
  font-size:11px;background:#0f172a;border:1px solid #334155;border-radius:999px;
  padding:2px 8px;color:#a5f3fc
}

/* Cards */
.cards{position:absolute;display:flex;gap:8px;transform:translate(-50%,-105%)}
.card{
  width:68px;height:96px;border-radius:14px;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:linear-gradient(160deg,#fff,#f3f4f6);
  box-shadow:0 10px 20px #0008;border:2px solid #4f46e5;
}
.rank{font-size:30px;font-weight:900;line-height:1}
.suit{font-size:24px;line-height:1}
.red{color:#ef4444}.black{color:#0f172a}

/* Board */
.board{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:10px;z-index:10}

/* Bet chips */
.betplate{
  position:absolute;transform:translate(-50%,-60px);
  background:linear-gradient(135deg,#16243e,#0e1930);
  border:1px solid #475569;border-radius:10px;padding:6px 10px;
  font-weight:800;font-size:12px;color:#e0f2fe;display:flex;align-items:center;gap:6px;
}
.chip{width:14px;height:14px;border-radius:50%;
  background:radial-gradient(circle at 50% 50%,#f59e0b 0 28%,#7c3aed 32% 60%,#f59e0b 64%);
}

/* HUD center */
.hud{
  position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
  background:#0b1326d9;border:1px solid #243b55;border-radius:10px;
  padding:6px 10px;display:flex;gap:8px;align-items:center;font-size:12px;
  color:#c7d2fe;font-weight:800;backdrop-filter:blur(3px)
}

/* Action buttons */
.actionbar-wrap{display:flex;justify-content:center;margin-top:18px}
.actionbar{
  background:#0b1326;border:1px solid #243b55;border-radius:12px;
  box-shadow:0 0 20px #0008;padding:12px 16px;
  display:flex;justify-content:center;gap:10px;flex-wrap:wrap;min-height:60px;width:min(920px,95vw)
}

/* Panels */
.panel{background:#0b1326;border:1px solid #243b55;border-radius:14px;padding:12px;color:var(--ink)}
.result{background:linear-gradient(135deg,var(--indigo),var(--teal));color:white;border-radius:14px;padding:14px}
.big{font-size:42px;font-weight:1000}
.good{color:var(--good)}.bad{color:var(--bad)}
</style>
</head>
<body>
<header>
  <div>
    <div class="title">GTO Shark • Live Practice</div>
    <div class="subtitle">Cinematic felt • Realistic villains • Showdown-only reveal</div>
  </div>
  <div class="controls">
    <label>Players
      <select id="playersSel">
        <option>9-max</option><option>8-max</option><option>7-max</option><option>6-max</option><option>5-max</option>
      </select>
    </label>
    <label>Hero Position
      <select id="heroSel"></select>
    </label>
    <label>Play Range
      <select id="rangeSel">
        <option value="preflop">Preflop Only</option>
        <option value="turn">Play to Turn</option>
        <option value="river" selected>Play to River</option>
      </select>
    </label>
    <button id="newBtn" class="btn btn-primary">♠ New Hand</button>
  </div>
</header>

<div class="table-wrap">
  <div id="table" class="table">
    <div class="rim"></div>
    <div id="hud" class="hud">
      <span id="hudStreet">—</span><span>•</span>
      <span id="hudPot">Pot —</span><span>•</span>
      <span id="hudSPR">SPR —</span>
    </div>
    <div id="board" class="board"></div>
    <div id="seatsLayer"></div>
    <div id="floatLayer"></div>
  </div>
</div>

<div class="actionbar-wrap">
  <div id="actions" class="actionbar"></div>
</div>

<div class="panel" style="margin:14px auto;max-width:920px">
  <h3>Your Move</h3>
  <div id="prompt" style="color:#94a3b8">Waiting for game to start…</div>
</div>

<div class="result" id="resultPanel" style="display:none;max-width:320px;margin:20px auto">
  <div id="scorePct" class="big">—%</div>
  <div id="scoreVerdict"></div>
  <div style="margin-top:10px;display:flex;gap:8px;justify-content:center">
    <button id="nextBtn" class="btn btn-primary">Next Hand</button>
  </div>
</div>

<script>
/* ========= Core JS setup (continued in part 2) ========= */
</script>
<script>
/* =========================================================
   Utilities & RNG
   ========================================================= */
let _seed = (Date.now() ^ (Math.random()*1e9)) >>> 0;
function xorshift(){ _seed ^= _seed<<13; _seed ^= _seed>>>17; _seed ^= _seed<<5; return (_seed>>>0)/0xFFFFFFFF; }
function rchoice(arr){ return arr[Math.floor(xorshift()*arr.length)] }
const sleep = (ms)=>new Promise(res=>setTimeout(res,ms));

/* =========================================================
   Cards & Layout
   ========================================================= */
const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const SUITS = ["♠","♥","♦","♣"];
const suitClass = s => (s==="♥"||s==="♦") ? "red":"black";

function deal(n, taken=new Set()){
  const out=[];
  while(out.length<n){
    const c = rchoice(RANKS)+rchoice(SUITS);
    if(!taken.has(c)){ taken.add(c); out.push(c); }
  }
  return out;
}
function cardEl(card, small=false){
  const r=card[0], s=card[1];
  const d=document.createElement("div");
  d.className="card";
  if(small){ d.style.width="60px"; d.style.height="86px"; }
  d.innerHTML=`<div class="rank ${suitClass(s)}">${r}</div><div class="suit ${suitClass(s)}">${s}</div>`;
  return d;
}

/* =========================================================
   DOM Refs
   ========================================================= */
const tableEl     = document.getElementById("table");
const seatsLayer  = document.getElementById("seatsLayer");
const floatLayer  = document.getElementById("floatLayer");
const boardEl     = document.getElementById("board");
const hudStreet   = document.getElementById("hudStreet");
const hudPot      = document.getElementById("hudPot");
const hudSPR      = document.getElementById("hudSPR");
const promptEl    = document.getElementById("prompt");
const actionsEl   = document.getElementById("actions");
const resultPanel = document.getElementById("resultPanel");
const scorePctEl  = document.getElementById("scorePct");
const scoreVerdEl = document.getElementById("scoreVerdict");
const nextBtn     = document.getElementById("nextBtn");

const playersSel  = document.getElementById("playersSel");
const heroSel     = document.getElementById("heroSel");
const rangeSel    = document.getElementById("rangeSel");
const newBtn      = document.getElementById("newBtn");

/* =========================================================
   Seat templates (clockwise, BTN fixed at bottom)
   ========================================================= */
const TEMPLATES={
  "9-max":["UTG","UTG+1","MP","LJ","HJ","CO","BTN","SB","BB"],
  "8-max":["UTG","UTG+1","MP","HJ","CO","BTN","SB","BB"],
  "7-max":["UTG","MP","LJ","HJ","CO","BTN","SB","BB"],
  "6-max":["UTG","HJ","CO","BTN","SB","BB"],
  "5-max":["UTG","CO","BTN","SB","BB"],
};

/* =========================================================
   Game State
   ========================================================= */
const state = {
  seats: [],
  nodes: {},         // seat -> { seat, stack, cardsHolder, pos:{x,y} }
  stacks:{},
  committed:{},
  folded:{},
  allin:{},
  interacted:new Set(), // villains who put chips in vs hero
  street:"preflop",
  target:"river",       // preflop|turn|river (play-through range)
  pot:0,
  currentBet:0,
  lastRaise:1,          // BB size baseline
  board:[],
  hands:{},
  hero:"BTN",
  bbSize:1,
  sbSize:0.5,
  stackBB:100,
  // scoring
  evLoss:0,
  ended:false,
};

/* =========================================================
   Layout & Rendering
   ========================================================= */
function layoutSeats(){
  seatsLayer.innerHTML=""; state.nodes={};
  const W=tableEl.clientWidth, H=tableEl.clientHeight;
  const cx=W/2, cy=H/2, R=Math.min(W,H)/2 - 90;
  const n=state.seats.length;
  // BTN should be at ~ 6 o'clock (index of BTN in seats)
  const startAngle=-90; // degrees at rightmost-mid is 0; -90 is bottom
  const step=360/n;

  state.seats.forEach((seatName,i)=>{
    const angle = (startAngle + step*i) * Math.PI/180;
    const x = cx + R*Math.cos(angle);
    const y = cy + R*Math.sin(angle);

    const wrap=document.createElement("div");
    wrap.className="seat";
    wrap.style.left = (x/W*100)+"%";
    wrap.style.top  = (y/H*100)+"%";
    wrap.textContent=seatName;

    const stack=document.createElement("div");
    stack.className="stack";
    stack.id=`stack-${seatName}`;
    stack.textContent="—";
    wrap.appendChild(stack);

    seatsLayer.appendChild(wrap);

    state.nodes[seatName]={
      seat:wrap,
      stack,
      pos:{x:x/W*100, y:y/H*100},
      cardsHolder:null,
      betPlate:null,
    };
  });
}

function setHeroHighlight(){
  Object.values(state.nodes).forEach(n=>{
    n.seat.classList.remove("hero");
  });
  state.nodes[state.hero]?.seat.classList.add("hero");
}

function placeHeroCards(){
  // remove old
  document.querySelectorAll(".cards.hero").forEach(n=>n.remove());
  const n = state.nodes[state.hero]; if(!n) return;
  const holder=document.createElement("div");
  holder.className="cards hero";
  holder.style.left = n.pos.x+"%";
  holder.style.top  = n.pos.y+"%";
  state.hands[state.hero].forEach(c=> holder.appendChild(cardEl(c)) );
  tableEl.appendChild(holder);
  n.cardsHolder = holder;
}

function renderBoard(){
  boardEl.innerHTML="";
  state.board.forEach(c=> boardEl.appendChild(cardEl(c,true)) );
}

function updateStacks(){
  state.seats.forEach(s=>{
    const n=state.nodes[s];
    n.stack.textContent = `${state.stacks[s].toFixed(1)} BB`;
  });
}

function renderHUD(){
  const txt = state.street.toUpperCase();
  hudStreet.textContent = txt;
  hudPot.textContent = `Pot ${state.pot.toFixed(1)} BB`;
  const live = state.seats.filter(s=>!state.folded[s]);
  const eff  = live.length? Math.min(...live.map(s=>Math.max(0.1,state.stacks[s]))): state.stackBB;
  const spr  = eff/Math.max(1,state.pot||1);
  hudSPR.textContent = `SPR ${spr.toFixed(1)}`;
}

function showBetPlate(seat, label){
  const n=state.nodes[seat];
  if(n.betPlate){ n.betPlate.remove(); }
  const plate=document.createElement("div");
  plate.className="betplate";
  plate.style.left = n.pos.x+"%";
  plate.style.top  = `calc(${n.pos.y}% - 48px)`;
  plate.innerHTML = `<span class="chip"></span><span>${label}</span>`;
  tableEl.appendChild(plate);
  n.betPlate=plate;
}

/* =========================================================
   Action buttons
   ========================================================= */
function clearActions(){ actionsEl.innerHTML=""; }
function addBtn(label, cls, cb, disabled=false){
  const b=document.createElement("button");
  b.className=`btn ${cls}`; b.textContent=label; b.onclick=cb; b.disabled=!!disabled;
  actionsEl.appendChild(b);
}

/* =========================================================
   Accounting (current street)
   ========================================================= */
function resetCommitted(){
  state.committed={}; state.seats.forEach(s=> state.committed[s]=0);
}
function startStreetAccounting(){
  state.currentBet = 0;
  resetCommitted();
  // blinds on preflop
  if(state.street==="preflop"){
    // SB then BB
    if(state.seats.includes("SB"))  postTo("SB", state.sbSize);
    if(state.seats.includes("BB")){ postTo("BB", state.bbSize); state.currentBet=state.bbSize; state.lastRaise=state.bbSize; }
  }
}

function toCall(seat){ return Math.max(0, state.currentBet - state.committed[seat]); }

function postTo(seat, targetTo){
  const need = Math.max(0, targetTo - state.committed[seat]);
  if(need<=0) return 0;
  const pay = Math.min(need, state.stacks[seat]);
  state.stacks[seat]     = +(state.stacks[seat]-pay).toFixed(1);
  state.committed[seat]  = +(state.committed[seat]+pay).toFixed(1);
  state.pot              = +(state.pot+pay).toFixed(1);
  if(state.stacks[seat]<=0){ state.allin[seat]=true; }
  updateStacks(); renderHUD();
  return pay;
}

function raiseTo(seat, newTotal){
  const minTo = state.currentBet + state.lastRaise; // min-raise rule
  let target  = Math.max(newTotal, minTo);
  const maxTo = state.committed[seat] + state.stacks[seat]; // jam cap
  if(target >= maxTo){
    state.currentBet = maxTo;
    state.lastRaise  = Math.max(state.lastRaise, maxTo - state.currentBet); // keep
    postTo(seat, state.currentBet);
    showBetPlate(seat,"All-in");
    return "allin";
  }else{
    const prev = state.currentBet;
    state.currentBet = target;
    state.lastRaise  = Math.max(state.lastRaise, state.currentBet - prev);
    const add = postTo(seat, state.currentBet);
    showBetPlate(seat, `Raise ${(add).toFixed(1)} BB`);
    return "raise";
  }
}

function equalizedAmongLive(){
  const live=state.seats.filter(s=>!state.folded[s] && !state.allin[s]);
  return live.every(s => state.committed[s]===state.currentBet);
}

/* =========================================================
   Strength & simplified GTO policy
   ========================================================= */
function pfStrength(cards){
  const [a,b]=cards;
  const r1=RANKS.indexOf(a[0]), r2=RANKS.indexOf(b[0]);
  const pair=a[0]===b[0], suited=a[1]===b[1];
  const gap=Math.abs(r1-r2);
  let s= pair ? (100 - r1*3)
              : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?6:0);
  return s + xorshift()*2; // small noise
}
function postStrength(cards, board){
  const ranks=board.map(c=>c[0]);
  const high= ranks.filter(r=>["A","K","Q","J","T"].includes(r)).length*2;
  const pair = ranks.some(r=> r===cards[0][0] || r===cards[1][0]) ? 8:0;
  const suit = (cards[0][1]===cards[1][1])?3:0;
  return high+pair+suit + xorshift()*2;
}
function villainPolicy(seat){
  // returns one of: fold, call, check, bet_s, bet_m, bet_b, r_small, r_big, jam
  const s = state.street==="preflop" ? pfStrength(state.hands[seat]) : postStrength(state.hands[seat], state.board);
  const need = toCall(seat);

  if(state.street==="preflop"){
    if(need>0){
      if(s<68) return (xorshift()<0.85) ? "fold" : "call";
      if(s<80) return (xorshift()<0.70) ? "call" : "r_small";
      if(s<92) return (xorshift()<0.55) ? "r_small":"r_big";
      return (xorshift()<0.80) ? "r_big" : "jam";
    }else{
      if(s<70) return "check";
      if(s<88) return (xorshift()<0.65) ? "r_small":"check";
      return (xorshift()<0.7) ? "r_big":"r_small";
    }
  }else{
    // postflop
    if(need>0){
      if(s<8)   return (xorshift()<0.8) ? "fold":"call";
      if(s<12)  return (xorshift()<0.7) ? "call":"r_small";
      if(s<16)  return (xorshift()<0.65)? "r_small":"r_big";
      return (xorshift()<0.70)? "r_big":"jam";
    }else{
      if(s<8)   return "check";
      if(s<12)  return (xorshift()<0.7) ? "check":"bet_s";
      if(s<16)  return (xorshift()<0.65)? "bet_m":"bet_s";
      return (xorshift()<0.6) ? "bet_b":"bet_m";
    }
  }
}

/* =========================================================
   Hero policy grading (EV-ish penalty → score%)
   ========================================================= */
function evPenalty(actionKey, optimalKey){
  if(actionKey===optimalKey) return 0;
  const fam=a=>a.startsWith("r_")?"Raise":a.startsWith("bet")?"Bet":(a[0].toUpperCase()+a.slice(1));
  const weights={
    preflop:{Fold:.9,Call:.55,Raise:.65,"All-in":1.1},
    flop:{Check:.22,Bet:.38,"All-in":.75},
    turn:{Check:.28,Bet:.5,"All-in":.9},
    river:{Check:.33,Bet:.62,"All-in":1.05}
  };
  const map = weights[state.street] || weights.flop;
  let w = map[fam(actionKey)] ?? .5;
  // quick buff: junk-fold preflop = 0 penalty
  if(state.street==="preflop" && actionKey==="fold" && pfStrength(state.hands[state.hero])<66) return 0;
  w += xorshift()*0.12;
  return +w.toFixed(2);
}
function scoreFromLoss(loss){
  return Math.max(0, Math.min(100, Math.round(100 - loss*25)));
}

/* =========================================================
   Street dealing
   ========================================================= */
function dealFlop(){
  const t=new Set(Object.values(state.hands).flat());
  state.board=deal(3,t);
  state.street="flop";
  renderBoard(); startStreetAccounting(); renderHUD();
}
function dealTurn(){
  const t=new Set(Object.values(state.hands).flat().concat(state.board));
  state.board=[...state.board, ...deal(1,t)];
  state.street="turn";
  renderBoard(); startStreetAccounting(); renderHUD();
}
function dealRiver(){
  const t=new Set(Object.values(state.hands).flat().concat(state.board));
  state.board=[...state.board, ...deal(1,t)];
  state.street="river";
  renderBoard(); startStreetAccounting(); renderHUD();
}

/* =========================================================
   Villain acting (one seat)
   ========================================================= */
async function villainAct(seat){
  if(state.folded[seat] || state.allin[seat]) return;
  const node=state.nodes[seat]; node.seat.classList.add("acting");
  await sleep(350 + Math.floor(xorshift()*450));

  const need = toCall(seat);
  const pol  = villainPolicy(seat);

  if(need===0){
    if(pol==="check"){ node.seat.classList.remove("acting"); return; }
    if(pol==="bet_s"||pol==="bet_m"||pol==="bet_b"){
      const p=state.pot||2;
      const size = pol==="bet_s"? Math.max(2, Math.round(p*0.33))
                 : pol==="bet_m"? Math.max(2, Math.round(p*0.5))
                 : Math.max(2, Math.round(p*0.75));
      state.currentBet=size; state.lastRaise=size; postTo(seat, state.currentBet);
      showBetPlate(seat, `Bet ${size} BB`);
      state.interacted.add(seat);
      node.seat.classList.remove("acting");
      return;
    }
    if(pol==="r_small"||pol==="r_big"){ // opening preflop
      const open = pol==="r_small" ? 2.5 : 3.0;
      state.currentBet=open; state.lastRaise=open - state.bbSize;
      postTo(seat, state.currentBet);
      showBetPlate(seat, `Open ${open.toFixed(1)} BB`);
      state.interacted.add(seat);
      node.seat.classList.remove("acting");
      return;
    }
  }else{
    if(pol==="fold"){
      state.folded[seat]=true;
      node.seat.classList.add("folded");
      node.seat.textContent="FOLD";
      node.seat.classList.remove("acting");
      return;
    }
    if(pol==="call"){
      const paid=postTo(seat, state.currentBet);
      showBetPlate(seat, paid>=state.stacks[seat]+paid ? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
      state.interacted.add(seat);
      node.seat.classList.remove("acting");
      return;
    }
    if(pol==="jam"){
      state.currentBet = state.committed[seat] + state.stacks[seat];
      state.lastRaise  = Math.max(state.lastRaise, state.currentBet - state.committed[seat]);
      postTo(seat, state.currentBet);
      showBetPlate(seat,"All-in");
      state.interacted.add(seat);
      node.seat.classList.remove("acting");
      return;
    }
    if(pol==="r_small"||pol==="r_big"){
      const add = pol==="r_small" ? Math.max(2, Math.round(Math.max(2, state.lastRaise))) :
                                    Math.max(3, Math.round(Math.max(3, state.lastRaise*1.5)));
      raiseTo(seat, state.currentBet + add);
      state.interacted.add(seat);
      node.seat.classList.remove("acting");
      return;
    }
  }
  node.seat.classList.remove("acting");
}

/* =========================================================
   Turn order helpers
   ========================================================= */
function idxOf(seat){ return state.seats.indexOf(seat); }

async function runBeforeHeroThisStreet(){
  // order starts: preflop UTG .. -> hero-1
  // postflop: from SB clockwise until hero-1
  let order=[];
  if(state.street==="preflop"){
    const start = idxOf("UTG");
    for(let i=0;i<state.seats.length;i++){
      const s = state.seats[(start+i)%state.seats.length];
      if(s===state.hero) break;
      order.push(s);
    }
  }else{
    const start = idxOf("SB");
    for(let i=0;i<state.seats.length;i++){
      const s = state.seats[(start+i)%state.seats.length];
      if(s===state.hero) break;
      if(!state.folded[s]) order.push(s);
    }
  }
  for(const s of order){ await villainAct(s); }
}

async function runAfterHeroThisStreet(){
  // continue from the seat after hero to the end of round
  let order=[];
  const start = (idxOf(state.hero)+1) % state.seats.length;
  for(let i=0;i<state.seats.length;i++){
    const s = state.seats[(start+i)%state.seats.length];
    if(s===state.hero) break;
    order.push(s);
  }
  // loop until equalized or only one live
  let safety=20;
  while(safety-->0){
    let live=state.seats.filter(s=>!state.folded[s] && !state.allin[s]);
    if(live.length<=1 || equalizedAmongLive()) break;
    for(const s of order){
      if(!state.folded[s] && !state.allin[s]){ await villainAct(s); }
      live=state.seats.filter(t=>!state.folded[t] && !state.allin[t]);
      if(live.length<=1 || equalizedAmongLive()) break;
    }
  }
}

/* =========================================================
   Hero actions
   ========================================================= */
function offerHero(){
  clearActions();
  if(state.ended) return;
  const need = toCall(state.hero);
  const eff  = state.stacks[state.hero];
  const node = state.nodes[state.hero];

  // Always fold option
  addBtn("Fold","btn btn-ghost".replace('btn ',''),
    ()=>heroAct("fold"));

  if(need===0){
    addBtn("Check","btn btn-ghost".replace('btn ',''), ()=>heroAct("check"));
  }else{
    addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`,`btn btn-primary`.replace('btn ',''), ()=>heroAct("call"));
  }

  if(eff>0){
    if(state.street==="preflop"){
      const base = Math.max(2.2, state.currentBet ? state.currentBet + state.lastRaise : 2.5);
      const r1   = +base.toFixed(1);
      const r2   = +(base+1.5).toFixed(1);
      addBtn(`Raise to ${r1} BB`,`btn btn-primary`.replace('btn ',''), ()=>heroAct({type:"raise",to:r1}));
      addBtn(`Raise to ${r2} BB`,`btn btn-primary`.replace('btn ',''), ()=>heroAct({type:"raise",to:r2}));
    }else{
      const p = Math.max(2, state.pot);
      const s1=Math.round(p*0.33), s2=Math.round(p*0.5), s3=Math.round(p*0.66);
      if(need===0){
        addBtn(`Bet ${s1} BB`,`btn btn-primary`.replace('btn ',''), ()=>heroAct({type:"bet",to:s1}));
        addBtn(`Bet ${s2} BB`,`btn btn-primary`.replace('btn ',''), ()=>heroAct({type:"bet",to:s2}));
        addBtn(`Bet ${s3} BB`,`btn btn-primary`.replace('btn ',''), ()=>heroAct({type:"bet",to:s3}));
      }else{
        const rTo = Math.max(state.currentBet + state.lastRaise, state.currentBet + Math.round(p*0.4));
        addBtn(`Raise to ${rTo} BB`,`btn btn-primary`.replace('btn ',''), ()=>heroAct({type:"raise",to:rTo}));
      }
    }
    addBtn("All-in","btn-danger", ()=>heroAct("allin"));
  }

  promptEl.textContent = `${state.street.toUpperCase()}: Your action as ${state.hero}.`;
  // visual "acting"
  Object.values(state.nodes).forEach(n=>n.seat.classList.remove("acting"));
  node.seat.classList.add("acting");
}

function optimalForHero(){
  // Very light guidance: strong -> raise/bet; medium -> call/check; weak -> fold/check
  const s = state.street==="preflop" ? pfStrength(state.hands[state.hero]) : postStrength(state.hands[state.hero], state.board);
  const need=toCall(state.hero);
  if(state.street==="preflop"){
    if(need===0){
      if(s>85) return "r_big";
      if(s>72) return "r_small";
      return "check";
    }else{
      if(s<66) return "fold";
      if(s<82) return "call";
      if(s<92) return "r_small";
      return "r_big";
    }
  }else{
    if(need===0){
      if(s<8) return "check";
      if(s<12) return "bet_s";
      if(s<16) return "bet_m";
      return "bet_b";
    }else{
      if(s<8) return "fold";
      if(s<12) return "call";
      if(s<16) return "r_small";
      return "r_big";
    }
  }
}

async function heroAct(action){
  if(state.ended) return;

  // Grade
  let aKey;
  if(action==="fold"||action==="check"||action==="call"||action==="allin"){
    aKey = action;
  }else if(action.type==="raise"){ aKey="r_small"; }
  else if(action.type==="bet"){ aKey = action.to<=Math.round((state.pot||2)*0.4) ? "bet_s" : action.to<=Math.round((state.pot||2)*0.6) ? "bet_m" : "bet_b"; }

  state.evLoss += evPenalty(aKey, optimalForHero());

  // Execute
  const seat=state.hero;
  const node=state.nodes[seat]; node.seat.classList.remove("acting");

  if(action==="fold"){
    state.folded[seat]=true;
    node.seat.classList.add("folded"); node.seat.textContent="FOLD";
    endHand("hero_fold"); return;
  }
  if(action==="check"){
    showBetPlate(seat,"Check");
  }
  if(action==="call"){
    const paid=postTo(seat, state.currentBet);
    showBetPlate(seat, paid>=state.stacks[seat]+paid ? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
    if(state.allin[seat]){ endHand("hero_allin"); return; }
  }
  if(action==="allin"){
    state.currentBet = state.committed[seat] + state.stacks[seat];
    state.lastRaise  = Math.max(state.lastRaise, state.currentBet - state.committed[seat]);
    postTo(seat, state.currentBet);
    showBetPlate(seat,"All-in");
    endHand("hero_allin"); return;
  }
  if(action?.type==="raise"){
    const res = raiseTo(seat, action.to);
    if(res==="allin"){ endHand("hero_allin"); return; }
  }
  if(action?.type==="bet"){
    state.currentBet=action.to; state.lastRaise=action.to;
    postTo(seat, state.currentBet);
    showBetPlate(seat, `Bet ${action.to} BB`);
  }

  // Let the rest act to complete the round
  await runAfterHeroThisStreet();

  // If your target range is met, end here
  if(state.target==="preflop" && state.street==="preflop"){ endHand("range_end"); return; }
  if(state.target==="turn" && state.street==="turn"){ endHand("range_end"); return; }

  // Move to next street if >= 2 live and equalized
  const live=state.seats.filter(s=>!state.folded[s] && !state.allin[s]);
  if(live.length<=1){ endHand("last_player"); return; }
  if(!equalizedAmongLive()){ offerHero(); return; }

  if(state.street==="preflop"){ dealFlop(); await runBeforeHeroThisStreet(); offerHero(); return; }
  if(state.street==="flop"){ dealTurn(); await runBeforeHeroThisStreet(); offerHero(); return; }
  if(state.street==="turn"){ dealRiver(); await runBeforeHeroThisStreet(); offerHero(); return; }
  if(state.street==="river"){ endHand("river_end"); return; }
}

/* =========================================================
   End / Scoring / Showdown
   ========================================================= */
function revealSeat(seat){
  // only if reached showdown vs hero (not folded) or hero
  if(seat!==state.hero && !state.showdown?.has(seat)) return;
  const n=state.nodes[seat]; if(!n) return;
  const holder=document.createElement("div");
  holder.className="cards";
  holder.style.left=n.pos.x+"%";
  holder.style.top =`calc(${n.pos.y}% - 10%)`;
  state.hands[seat].forEach(c=> holder.appendChild(cardEl(c,true)) );
  tableEl.appendChild(holder);
}

function showResult(){
  const pct = scoreFromLoss(state.evLoss);
  scorePctEl.textContent = `${pct}%`;
  scorePctEl.classList.toggle("good", pct>=50);
  scorePctEl.classList.toggle("bad", pct<50);
  scoreVerdEl.textContent = pct>=85?"Excellent":pct>=70?"Strong":pct>=50?"Okay":"Needs Work";
  resultPanel.style.display="block";
}

function endHand(reason){
  if(state.ended) return; state.ended=true;
  clearActions();

  // compose showdown set: villains who interacted and didn't fold
  state.showdown = new Set(
    state.seats.filter(s => s!==state.hero && !state.folded[s] && state.interacted.has(s))
  );

  // Only reveal hero + showdown villains (if any)
  revealSeat(state.hero);
  state.showdown.forEach(s=>revealSeat(s));

  showResult();
}

nextBtn.onclick = ()=> startNewHand();

/* =========================================================
   New Hand
   ========================================================= */
async function startNewHand(){
  resultPanel.style.display="none";
  scorePctEl.textContent="—%"; scoreVerdEl.textContent="";
  state.ended=false;
  floatLayer.innerHTML=""; boardEl.innerHTML="";
  document.querySelectorAll(".cards").forEach(n=>n.remove());

  // seats from selector
  const key = playersSel.value;
  state.seats = TEMPLATES[key].slice();

  // hero drop
  heroSel.innerHTML = state.seats.map(s=>`<option value="${s}">${s}</option>`).join("");
  if(!state.seats.includes(heroSel.value)) heroSel.value="BTN";
  state.hero = heroSel.value;

  // target range
  state.target = rangeSel.value==="preflop" ? "preflop" :
                 rangeSel.value==="turn"    ? "turn"    : "river";

  // stacks/init
  state.stacks={}; state.committed={}; state.folded={}; state.allin={};
  state.pot=0; state.currentBet=0; state.lastRaise=1; state.evLoss=0;
  state.board=[]; state.hands={}; state.interacted=new Set();

  layoutSeats(); setHeroHighlight();
  state.seats.forEach(s=> state.stacks[s]=state.stackBB);

  // deal hands
  const taken=new Set();
  state.seats.forEach(s=> state.hands[s]=deal(2,taken));
  placeHeroCards(); renderBoard(); updateStacks();

  // preflop start
  state.street="preflop";
  startStreetAccounting(); renderHUD();

  // villains before hero act (preflop order)
  await runBeforeHeroThisStreet();
  offerHero();
}

/* =========================================================
   Wire up + boot
   ========================================================= */
newBtn.onclick = startNewHand;
playersSel.onchange = ()=> startNewHand();
heroSel.onchange    = ()=>{ state.hero=heroSel.value; setHeroHighlight(); placeHeroCards(); offerHero(); };
rangeSel.onchange   = ()=> startNewHand();

// Boot first hand
startNewHand();
</script>
</body>
</html>















