<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GTO Shark • Live Practice (Indigo/Teal Felt)</title>
<style>
  :root{
    --bg:#0b1220;         /* page */
    --felt:#0e192b;       /* table felt base */
    --felt-outer:#0a1322; /* table outer */
    --indigo:#5967ff;
    --teal:#11c5b3;
    --ink:#e6eefb;
    --muted:#96a3b8;
    --good:#22c55e;
    --warn:#f59e0b;
    --bad:#ef4444;
  }
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 1200px at 30% -10%, #132038, #0b1220 60%);
    color:var(--ink); font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    overflow-x:hidden;
  }
  /* header controls */
  .topbar{display:flex;gap:10px;align-items:center;justify-content:flex-end;padding:10px 14px}
  .brand{position:absolute;left:14px;top:10px;font-weight:800;letter-spacing:.2px;
         background:linear-gradient(90deg,#7ea2ff, #2fe0d3 70%); -webkit-background-clip:text; background-clip:text; color:transparent}
  select,button{background:#13223a;color:#d7e3fb;border:1px solid #2a3c5f;border-radius:10px;padding:8px 10px}
  button.primary{background:linear-gradient(135deg,#5d6bff,#1fd0c2); color:#08111f; font-weight:800; border:none}
  button.ghost{background:#102036}
  button:disabled{opacity:.55;cursor:not-allowed}

  /* layout */
  .app{display:grid; grid-template-columns:minmax(860px,1fr) 330px; gap:14px; padding:10px 14px 80px}
  @media (max-width:1200px){ .app{grid-template-columns:1fr} .sidebar{order:3} }

  /* table */
  .table-wrap{display:flex;justify-content:center;align-items:center}
  .table{
    position:relative; width:min(1200px,90vw); aspect-ratio:1/1; border-radius:50%;
    background:
      radial-gradient(60% 60% at 50% 45%, rgba(17,197,179,.22), rgba(17,197,179,0) 60%),
      radial-gradient(65% 65% at 50% 52%, #0d1b30 0%, #0a1527 55%, #0a1425 70%),
      radial-gradient(120% 120% at 50% 55%, var(--felt) 40%, var(--felt-outer) 100%);
    box-shadow:
      inset 0 0 120px rgba(95,110,255,.25),
      0 0 0 10px rgba(95,110,255,.15),
      0 0 80px rgba(18,230,208,.18);
  }

  /* seats */
  .seat{
    position:absolute; transform:translate(-50%,-50%);
    width:84px;height:84px;border-radius:999px;display:flex;align-items:center;justify-content:center;
    background:#111f34; border:2px solid #274165; color:#b8c7de; font-weight:800; letter-spacing:.5px;
    box-shadow:0 10px 22px rgba(0,0,0,.35);
  }
  .seat.hero{border-color:#2ed9c8; color:#dcfff9; box-shadow:0 0 26px rgba(46,217,200,.55)}
  .seat.acting{border-color:#ffbe3c; color:#ffe7b3; box-shadow:0 0 28px rgba(255,190,60,.55)}
  .seat.fold{border-color:#2a3447; color:#6e7c92; filter:grayscale(.4)}
  .stack{
    position:absolute; left:50%; top:calc(100% + 14px); transform:translateX(-50%);
    background:#0b1931;border:1px solid #324a74;color:#d4dfff;padding:2px 10px;border-radius:999px;font-size:12px;white-space:nowrap
  }

  /* hero cards pinned to seat */
  .heroCards{position:absolute; transform:translate(-50%,-70%); display:flex; gap:8px; z-index:6}
  /* board */
  .board{position:absolute; left:50%; top:48%; transform:translate(-50%,-50%); display:flex; gap:10px; z-index:5}

  /* cards */
  .card{
    width:84px;height:118px;border-radius:14px;
    background:linear-gradient(155deg,#fff,#eef1ff 55%, #dee6ff 100%);
    border:2px solid rgba(93,107,255,.9); box-shadow:0 14px 30px rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center; flex-direction:column
  }
  .rank{font-size:40px;font-weight:900;margin-top:-2px}
  .suit{font-size:30px;margin-top:-2px}
  .red{color:#e63f4c} .black{color:#0c1430}
  .board .card{width:76px;height:108px;border-radius:12px}

  /* HUD center */
  .hud{
    position:absolute; left:50%; top:56%; transform:translate(-50%,-50%);
    background:rgba(9,20,38,.7); border:1px solid #2b4168; color:#d8e3fb;
    padding:6px 10px; border-radius:10px; font-weight:800; display:flex; gap:10px; z-index:7; backdrop-filter:blur(2px)
  }

  /* chip plates (persist until next street) */
  .plate{
    position:absolute; transform:translate(-50%,-15px);
    background:linear-gradient(135deg,#15243d,#0c172b); border:1px solid rgba(95,110,255,.55);
    color:#d8e3ff; padding:4px 7px; border-radius:8px; font-weight:900; font-size:12px;
    display:flex; align-items:center; gap:6px; z-index:6; pointer-events:none;
    box-shadow:0 10px 20px rgba(0,0,0,.35)
  }
  .chip{width:14px;height:14px;border-radius:999px; background:
     radial-gradient(circle at 50% 50%, #f7b53f 0 26%, #7f44ff 28% 32%, #f7b53f 35% 60%, #7f44ff 63% 67%, #f7b53f 70%);
     border:1px solid rgba(247,181,63,.9)
  }

  /* action bar */
  .actionBar{
    margin-top:16px; display:flex; justify-content:center; gap:10px; flex-wrap:wrap
  }
  .btn{padding:14px 18px;border-radius:12px;border:1px solid #2c3f63;background:#0f213a;color:#d9e7ff;font-weight:900}
  .btn.primary{background:linear-gradient(135deg,#5c6aff,#1ed0c1); color:#08111f; border:none}
  .btn.danger{background:linear-gradient(135deg,#ff4b4b,#d82d2d); color:#fff; border:none}
  .btn.ghost{background:#10233f}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  /* panels */
  .panel{background:#0d1b30;border:1px solid #273b5c;border-radius:14px;padding:14px}
  .muted{color:var(--muted)}
  .result{display:none;background:linear-gradient(135deg,#5e6cff,#18cbbb);padding:14px;border-radius:12px;color:#08111f;font-weight:900}
  .score{font-size:44px}
  .logRow{display:flex;justify-content:space-between;align-items:center;background:#0c1a2f;border:1px solid #2a3c5f;border-radius:10px;padding:8px 10px;margin-bottom:8px}
  .good{color:var(--good)} .bad{color:var(--bad)}

  .footerPrompt{margin-top:10px;font-size:12px;color:#a9b7cf}
</style>
</head>
<body>

<div class="brand">GTO Shark • Live Practice</div>

<div class="topbar">
  <label class="muted">Players</label>
  <select id="players">
    <option value="9" selected>9-max</option>
    <option value="6">6-max</option>
  </select>

  <label class="muted">Hero</label>
  <select id="heroSel"></select>

  <label class="muted">Play-through</label>
  <select id="rangeSel">
    <option value="preflop">Preflop only</option>
    <option value="turn">Play to Turn</option>
    <option value="river" selected>Play to River</option>
  </select>

  <label class="muted">Start</label>
  <select id="startStreetSel">
    <option value="preflop" selected>Preflop</option>
    <option value="flop">Flop</option>
    <option value="turn">Turn</option>
    <option value="river">River</option>
  </select>

  <label class="muted">Scenario</label>
  <select id="scenarioSel">
    <option value="none" selected>None (Normal)</option>
    <option value="bvb">Blind vs Blind</option>
    <option value="bbvbtn">BB vs BTN</option>
    <option value="covbb">CO vs BB</option>
    <option value="utgvbb">UTG vs BB</option>
  </select>

  <button id="newHandBtn" class="primary">♻ New Hand</button>
</div>

<div class="app">
  <main>
    <div class="panel">
      <div class="table-wrap">
        <div id="table" class="table">
          <div id="board" class="board"></div>
          <div id="hud" class="hud"><span id="hudStreet">—</span> | <span id="hudPot">Pot —</span> | <span id="hudSPR">SPR —</span></div>
          <div id="seatsLayer"></div>
          <div id="platesLayer"></div>
        </div>
      </div>
      <div id="actionBar" class="actionBar"></div>
      <div class="footerPrompt" id="prompt">Engine loaded. Dealing…</div>
    </div>
  </main>

  <aside class="sidebar">
    <div id="result" class="result">
      <div class="score" id="scorePct"></div>
      <div id="scoreVerdict"></div>
    </div>
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <strong>Hand Log</strong>
        <button id="clearLog" class="ghost">Clear</button>
      </div>
      <div class="muted" style="font-size:12px;margin-bottom:6px">✅ ≥ 50% ❌ &lt; 50%</div>
      <div id="logList"></div>
    </div>
  </aside>
</div>

<script>
/* ========= RNG (seeded with Google Books length using your key) ========= */
const API_KEY = "AIzaSyBZh4GD0KX691kfF3eU45a71o1IHf5iL4U";
let _seed = Date.now()|0;
function xsSeed(n){ _seed = (n>>>0) || 0x9e3779b9 }
function xsRand(){ _seed^=_seed<<13; _seed^=_seed>>>17; _seed^=_seed<<5; return ((_seed>>>0)%1e6)/1e6 }
async function seedFromAPI(){
  try{
    const r = await fetch(`https://www.googleapis.com/books/v1/volumes?q=poker&maxResults=5&key=${API_KEY}`,{cache:"no-store"});
    const j = await r.json(); xsSeed(JSON.stringify(j).length ^ Date.now());
  }catch{ xsSeed(Date.now() ^ 0x9e3779b9) }
}
const sleep = ms => new Promise(r=>setTimeout(r,ms));

/* ========= DOM refs ========= */
const tableEl   = document.getElementById('table');
const seatsLayer= document.getElementById('seatsLayer');
const plates    = document.getElementById('platesLayer');
const boardEl   = document.getElementById('board');
const hudStreet = document.getElementById('hudStreet');
const hudPot    = document.getElementById('hudPot');
const hudSPR    = document.getElementById('hudSPR');
const promptEl  = document.getElementById('prompt');
const actionBar = document.getElementById('actionBar');
const resultBox = document.getElementById('result');
const scorePct  = document.getElementById('scorePct');
const scoreVerd = document.getElementById('scoreVerdict');
const logList   = document.getElementById('logList');

const playersSel= document.getElementById('players');
const heroSel   = document.getElementById('heroSel');
const rangeSel  = document.getElementById('rangeSel');
const startSel  = document.getElementById('startStreetSel');
const scenSel   = document.getElementById('scenarioSel');
const newBtn    = document.getElementById('newHandBtn');
const clearBtn  = document.getElementById('clearLog');

/* ========= Cards & rendering ========= */
const RANKS=["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const SUITS=["♠","♥","♦","♣"];
const suitCls = s => (s==="♥"||s==="♦")?"red":"black";
function makeCard(face){ const [r,s]=[face[0],face[1]]; const d=document.createElement('div');
  d.className='card'; d.innerHTML=`<div class="rank ${suitCls(s)}">${r}</div><div class="suit ${suitCls(s)}">${s}</div>`; return d }
function randomCard(taken){
  let c; do{ c=RANKS[Math.floor(xsRand()*13)]+SUITS[Math.floor(xsRand()*4)] }while(taken.has(c));
  taken.add(c); return c
}
function dealNCards(n,taken){ const a=[]; for(let i=0;i<n;i++) a.push(randomCard(taken)); return a }

/* ========= Positions & acting order ========= */
const TEMPLATE_9 = ["UTG","UTG+1","UTG+2","LJ","HJ","CO","BTN","SB","BB"];
const TEMPLATE_6 = ["UTG","HJ","CO","BTN","SB","BB"];
const ORDER_PRE  = s => (s.players===9?TEMPLATE_9:TEMPLATE_6);
const ORDER_POST = s => {
  const base = s.players===9?TEMPLATE_9:TEMPLATE_6;
  const ixSB = base.indexOf("SB");
  return [...base.slice(ixSB), ...base.slice(0,ixSB)];
}

/* ========= State ========= */
const S = {
  players: 9,
  seats: [...TEMPLATE_9],
  hero: "BTN",
  startStreet: "preflop",
  playTo: "river",
  scenario: "none",

  /* per hand */
  board: [],
  hands: {},           // seat -> [c1,c2]
  stacks: {},          // seat -> bb
  committed: {},       // seat -> bb for current street
  folded: {},          // seat -> boolean
  interacting: new Set(), // villains who put chips into a pot where hero is present
  street: "preflop",
  pot: 0,
  currentBet: 0,
  lastRaiseSize: 1,    // default = 1bb first raise size when needed
  stackBB: 100,        // default per seat
  heroPlates: [],
  showdownSet: new Set(),
  evLoss: 0,           // score accumulator
  snapshot: null,      // for replay (optional)
  heroCardsNode: null
};

/* ========= Layout: build seats in a circle ========= */
const NODES = {}; // seat -> {seat, stack, plate, pos:{x%,y%}}
function layoutSeats(){
  seatsLayer.innerHTML=""; plates.innerHTML="";
  const N = S.players;
  const names = S.seats;
  const r = tableEl.clientWidth*0.40;           // radius
  const cx = tableEl.clientWidth/2, cy = tableEl.clientHeight/2;
  const startAngle = -Math.PI/2;                // top

  for(let i=0;i<N;i++){
    const ang = startAngle + i*(2*Math.PI/N);
    const x = cx + r*Math.cos(ang), y = cy + r*Math.sin(ang);

    const seat = document.createElement('div');
    seat.className = "seat";
    seat.style.left = `${x}px`;
    seat.style.top  = `${y}px`;
    seat.textContent = names[i];

    const stack = document.createElement('div');
    stack.className = "stack";
    stack.id = `stack-${names[i]}`;
    stack.textContent = "—";
    seat.appendChild(stack);

    seatsLayer.appendChild(seat);

    NODES[names[i]] = { seat, stack, pos:{x,y}, plate:null, label:names[i] };
  }
  highlightHero();
}

function highlightHero(){
  S.seats.forEach(p=>{
    NODES[p].seat.classList.toggle('hero', p===S.hero)
  });
}

/* ========= HUD & UI ========= */
function setPrompt(txt){ promptEl.textContent = txt }
function updateHUD(){
  hudStreet.textContent = S.street.toUpperCase();
  hudPot.textContent    = `Pot ${S.pot.toFixed(1)} BB`;
  const live = S.seats.filter(p=>!S.folded[p]);
  const eff  = live.length? Math.min(...live.map(p=>Math.max(0.1,S.stacks[p]))):S.stackBB;
  const spr  = (eff / Math.max(1,S.pot)).toFixed(1);
  hudSPR.textContent    = `SPR ${spr}`;
}
function setActing(seat,on){
  NODES[seat].seat.classList.toggle('acting', !!on);
  if(on){ setTimeout(()=>NODES[seat].seat.classList.remove('acting'), 1100) }
}

/* ========= Plates (chips in front of seat; persist this street) ========= */
function clearStreetPlates(){
  S.seats.forEach(p=>{
    if(NODES[p].plate){ NODES[p].plate.remove(); NODES[p].plate=null }
  });
}
function putPlate(seat, label){
  const n = NODES[seat];
  if(n.plate){ n.plate.remove() }
  const d = document.createElement('div');
  d.className = "plate";
  d.style.left = `${n.pos.x}px`;
  d.style.top  = `${n.pos.y - 52}px`; // toward center
  d.innerHTML  = `<span class="chip"></span><span>${label}</span>`;
  plates.appendChild(d);
  n.plate = d;
}

/* ========= Board & hero cards ========= */
function renderBoard(){
  boardEl.innerHTML = "";
  S.board.forEach(c => boardEl.appendChild(makeCard(c)));
}
function renderHeroCards(){
  if(S.heroCardsNode){ S.heroCardsNode.remove(); S.heroCardsNode=null }
  const h = document.createElement('div');
  h.className = "heroCards";
  const pos = NODES[S.hero].pos;
  h.style.left = `${pos.x}px`;
  h.style.top  = `${pos.y}px`;
  (S.hands[S.hero]||[]).forEach(c=>h.appendChild(makeCard(c)));
  tableEl.appendChild(h);
  S.heroCardsNode = h;
}

/* ========= Accounting ========= */
function resetCommitted(){ S.seats.forEach(p=> S.committed[p]=0) }
function toCall(p){ return Math.max(0, S.currentBet - S.committed[p]) }
function payTo(p, target){                          // move chips from stack to committed
  const need = Math.max(0, target - S.committed[p]);
  const afford = Math.min(need, S.stacks[p]);
  S.stacks[p] = +(S.stacks[p] - afford).toFixed(1);
  S.committed[p] = +(S.committed[p] + afford).toFixed(1);
  S.pot = +(S.pot + afford).toFixed(1);
  NODES[p].stack.textContent = `${S.stacks[p].toFixed(1)} BB`;
  updateHUD();
  return afford;
}
function everyoneMatched(){
  return S.seats.filter(p=>!S.folded[p]).every(p => S.committed[p] === S.currentBet || S.stacks[p]===0)
}

/* ========= “Simplified GTO” policy (mixed freq; stronger = aggressive) ========= */
function handStrength(pair){
  const [a,b] = pair;
  const r1 = RANKS.indexOf(a[0]), r2 = RANKS.indexOf(b[0]);
  const suited = a[1]===b[1], pairr = a[0]===b[0], gap = Math.abs(r1-r2);
  let s = pairr ? (100 - r1*3) : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?5:0);
  return s + xsRand()*2;
}
function postStrength(pair,board){
  const ranks= board.map(c=>c[0]);
  const high = ranks.filter(r=>["A","K","Q","J","T"].includes(r)).length*2;
  const pair = ranks.some(r=>r===pair[0][0]||r===pair[1][0])?8:0;
  const suited= (pair[0][1]===pair[1][1])?2:0;
  return high + pair + suited + xsRand()*2;
}
function policy(street, seat){      // returns: fold | call | raiseS | raiseM | raiseB | betS/M/B | check | jam
  if(street==="preflop"){
    const s = handStrength(S.hands[seat]);
    if(s>92) return "raiseB";
    if(s>84) return xsRand()<.6 ? "raiseM" : "raiseS";
    if(s>70) return "call";
    return xsRand()<.1 ? "raiseS" : "fold";
  }
  const s = postStrength(S.hands[seat], S.board);
  if(s>16) return xsRand()<.2 ? "jam" : "betB";
  if(s>12) return xsRand()<.4 ? "betM" : "check";
  if(s>8)  return xsRand()<.5 ? "betS" : "check";
  return "check";
}

/* ========= EV grading ========= */
function evPenalty(street, actionKey, optimalKey){
  if(actionKey===optimalKey) return 0;
  const fam = a => a.startsWith("raise")?"Raise" : a.startsWith("bet")?"Bet" : (a==="jam"?"All-in":a[0].toUpperCase()+a.slice(1));
  const W = {
    preflop:{Fold:.9, Call:.55, Raise:.65, "All-in":1.2},
    flop:{Check:.25, Bet:.42, "All-in":.8},
    turn:{Check:.30, Bet:.5, "All-in":.9},
    river:{Check:.35, Bet:.62, "All-in":1.05},
  };
  let w = (W[street][fam(actionKey)] ?? .55) + xsRand()*0.12;
  // Bonus logic: folding trash preflop = perfect
  if(street==="preflop" && actionKey==="fold" && handStrength(S.hands[S.hero])<66) return 0;
  if(actionKey==="jam"){
    const str = street==="preflop"? handStrength(S.hands[S.hero]) : postStrength(S.hands[S.hero], S.board);
    if(str<78) w += .7;
  }
  if(fam(actionKey)!==fam(optimalKey)) w += .25;
  return +w.toFixed(2);
}
function scoreNow(){ return Math.max(0, Math.min(100, Math.round(100 - S.evLoss*24)))}

/* ========= Action bar ========= */
function clearActions(){ actionBar.innerHTML="" }
function addBtn(text, cls, cb, disabled=false){
  const b=document.createElement('button'); b.className=`btn ${cls}`; b.textContent=text; b.onclick=cb; b.disabled=disabled; actionBar.appendChild(b); return b
}
function offerActions(){
  clearActions();
  const need = toCall(S.hero);
  const eff  = S.stacks[S.hero];

  // Fold is always available
  addBtn("Fold","ghost",()=>heroActs("fold"));
  if(eff<=0){ addBtn("All-in","danger",()=>{},true); return }

  /* Preflop → Check/Call/Raises */
  if(S.street==="preflop"){
    if(need===0) addBtn("Check","ghost",()=>heroActs("check"));
    if(need>0)   addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`,"primary",()=>heroActs("call"));

    // propose 3 open/raise sizes relative to current pot / bet
    const base = Math.max(2, S.currentBet ? Math.round(S.currentBet*1.8) : 2.5);
    const sizes = [base, base+2, Math.max(base+4, Math.round(base*1.5))];
    sizes.forEach(x=>{
      const to = Math.min(S.committed[S.hero]+eff, Math.max(S.currentBet + S.lastRaiseSize, x));
      const jam = to >= S.committed[S.hero]+eff - 1e-9;
      addBtn(jam? "All-in" : `Raise to ${to.toFixed(1)} BB`, jam?"danger":"primary",
        ()=> heroActs(jam? "jam" : `raiseTo:${to}`));
    });
  } else {
    if(need===0) addBtn("Check","ghost",()=>heroActs("check"));
    if(need>0)   addBtn(`Call ${Math.min(need,eff).toFixed(1)} BB`,"primary",()=>heroActs("call"));

    const p = Math.max(2, Math.round(S.pot));
    const betSizes = [Math.round(p*0.33), Math.round(p*0.5), Math.round(p*0.75)];
    betSizes.forEach(x=>{
      const to = Math.min(S.committed[S.hero]+eff, Math.max(S.currentBet, x));
      const jam = to >= S.committed[S.hero]+eff - 1e-9;
      addBtn(jam? "All-in" : (need>0?`Raise to ${to} BB`:`Bet ${to} BB`), jam?"danger":"primary",
        ()=> heroActs(jam? "jam" : (need>0? `raiseTo:${to}` : `bet:${to}`)));
    });
  }
}

/* ========= Villain flows ========= */
async function vPre(seat){
  if(S.folded[seat]) return;
  setActing(seat,true);
  await sleep(450 + Math.floor(xsRand()*450));
  const need = toCall(seat), rs = S.stacks[seat];
  const pol = policy("preflop", seat);

  if(need>0){
    if(pol.startsWith("raise") && rs>need && xsRand()<.55){
      const mult = pol==="raiseB"?3.2 : pol==="raiseM"?2.4 : 1.8;
      let to = Math.max(S.currentBet + S.lastRaiseSize, +(S.currentBet*mult).toFixed(1));
      const maxTo = S.committed[seat]+rs;
      if(to >= maxTo){ S.currentBet = maxTo; payTo(seat,S.currentBet); putPlate(seat, `All-in`); setActing(seat,false); return "jam" }
      const prev = S.currentBet;
      S.lastRaiseSize = Math.max(1, to - prev);
      S.currentBet = to;
      payTo(seat,S.currentBet); putPlate(seat, `Raise ${(S.currentBet - S.committed[seat] + 0).toFixed(1)} BB`);
      S.interacting.add(seat);
      setActing(seat,false); return;
    }
    if(xsRand()<.78 || rs<=need){
      const paid = payTo(seat, S.currentBet); putPlate(seat, paid>=rs? "Call all-in" : `Call ${paid.toFixed(1)} BB`);
      S.interacting.add(seat);
    }else{
      S.folded[seat]=true; NODES[seat].seat.classList.add('fold'); putPlate(seat, "Fold");
    }
    setActing(seat,false);
  } else {
    if(pol.startsWith("raise") && rs>0 && xsRand()<.35){
      let to = Math.max(S.currentBet + S.lastRaiseSize, Math.round(2.3));
      const maxTo = S.committed[seat]+rs;
      if(to >= maxTo){ S.currentBet = maxTo; payTo(seat,S.currentBet); putPlate(seat, "All-in"); setActing(seat,false); return "jam" }
      S.lastRaiseSize = Math.max(1, to - S.currentBet);
      S.currentBet = to; payTo(seat,S.currentBet); putPlate(seat, `Bet ${to.toFixed(1)} BB`); S.interacting.add(seat);
    } else {
      putPlate(seat, "Check");
    }
    setActing(seat,false);
  }
}
async function vPost(seat){
  if(S.folded[seat]) return;
  setActing(seat,true);
  await sleep(450 + Math.floor(xsRand()*450));
  const need = toCall(seat), rs = S.stacks[seat];
  const pol = policy(S.street, seat);

  if(need>0){
    if((pol.startsWith("bet") || pol==="jam") && rs>need && xsRand()<.28){
      let add = Math.max(2, Math.round(S.pot*0.45));
      let to  = S.currentBet + add;
      const maxTo = S.committed[seat] + rs;
      if(to >= maxTo){ S.currentBet=maxTo; payTo(seat,S.currentBet); putPlate(seat, "All-in"); setActing(seat,false); return "jam" }
      const prev=S.currentBet;
      S.lastRaiseSize = Math.max(1, to - prev);
      S.currentBet=to; payTo(seat,S.currentBet); putPlate(seat, `Raise ${(to - prev).toFixed(1)} BB`); S.interacting.add(seat);
    }else if(xsRand()<.76 || rs<=need){
      const paid = payTo(seat,S.currentBet); putPlate(seat, paid>=rs? "Call all-in" : `Call ${paid.toFixed(1)} BB`); S.interacting.add(seat);
    }else{
      S.folded[seat]=true; NODES[seat].seat.classList.add('fold'); putPlate(seat, "Fold");
    }
    setActing(seat,false); return;
  }

  if(pol==="jam" && rs>0 && xsRand()<.25){
    const to = S.committed[seat] + rs; S.currentBet = to; payTo(seat,S.currentBet); putPlate(seat,"All-in"); S.interacting.add(seat);
  } else if(pol.startsWith("bet") && rs>0 && xsRand()<.45){
    const base = pol==="betB"? Math.max(2, Math.round(S.pot*0.7))
               : pol==="betM"? Math.max(2, Math.round(S.pot*0.5))
               : Math.max(2, Math.round(S.pot*0.33));
    const to = Math.min(S.committed[seat]+rs, Math.max(S.currentBet, base));
    const add = Math.max(0, to - S.currentBet);
    S.lastRaiseSize = Math.max(1, add);
    S.currentBet = to; payTo(seat,S.currentBet);
    putPlate(seat, to>=S.committed[seat]+rs? "All-in" : `Bet ${add} BB`); S.interacting.add(seat);
  } else {
    putPlate(seat, "Check");
  }
  setActing(seat,false);
}

/* ========= Hero acts (ends hand if hero’s sequence ended) ========= */
async function heroActs(action){
  // EV grading vs local optimal (for training)
  const opt = policy(S.street, S.hero);
  const actKey = action.startsWith("raiseTo") ? "raiseM"
              : action.startsWith("bet:")    ? "betM"
              : action;
  S.evLoss += evPenalty(S.street, actKey, opt);

  // Execute action
  if(S.street==="preflop"){
    if(action==="fold"){ S.folded[S.hero]=true; NODES[S.hero].seat.classList.add('fold'); putPlate(S.hero,"Fold"); return finishOrNext() }
    if(action==="check"){ putPlate(S.hero,"Check") }
    if(action==="call"){ const paid = payTo(S.hero,S.currentBet); putPlate(S.hero, paid>=S.stacks[S.hero]+paid? "Call all-in" : `Call ${paid.toFixed(1)} BB`) }
    if(action.startsWith("raiseTo")){
      const to=parseFloat(action.split(":")[1]); const prev=S.currentBet;
      S.lastRaiseSize = Math.max(1, to - prev);
      S.currentBet=Math.max(S.currentBet,to); payTo(S.hero,S.currentBet);
      putPlate(S.hero, prev? `Raise ${(S.currentBet-prev).toFixed(1)} BB` : `Open ${S.currentBet.toFixed(1)} BB`);
      S.interacting.add(S.hero);
    }
    if(action==="jam"){ const to=S.committed[S.hero]+S.stacks[S.hero]; S.currentBet=Math.max(S.currentBet,to); payTo(S.hero,S.currentBet); putPlate(S.hero,"All-in"); S.interacting.add(S.hero) }

    // remaining villains act after hero (BTN → SB → BB etc.)
    const order = ORDER_PRE(S);
    const start = order.indexOf(S.hero)+1;
    for(let i=start;i<order.length;i++){
      const res = await vPre(order[i]); if(res==="jam") return allInRunout();
    }
    return finishOrNext();

  } else {
    if(action==="fold"){ S.folded[S.hero]=true; NODES[S.hero].seat.classList.add('fold'); putPlate(S.hero,"Fold"); return finishOrNext() }
    if(action==="check"){ putPlate(S.hero,"Check") }
    if(action==="call"){ const paid = payTo(S.hero,S.currentBet); putPlate(S.hero, paid>=S.stacks[S.hero]+paid? "Call all-in" : `Call ${paid.toFixed(1)} BB`) }
    if(action.startsWith("bet:") || action.startsWith("raiseTo")){
      const to=parseFloat(action.split(":")[1]); const prev=S.currentBet;
      S.lastRaiseSize = Math.max(1, to - prev);
      S.currentBet=Math.max(S.currentBet,to); payTo(S.hero,S.currentBet);
      putPlate(S.hero, (prev && to>prev)? `Raise ${(to-prev).toFixed(1)} BB` : `Bet ${Math.max(1,to-prev)} BB`); S.interacting.add(S.hero)
    }
    if(action==="jam"){ const to=S.committed[S.hero]+S.stacks[S.hero]; S.currentBet=Math.max(S.currentBet,to); payTo(S.hero,S.currentBet); putPlate(S.hero,"All-in"); S.interacting.add(S.hero) }

    // postflop: all villains act in order (SB,BB,UTG,...)
    for(const seat of ORDER_POST(S)){ if(seat===S.hero) continue; const res = await vPost(seat); if(res==="jam") return allInRunout() }
    return finishOrNext();
  }
}

/* ========= Street transitions ========= */
async function finishOrNext(){
  if(!everyoneMatched()){ offerActions(); return }

  // End here if user's configured range reached or hero already folded
  if((S.playTo==="preflop" && S.street==="preflop") || S.folded[S.hero]) return finish();

  if(S.street==="preflop"){ await dealFlop(); offerActions(); return }
  if(S.playTo==="turn" && S.street==="turn") return finish();
  if(S.street==="flop"){ await dealTurn(); offerActions(); return }
  if(S.street==="turn"){ await dealRiver(); return finish() }
  if(S.street==="river") return finish();
}

async function allInRunout(){
  if(S.street==="preflop"){ await dealFlop(); if(S.playTo==="preflop") return finish() }
  if(S.street==="flop"){ await dealTurn(); if(S.playTo==="turn") return finish() }
  if(S.street==="turn"){ await dealRiver() }
  return finish();
}

async function dealFlop(){
  clearStreetPlates();
  const taken=new Set(Object.values(S.hands).flat());
  S.board = dealNCards(3, taken);
  S.street="flop"; S.currentBet=0; S.lastRaiseSize=1; resetCommitted();
  renderBoard(); updateHUD(); setPrompt("FLOP: Your action when prompted.");
  await sleep(250);
}
async function dealTurn(){
  clearStreetPlates();
  const taken=new Set(Object.values(S.hands).flat().concat(S.board));
  S.board.push(randomCard(taken));
  S.street="turn"; S.currentBet=0; S.lastRaiseSize=1; resetCommitted();
  renderBoard(); updateHUD(); setPrompt("TURN: Your action when prompted.");
  await sleep(250);
}
async function dealRiver(){
  clearStreetPlates();
  const taken=new Set(Object.values(S.hands).flat().concat(S.board));
  S.board.push(randomCard(taken));
  S.street="river"; S.currentBet=0; S.lastRaiseSize=1; resetCommitted();
  renderBoard(); updateHUD(); setPrompt("RIVER: Your action when prompted.");
  await sleep(250);
}

/* ========= Finish & results ========= */
function showdownReveal(){
  S.showdownSet = new Set(S.seats.filter(p => p!==S.hero && !S.folded[p] && S.interacting.has(p)));
  // reveal hero
  const heroHolder = document.createElement('div');
  heroHolder.style.position="absolute"; heroHolder.style.zIndex=8;
  const hp = NODES[S.hero].pos; heroHolder.style.left=`${hp.x}px`; heroHolder.style.top=`${hp.y-110}px`; heroHolder.style.transform="translate(-50%,-50%)";
  heroHolder.style.display="flex"; heroHolder.style.gap="8px";
  S.hands[S.hero].forEach(c=> heroHolder.appendChild(makeCard(c)));
  plates.appendChild(heroHolder);

  // reveal only showdown villains
  S.showdownSet.forEach(seat=>{
    const p = NODES[seat].pos;
    const d = document.createElement('div');
    d.style.position="absolute"; d.style.zIndex=8; d.style.left=`${p.x}px`; d.style.top=`${p.y-110}px`; d.style.transform="translate(-50%,-50%)"; d.style.display="flex"; d.style.gap="8px";
    S.hands[seat].forEach(c=> d.appendChild(makeCard(c)));
    plates.appendChild(d);
  });
}
function verdict(p){ return p>=85?"Excellent":p>=70?"Strong":p>=50?"Okay":"Needs work" }

function finish(){
  showdownReveal();
  clearActions();
  const pct = scoreNow();
  resultBox.style.display="block";
  scorePct.textContent = `${pct}%`;
  scoreVerd.textContent= verdict(pct);
  scorePct.className = `score ${pct>=50?'good':'bad'}`;

  const row = document.createElement('div');
  row.className="logRow";
  row.innerHTML = `<div>${S.hero} • ${S.players}-max • ${S.street.toUpperCase()}</div>
                   <div class="${pct>=50?'good':'bad'}"><strong>${pct}%</strong> ${pct>=50?'✅':'❌'}</div>`;
  logList.prepend(row);

  addBtn("Next Hand","primary", startNewHand);
}

/* ========= NEW HAND ========= */
async function startNewHand(){
  resultBox.style.display="none"; scorePct.textContent=""; scoreVerd.textContent="";
  clearStreetPlates(); actionBar.innerHTML=""; boardEl.innerHTML="";
  S.evLoss=0; S.pot=0; S.board=[]; S.interacting.clear(); S.showdownSet.clear();

  // prefs
  S.players = parseInt(playersSel.value,10);
  S.seats   = (S.players===9? [...TEMPLATE_9] : [...TEMPLATE_6]);
  // (rebuild hero list)
  heroSel.innerHTML = S.seats.map(p=>`<option value="${p}">${p}</option>`).join("");
  if(!S.seats.includes(S.hero)) S.hero=S.seats.includes("BTN")?"BTN":S.seats[0];
  heroSel.value = S.hero;

  S.playTo  = rangeSel.value;
  S.startStreet = startSel.value;
  S.scenario = scenSel.value;

  layoutSeats(); highlightHero();
  // init stacks
  S.seats.forEach(p=>{ S.stacks[p]=S.stackBB; S.folded[p]=false; NODES[p].stack.textContent=`${S.stackBB.toFixed(1)} BB`; NODES[p].seat.classList.remove('fold') });

  // seed RNG
  await seedFromAPI();
  await sleep(200);

  // deal hole cards
  const taken = new Set();
  S.seats.forEach(p => S.hands[p] = dealNCards(2, taken));
  renderHeroCards();

  // preflop blinds (only when we start at preflop)
  resetCommitted(); S.currentBet=0; S.lastRaiseSize=1;
  if(S.startStreet==="preflop"){
    payTo("SB", 0.5); putPlate("SB","SB 0.5 BB");
    payTo("BB", 1.0); putPlate("BB","BB 1.0 BB");
    S.currentBet = 1.0; S.lastRaiseSize=1.0;
  }

  // start board per startStreet
  if(S.startStreet==="flop"){ S.board = dealNCards(3, taken) }
  if(S.startStreet==="turn"){ S.board = [...dealNCards(3,taken), randomCard(taken)] }
  if(S.startStreet==="river"){ S.board = [...dealNCards(3,taken), randomCard(taken), randomCard(taken)] }
  renderBoard();

  // scenario folding (pre-setup)
  if(S.scenario==="bvb"){ // folds to SB and BB
    S.seats.forEach(p=>{ if(!["SB","BB"].includes(p)){ S.folded[p]=true; NODES[p].seat.classList.add('fold') }});
  }
  if(S.scenario==="bbvbtn"){
    S.seats.forEach(p=>{ if(!["BB","BTN"].includes(p)){ S.folded[p]=true; NODES[p].seat.classList.add('fold') }});
  }
  if(S.scenario==="covbb"){
    S.seats.forEach(p=>{ if(!["CO","BB"].includes(p)){ S.folded[p]=true; NODES[p].seat.classList.add('fold') }});
  }
  if(S.scenario==="utgvbb"){
    S.seats.forEach(p=>{ if(!["UTG","BB"].includes(p)){ S.folded[p]=true; NODES[p].seat.classList.add('fold') }});
  }

  // choose street to start
  S.street = S.startStreet;
  updateHUD();
  setPrompt(`${S.street.toUpperCase()}: Your action appears below the table.`);

  // pre-hero actors act FIRST in correct order for the starting street
  if(S.street==="preflop"){
    const order = ORDER_PRE(S);
    const preIndex = order.indexOf(S.hero);
    for(let i=0;i<preIndex;i++){
      const seat = order[i]; if(S.folded[seat]) continue;
      const res = await vPre(seat); if(res==="jam") { offerActions(); return allInRunout() }
    }
    offerActions();
  } else {
    // postflop order starts at SB, then BB, UTG, ...
    const order = ORDER_POST(S);
    const heroIx = order.indexOf(S.hero);
    for(let i=0;i<heroIx;i++){
      const seat = order[i]; if(S.folded[seat]) continue;
      const res = await vPost(seat); if(res==="jam"){ offerActions(); return allInRunout() }
    }
    offerActions();
  }
}

/* ========= Wiring & boot ========= */
playersSel.onchange = ()=> startNewHand();
heroSel.onchange    = ()=>{ S.hero = heroSel.value; highlightHero(); renderHeroCards(); }
rangeSel.onchange   = ()=> startNewHand();
startSel.onchange   = ()=> startNewHand();
scenSel.onchange    = ()=> startNewHand();
newBtn.onclick      = startNewHand;
clearBtn.onclick    = ()=>{ localStorage.removeItem("gto_log_v1"); logList.innerHTML="" }

window.addEventListener('load', async ()=>{
  await startNewHand();
});
</script>

</body>
</html>















