<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>GTO Shark • Live Practice</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0f172a;    /* slate-900 */
      --card: #ffffff;  /* white face for cards */
      --ink: #e2e8f0;   /* slate-200 */
      --indigo: #4f46e5;
      --teal: #14b8a6;
      --slate8: #1e293b;
    }
    body { font-family: "Inter", sans-serif; background: var(--bg); color: var(--ink); overflow-x: hidden; }

    /* Table */
    .table-ring {
      width: 620px; height: 620px; border-radius: 9999px;
      border: 6px solid rgba(79,70,229,.35);
      box-shadow: 0 0 40px rgba(79,70,229,.15) inset;
      background: radial-gradient(ellipse at center, rgba(2,6,23,.92) 0%, rgba(2,6,23,.62) 58%, rgba(2,6,23,.28) 100%);
      position: relative; z-index: 1;
    }

    /* Seats + stacks */
    .seat {
      position: absolute; transform: translate(-50%, -50%);
      background: rgba(30,41,59,.92); border: 1px solid rgba(100,116,139,.45);
      width: 68px; height: 68px; border-radius: 9999px;
      display: flex; align-items: center; justify-content: center;
      font-size: 12px; font-weight: 800; color: #94a3b8; text-transform: uppercase;
      transition: all .3s ease;
    }
    .seat.hero { border-color: #f59e0b; color: #facc15; box-shadow: 0 0 22px rgba(245,158,11,.3); }
    .stack {
      position: absolute; transform: translate(-50%, -50%);
      top: calc(100% + 18px); left: 50%;
      background: #0b1220; border: 1px solid rgba(99,102,241,.5);
      padding: 2px 10px; border-radius: 9999px; font-size: 12px; color: #c7d2fe;
      white-space: nowrap;
    }

    /* Cards */
    .card {
      width: 62px; height: 86px; border-radius: 12px;
      display: flex; align-items: center; justify-content: center; flex-direction: column;
      background: var(--card); border: 2px solid var(--indigo);
      font-weight: 800; letter-spacing: .2px; box-shadow: 0 8px 24px rgba(0,0,0,.25);
    }
    .rank { font-size: 22px; line-height: 1; }
    .suit { font-size: 18px; line-height: 1; margin-top: 2px; }
    .red { color: #ef4444; }
    .black { color: #0f172a; }

    .board-card { width: 56px; height: 78px; border-radius: 10px; }
    .hero-cards .card { box-shadow: 0 10px 28px rgba(79,70,229,.35); }

    /* HUD */
    .hud {
      position: absolute; top: 45%; left: 50%; transform: translate(-50%,-50%);
      background: rgba(2,6,23,.8); border: 1px solid rgba(99,102,241,.35);
      padding: .4rem .75rem; border-radius: .75rem; display: flex; gap: .5rem;
      font-weight: 700; font-size: 14px; color: #c7d2fe; backdrop-filter: blur(3px);
      z-index: 50; text-shadow: 0 1px 2px rgba(0,0,0,.5);
    }
    .hud .sep { opacity: .6; }

    /* Buttons */
    .btn { font-weight: 700; padding: .8rem 1.2rem; border-radius: .65rem; transition: .15s; }
    .btn-primary { background: var(--indigo); color: white; }
    .btn-primary:hover { filter: brightness(1.08); transform: translateY(-1px); }
    .btn-ghost { background: rgba(20,184,166,0.08); color: #5eead4; border: 1px solid rgba(45,212,191,.35); }
    .btn-ghost:hover { background: rgba(20,184,166,0.14); }
    .btn-danger {
      background: linear-gradient(135deg, #ef4444, #dc2626); color: #fff;
      box-shadow: 0 6px 18px rgba(239,68,68,.35);
    }
    .btn-danger:hover { filter: brightness(1.08); transform: translateY(-1px); }

    /* Panels */
    .kpi { background: #0b1220; border: 1px solid #374151; border-radius: .75rem; padding: .75rem 1rem; }
    .divider { height: 1px; background: rgba(148,163,184,.18); }

    /* Animations */
    .fade-in { animation: fade .22s ease-out; }
    @keyframes fade { from { opacity: 0; transform: translateY(6px);} to { opacity: 1; transform: translateY(0);} }

    .float-chip {
      position: absolute; padding: .35rem .6rem; border-radius: .65rem; font-size: 12px; font-weight: 800;
      background: #0b1220; border: 1px solid rgba(99,102,241,.6); color: #c7d2fe; white-space: nowrap;
      opacity: 0; transform: translate(-50%, -8px); animation: bubble 2.2s ease-out forwards;
    }
    @keyframes bubble {
      0% { opacity: 0; transform: translate(-50%, 8px); }
      20% { opacity: 1; transform: translate(-50%, 0); }
      80% { opacity: 1; transform: translate(-50%, -10px); }
      100% { opacity: 0; transform: translate(-50%, -18px); }
    }
  </style>
</head>

<body class="p-4 md:p-6">
  <header class="flex flex-col gap-4 md:flex-row md:items-end md:justify-between mb-6">
    <div>
      <h1 class="text-3xl font-extrabold text-indigo-400">GTO Shark • Live Practice</h1>
      <p class="text-slate-400 text-sm">Full-hand drills with villain responses, dynamic stacks, cinematic pacing.</p>
    </div>
    <div class="flex flex-wrap items-center gap-3">
      <label class="text-xs text-slate-400 block">Game</label>
      <select id="gameType" class="bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm">
        <option value="cash_100">Cash — 100bb</option>
        <option value="mtt_40">MTT (ChipEV) — 40bb</option>
      </select>
      <label class="text-xs text-slate-400 block ml-3">Start from</label>
      <select id="startStreet" class="bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm">
        <option value="preflop">Preflop</option>
        <option value="flop">Flop</option>
        <option value="turn">Turn</option>
        <option value="river">River</option>
      </select>
      <button id="newHand" class="btn btn-primary">♻️ New Scenario</button>
    </div>
  </header>

  <section class="relative mx-auto table-ring flex items-center justify-center overflow-hidden">
    <div id="hud" class="hud">
      <span id="hudStreet">—</span>
      <span class="sep">–</span>
      <span id="hudPot">Pot: —</span>
      <span class="sep">|</span>
      <span id="hudSPR">SPR: —</span>
    </div>

    <div id="seat-BTN" class="seat hero" style="top: 92%; left: 50%;">BTN<span id="stack-BTN" class="stack">—</span></div>
    <div id="seat-SB"  class="seat" style="top: 78%; left: 18%;">SB<span id="stack-SB" class="stack">—</span></div>
    <div id="seat-BB"  class="seat" style="top: 48%; left: 6%;">BB<span id="stack-BB" class="stack">—</span></div>
    <div id="seat-UTG" class="seat" style="top: 8%;  left: 50%;">UTG<span id="stack-UTG" class="stack">—</span></div>
    <div id="seat-HJ"  class="seat" style="top: 28%; left: 84%;">HJ<span id="stack-HJ" class="stack">—</span></div>
    <div id="seat-CO"  class="seat" style="top: 68%; left: 86%;">CO<span id="stack-CO" class="stack">—</span></div>

    <div id="board" class="absolute top-[46%] flex gap-2 z-40"></div>
    <div id="heroCards" class="hero-cards absolute bottom-[16%] flex gap-2 z-40"></div>
    <div id="floatLayer" class="absolute inset-0 pointer-events-none z-50"></div>
  </section>

  <section class="mt-6 grid gap-4 md:grid-cols-3">
    <div class="kpi md:col-span-1">
      <h3 class="text-lg font-bold text-white mb-1">Your move</h3>
      <p id="prompt" class="text-slate-300 text-sm">Click “New Scenario” to begin.</p>
      <div class="divider my-3"></div>
      <div class="text-xs text-slate-400"><span id="combo"></span></div>
    </div>
    <div class="kpi md:col-span-2"><div id="actions" class="flex flex-wrap gap-3"></div></div>
  </section>

  <section id="summary" class="hidden mt-6 bg-slate-800 border border-slate-700 rounded-xl p-6 space-y-4">
    <h3 class="text-2xl font-bold text-teal-400">Drill Summary</h3>
    <div id="summaryBody" class="space-y-2 text-slate-200 text-sm"></div>
    <div class="divider"></div>
    <div class="flex flex-wrap items-center gap-3">
      <div id="evLine" class="text-lg font-bold"></div>
      <div id="gtoScore" class="chip"></div>
    </div>
    <p id="tutor" class="text-slate-300 text-sm"></p>
    <div class="pt-2 flex gap-3">
      <button id="again" class="btn btn-primary">Next Hand</button>
      <button id="replay" class="btn btn-ghost">Replay this Hand</button>
    </div>
  </section>
  <script>
    /**********************
     * CONFIG + RNG VIA API
     **********************/
    const API_KEY = "AIzaSyBZh4GD0KX691kfF3eU45a71o1IHf5iL4U";

    // Seeded RNG (xorshift32)
    let _seed = 123456789;
    function xsSeed(n){ _seed = (n>>>0) || 2463534242; }
    function xsRand(){ _seed ^= _seed << 13; _seed ^= _seed >>> 17; _seed ^= _seed << 5; return ((_seed>>>0) % 100000) / 100000; }
    async function seedFromAPI(customSalt=0){
      try{
        const r = await fetch(`https://www.googleapis.com/books/v1/volumes?q=poker&maxResults=5&key=${API_KEY}`, { cache: "no-store" });
        const j = await r.json();
        const len = JSON.stringify(j).length;
        xsSeed(len ^ Date.now() ^ customSalt);
      }catch(e){ xsSeed(Date.now() ^ 0x9e3779b9 ^ customSalt); }
    }
    const sleep = (ms)=> new Promise(res=>setTimeout(res, ms)); // cinematic pacing

    /**********************
     * CARD HELPERS
     **********************/
    const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
    const SUITS = ["♠","♥","♦","♣"];
    const SUIT_CLASS = (s)=> (s==="♥"||s==="♦") ? "red" : "black";

    function dealUniqueCards(n, taken=new Set()){
      const res=[];
      while(res.length<n){
        const c = RANKS[Math.floor(xsRand()*13)] + SUITS[Math.floor(xsRand()*4)];
        if(!taken.has(c)){ taken.add(c); res.push(c); }
      }
      return res;
    }
    function cardEl(card, isBoard=false){
      const rank = card[0], suit = card[1];
      const wrap = document.createElement("div");
      wrap.className = `card ${isBoard?'board-card':''} fade-in`;
      const r = document.createElement("div"); r.className="rank "+SUIT_CLASS(suit); r.textContent = rank;
      const s = document.createElement("div"); s.className="suit "+SUIT_CLASS(suit); s.textContent = suit;
      wrap.appendChild(r); wrap.appendChild(s);
      return wrap;
    }

    /**********************
     * DOM REFS
     **********************/
    const hudStreet = document.getElementById("hudStreet");
    const hudPot = document.getElementById("hudPot");
    const hudSPR = document.getElementById("hudSPR");

    const boardEl = document.getElementById("board");
    const heroCardsEl = document.getElementById("heroCards");
    const floatLayer = document.getElementById("floatLayer");

    const promptEl = document.getElementById("prompt");
    const comboEl = document.getElementById("combo");
    const actEl = document.getElementById("actions");
    const sumSec = document.getElementById("summary");
    const sumBody = document.getElementById("summaryBody");
    const evLine = document.getElementById("evLine");
    const gtoScoreEl = document.getElementById("gtoScore");
    const tutor = document.getElementById("tutor");
    const gameTypeSel = document.getElementById("gameType");
    const startStreetSel = document.getElementById("startStreet");
    const newBtn = document.getElementById("newHand");
    const againBtn = document.getElementById("again");
    const replayBtn = document.getElementById("replay");

    const stackRefs = {
      BTN: document.getElementById("stack-BTN"),
      SB:  document.getElementById("stack-SB"),
      BB:  document.getElementById("stack-BB"),
      UTG: document.getElementById("stack-UTG"),
      HJ:  document.getElementById("stack-HJ"),
      CO:  document.getElementById("stack-CO"),
    };

    /**********************
     * STATE
     **********************/
    const POSITIONS = ["UTG","HJ","CO","BTN","SB","BB"]; // preflop flow order
    const POSTFLOP_ORDER = ["SB","BB","UTG","HJ","CO","BTN"]; // first to act varies but BTN last suffices for training
    const STREET_ICON = { preflop:"💥 Preflop", flop:"🌊 Flop", turn:"🔥 Turn", river:"💧 River" };

    const state = {
      gameType: "cash_100",
      startStreet: "preflop",
      street: "preflop",
      stackBB: 100,

      pot: 0,
      stacks: { BTN:100, SB:100, BB:100, UTG:100, HJ:100, CO:100 },

      hero: [],
      villains: { UTG:[], HJ:[], CO:[], SB:[], BB:[] },
      folded:   { BTN:false, SB:false, BB:false, UTG:false, HJ:false, CO:false },

      board: [],
      history: [],
      evLoss: 0,

      lastSnapshot: null,
      lastSeedSalt: 0
    };

    /**********************
     * RENDER
     **********************/
    function updateStacksUI(){
      Object.keys(state.stacks).forEach(pos=>{
        stackRefs[pos].textContent = `${state.stacks[pos].toFixed(1)} BB`;
      });
    }
    function renderBoard(){
      boardEl.innerHTML = "";
      state.board.forEach(c=> boardEl.appendChild(cardEl(c,true)));
    }
    function renderHeroCards(){
      heroCardsEl.innerHTML = "";
      state.hero.forEach(c=> heroCardsEl.appendChild(cardEl(c,false)));
    }
    function renderHUD(){
      hudStreet.textContent = STREET_ICON[state.street] || "—";
      hudPot.textContent = `Pot: ${state.pot.toFixed(1)} BB`;
      const liveStacks = Object.entries(state.stacks)
        .filter(([p])=>!state.folded[p]) // only live for eff stack
        .map(([,v])=>v);
      const eff = Math.max(0.1, Math.min(...liveStacks, state.stacks.BTN));
      const spr = (eff / Math.max(1, state.pot)).toFixed(1);
      hudSPR.textContent = `SPR: ${spr}`;
    }
    function setPrompt(){
      let txt = state.street==="preflop" ? "Preflop: BTN decision node."
        : `${state.street[0].toUpperCase()+state.street.slice(1)} ${state.board.join(" ")}: Choose your line.`;
      promptEl.textContent = txt;
      comboEl.textContent = `Hero: ${state.hero.join(" ")}  •  Opponents acting in turn`;
    }
    function renderAll(){
      updateStacksUI(); renderBoard(); renderHeroCards(); renderHUD(); setPrompt();
      sumSec.classList.add("hidden");
    }

    /**********************
     * UTILS
     **********************/
    function pushHistory(msg){ state.history.push(msg); }
    function seatXY(pos){
      const seat = document.getElementById(`seat-${pos}`);
      return { top: seat.style.top, left: seat.style.left };
    }
    function announce(pos, text, duration=2200){
      const xy = seatXY(pos);
      const chip = document.createElement("div");
      chip.className="float-chip";
      chip.style.left = xy.left; chip.style.top = xy.top;
      chip.textContent = `${pos}: ${text}`;
      floatLayer.appendChild(chip);
      setTimeout(()=>chip.remove(), duration);
      pushHistory(`${pos}: ${text}`);
    }
    function spend(pos, bb){ // deduct from stack and add to pot
      const live = Math.max(0, Math.min(bb, state.stacks[pos]));
      state.stacks[pos] = +(state.stacks[pos] - live).toFixed(1);
      state.pot = +(state.pot + live).toFixed(1);
      updateStacksUI(); renderHUD();
    }
    function clearActions(){ actEl.innerHTML=""; }
    function addBtn(label, cls, cb){ const b=document.createElement("button"); b.className=`btn ${cls}`; b.textContent=label; b.onclick=cb; actEl.appendChild(b); return b; }

    /**********************
     * GTO-ish Policies & EV
     **********************/
    function pfStrength([a,b]){
      const r1 = RANKS.indexOf(a[0]), r2=RANKS.indexOf(b[0]);
      const pair=a[0]===b[0], suited=a[1]===b[1], gap=Math.abs(r1-r2);
      let s = pair? (100 - r1*3) : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?6:0);
      return s + xsRand()*2;
    }
    function postStrength(hero, board){
      const ranks = board.map(c=>c[0]);
      const high = ["A","K","Q","J","T"].includes(ranks[0]) ? 10 : 0;
      const pair = ranks.some(r => r===hero[0][0] || r===hero[1][0]) ? 8 : 0;
      const suit = (hero[0][1]===hero[1][1]) ? 3 : 0;
      return high + pair + suit + xsRand()*2;
    }
    function optimalAlias(street, label){
      if(street==="preflop"){
        if(label==="Fold") return "Fold";
        if(label==="Call") return "Call";
        if(label==="All-in") return "All-in";
        if(label.startsWith("Raise")){
          const n = parseInt(label.replace(/\D+/g,""),10)||3;
          return n>=3 ? "Raise 3.0x" : "Raise 2.5x";
        }
        return "Call";
      } else {
        if(label==="Check") return "Check";
        if(label==="All-in") return "All-in";
        if(label.startsWith("Bet")){
          const n = parseInt(label.replace(/\D+/g,""),10)||0;
          if(n <= state.pot*0.4) return "Bet (small)";
          if(n <= state.pot*0.6) return "Bet (med)";
          return "Bet (big)";
        }
        return "Check";
      }
    }
    function gtoPolicy(street){
      let optimal="Check";
      if(street==="preflop"){
        const s = pfStrength(state.hero);
        if(s>92) optimal="Raise 3.0x";
        else if(s>82) optimal="Raise 2.5x";
        else if(s>70) optimal="Call";
        else optimal="Fold";
      } else {
        const s = postStrength(state.hero, state.board);
        if(s>16) optimal="Bet (big)";
        else if(s>12) optimal="Bet (med)";
        else if(s>8)  optimal="Bet (small)";
        else optimal="Check";
      }
      return optimal;
    }
    function evPenalty(street, heroActAlias, optimal){
      if(heroActAlias===optimal) return 0;
      const fam = a => a.startsWith("Raise")?"Raise" : a.startsWith("Bet")?"Bet" : a;
      const w = {
        preflop: {Fold:.9, Call:.5, Raise:.6, "All-in":1.1},
        flop:    {Check:.2, Bet:.35, "All-in":.6},
        turn:    {Check:.25, Bet:.45, "All-in":.8},
        river:   {Check:.3, Bet:.55, "All-in":1.0},
      };
      const key = fam(heroActAlias);
      const base = (w[street][key] ?? .4);
      return +(base + xsRand()*0.15).toFixed(2);
    }
    function gtoScoreFromEV(ev){ return Math.min(100, Math.max(0, Math.round(100 - ev*25))); }

    /**********************
     * ACTION OPTIONS
     **********************/
    function bbSizes(){
      const live = Object.entries(state.stacks).filter(([p])=>!state.folded[p]).map(([,v])=>v);
      const eff = Math.max(1, Math.min(...live));
      if(state.street==="preflop"){
        return [2, 3, 5].map(n=> Math.min(n, Math.floor(eff*0.5)));
      }
      const p = Math.max(2, state.pot);
      const opts = [Math.round(p*0.33), Math.round(p*0.5), Math.round(p*0.66)];
      return opts.map(n=> Math.min(n, Math.max(2, Math.floor(eff*0.75))));
    }
    function offerActions(){
      clearActions();
      const sizes = bbSizes();
      if(state.street==="preflop"){
        addBtn("Fold","btn-ghost", ()=>heroActs("Fold"));
        addBtn("Call","btn-ghost", ()=>heroActs("Call"));
        sizes.forEach(bb=> addBtn(`Raise ${bb} BB`,"btn-primary", ()=>heroActs(`Raise ${bb} BB`)));
        addBtn("All-in","btn-danger", ()=>heroActs("All-in"));
      } else {
        addBtn("Check","btn-ghost", ()=>heroActs("Check"));
        sizes.forEach(bb=> addBtn(`Bet ${bb} BB`,"btn-primary", ()=>heroActs(`Bet ${bb} BB`)));
        addBtn("All-in","btn-danger", ()=>heroActs("All-in"));
      }
    }

    /**********************
     * PRE/FLOP VILLAIN FLOW
     **********************/
    async function preflopRoundBeforeBTN(){
      // UTG → HJ → CO
      for(const pos of ["UTG","HJ","CO"]){
        if(state.folded[pos]) continue;
        await sleep(600);
        const r = xsRand();
        if(r<0.14){ const to = [2,3,5][Math.floor(xsRand()*3)]; spend(pos,to); announce(pos, `raises to ${to} BB`); }
        else if(r<0.40){ spend(pos,2); announce(pos, "calls 2 BB"); }
        else { state.folded[pos]=true; announce(pos, "folds"); }
      }
    }
    async function preflopRoundAfterBTN(heroLabel){
      for(const pos of ["SB","BB"]){
        if(state.folded[pos]) continue;
        await sleep(600);
        const r = xsRand();
        if(heroLabel==="Fold"){ announce(pos,"wins uncontested"); continue; }
        if(r<0.20){ const to = 7+Math.floor(xsRand()*4); spend(pos, to); announce(pos, `3-bets to ${to} BB`); }
        else if(r<0.70){ const call = 2; spend(pos, call); announce(pos, `calls ${call} BB`); }
        else { state.folded[pos]=true; announce(pos, "folds"); }
      }
    }

    async function postflopOppReact(heroLabel){
      // Choose a live seat other than BTN
      const live = ["UTG","HJ","CO","SB","BB"].filter(p=>!state.folded[p]);
      if(live.length===0) return true;
      const pos = live[Math.floor(xsRand()*live.length)];
      await sleep(900);
      const r = xsRand();
      if(heroLabel.startsWith("Bet")){
        if(r<0.22){ const add = Math.max(2, Math.round(state.pot*0.35)); spend(pos, add); announce(pos, `raises +${add} BB`); }
        else if(r<0.75){ const call = Math.max(2, Math.round(state.pot*0.25)); spend(pos, call); announce(pos, `calls ${call} BB`); }
        else { state.folded[pos]=true; announce(pos, "folds"); }
      } else if(heroLabel==="All-in"){
        if(r<0.45){ const call = Math.min(state.stacks[pos], state.stacks.BTN); spend(pos, call); announce(pos, "calls all-in"); }
        else { state.folded[pos]=true; announce(pos, "folds"); }
      } else if(heroLabel==="Check"){
        if(r<0.5){ announce(pos, "checks"); }
        else { const bet = Math.max(2, Math.round(state.pot*0.25)); spend(pos, bet); announce(pos, `bets ${bet} BB`); await postflopHeroVsDonk(bet); return false; }
      }
      return true; // proceed next street
    }

    async function postflopHeroVsDonk(bet){
      // Quick response line after villain donk-bets
      clearActions();
      addBtn("Fold","btn-ghost", async ()=>{
        state.evLoss += .45; state.folded.BTN=true; announce("BTN","folds");
        await sleep(800); finish("Hero folded."); });
      addBtn(`Call ${bet} BB`,"btn-primary", async ()=>{
        spend("BTN",bet); announce("BTN",`calls ${bet} BB`); await sleep(900); nextStreet(); });
      addBtn(`Raise ${Math.round(bet*2)} BB`,"btn-primary", async ()=>{
        const r = Math.round(bet*2); spend("BTN",r); announce("BTN",`raises to ${r} BB`); await sleep(1000); nextStreet(); });
      addBtn("All-in","btn-danger", async ()=>{
        const jam = state.stacks.BTN; spend("BTN",jam); announce("BTN","jams"); await sleep(1000); finish("All-ins committed"); });
    }

    /**********************
     * HERO ACTION HANDLER
     **********************/
    async function heroActs(label){
      // Grade EV
      const optimal = gtoPolicy(state.street);
      const alias = optimalAlias(state.street, label);
      const loss = evPenalty(state.street, alias, optimal);
      state.evLoss += loss;

      // Log + animate hero action
      announce("BTN", label.toLowerCase());
      pushHistory(`${state.street.toUpperCase()}: Hero → ${label}`);

      // Visual stack/pot updates
      if(state.street==="preflop"){
        if(label==="Fold"){ state.folded.BTN=true; await sleep(800); return finish("Hero folded preflop."); }
        if(label==="Call"){ spend("BTN", 2); }
        if(label.startsWith("Raise")){
          const n = parseInt(label.replace(/\D+/g,""),10) || 3;
          spend("BTN", n);
        }
        if(label==="All-in"){
          const jam = state.stacks.BTN; spend("BTN", jam);
        }
        await preflopRoundAfterBTN(label);
        if(state.street==="river") return finish("Reached showdown.");
        await nextStreet();
        return;
      }

      // Postflop
      if(label==="Check"){
        // nothing
      } else if(label.startsWith("Bet")){
        const n = parseInt(label.replace(/\D+/g,""),10) || Math.round(state.pot/2);
        spend("BTN", Math.min(n, state.stacks.BTN));
      } else if(label==="All-in"){
        const jam = state.stacks.BTN; spend("BTN", jam);
      }

      // Villain reaction
      const proceed = await postflopOppReact(label);
      if(!proceed) return; // handled via donk line

      if(state.street==="river"){ return finish("Reached showdown."); }
      await nextStreet();
    }

    /**********************
     * STREET PROGRESSION
     **********************/
    async function nextStreet(){
      await sleep(600);
      const taken = new Set([
        ...state.hero,
        ...Object.values(state.villains).flat(),
        ...state.board
      ]);

      if(state.street==="preflop"){
        state.street = "flop";
        state.board = dealUniqueCards(3, taken);
      } else if(state.street==="flop"){
        state.street = "turn";
        state.board = [...state.board, ...dealUniqueCards(1, taken)];
      } else if(state.street==="turn"){
        state.street = "river";
        state.board = [...state.board, ...dealUniqueCards(1, taken)];
      } else {
        return finish("Reached showdown.");
      }

      renderAll();
      await sleep(500);
      offerActions();
    }
    /**********************
     * SHOWDOWN / REVEAL / SUMMARY
     **********************/
    function strengthScore(cards, board){
      // Lightweight strength proxy for training visuals (not a full evaluator)
      // Combines postStrength with a bit of preflop baseline and jitter
      return postStrength(cards, board) + pfStrength(cards)/10 + xsRand()*1.5;
    }

    function liveOpponents(){
      return ["UTG","HJ","CO","SB","BB"].filter(p => !state.folded[p]);
    }

    function revealHandAtSeat(pos, cards){
      // Render two small cards just above the seat to "reveal" at showdown
      const seat = document.getElementById(`seat-${pos}`);
      const holder = document.createElement("div");
      holder.style.position = "absolute";
      holder.style.transform = "translate(-50%,-50%)";
      holder.style.left = seat.style.left;
      holder.style.top  = `calc(${seat.style.top} - 52px)`;
      holder.style.display = "flex";
      holder.style.gap = "6px";
      holder.style.zIndex = 60;

      cards.forEach(c=>{
        const el = cardEl(c,false);
        el.style.width = "48px";
        el.style.height = "66px";
        el.classList.add("fade-in");
        holder.appendChild(el);
      });
      floatLayer.appendChild(holder);
      // Auto-remove on new hand via reset() (float layer is cleared)
    }

    function gtoVerdict(score){
      if(score>=92) return "Elite: you’re tracking solver mixes very closely.";
      if(score>=80) return "Strong fundamentals — tighten a couple of sizes.";
      if(score>=65) return "Good baseline. Study preflop frequencies and flop sizing.";
      return "Large deviations — drill specific nodes (3-bet pots, low boards).";
    }

    async function finish(reason){
      // If we reached river or explicitly a showdown, evaluate and reveal only live opponents
      let didShowdown = (reason.toLowerCase().includes("showdown") || state.street==="river");

      if(didShowdown){
        const live = liveOpponents();
        // Reveal ONLY the villains who did NOT fold (others stay hidden)
        live.forEach(pos => revealHandAtSeat(pos, state.villains[pos]));

        // Winner evaluation (simple strength model)
        const heroScore = strengthScore(state.hero, state.board);
        const oppScores = live.map(pos => ({ pos, score: strengthScore(state.villains[pos], state.board) }));
        const all = [{ pos:"BTN", score: heroScore }, ...oppScores];
        all.sort((a,b)=>b.score - a.score);
        const winner = all[0];

        if(winner.pos === "BTN"){
          announce("BTN", "wins the pot", 2000);
        } else {
          announce(winner.pos, "wins the pot", 2000);
        }
      }

      // Build textual summary
      renderAll();
      sumBody.innerHTML = "";
      state.history.forEach(h=>{
        const p=document.createElement("p");
        p.textContent=h;
        sumBody.appendChild(p);
      });

      // EV + Score
      const ev = state.evLoss.toFixed(2);
      const score = gtoScoreFromEV(state.evLoss);
      evLine.textContent = `Total EV Deviation: ${ev} BB`;
      evLine.className = score>=90 ? "text-green-400 font-bold"
                        : score>=70 ? "text-yellow-300 font-bold"
                        : "text-red-400  font-bold";
      gtoScoreEl.textContent = `GTO Score: ${score}/100`;
      tutor.textContent = gtoVerdict(score);

      sumSec.classList.remove("hidden");

      // Action buttons
      clearActions();
      addBtn("Play Next Hand","btn-primary", reset);
      addBtn("Replay this Hand","btn-ghost", replayHand);
    }

    /**********************
     * NEW / REPLAY SUPPORT
     **********************/
    function snapshotCurrent(){
      state.lastSnapshot = {
        gameType: state.gameType,
        startStreet: state.startStreet,
        stackBB: state.stackBB,
        seedSalt: state.lastSeedSalt
      };
    }

    async function reset(){
      // Clear floating reveals
      floatLayer.innerHTML = "";

      // Setup basics
      state.gameType = gameTypeSel.value;
      state.startStreet = startStreetSel.value;
      state.stackBB = state.gameType==="cash_100" ? 100 : 40;

      state.street = state.startStreet;
      state.pot = 0;
      state.history = [];
      state.evLoss = 0;
      state.board = [];
      state.folded = { BTN:false, SB:false, BB:false, UTG:false, HJ:false, CO:false };
      state.stacks = { BTN:state.stackBB, SB:state.stackBB, BB:state.stackBB, UTG:state.stackBB, HJ:state.stackBB, CO:state.stackBB };
      state.lastSeedSalt = (Math.random()*1e9)|0;

      await seedFromAPI(state.lastSeedSalt);

      // Deal cards
      const taken = new Set();
      state.hero = dealUniqueCards(2, taken);
      state.villains = {
        UTG: dealUniqueCards(2,taken),
        HJ:  dealUniqueCards(2,taken),
        CO:  dealUniqueCards(2,taken),
        SB:  dealUniqueCards(2,taken),
        BB:  dealUniqueCards(2,taken),
      };

      // Post blinds if starting preflop
      if(state.street==="preflop"){
        spend("SB", 0.5);
        spend("BB", 1.0);
      } else {
        // Start with a coarse postflop pot if jumping streets
        state.pot = 6.0;
      }

      // Starting board depending on selected street
      if(state.startStreet==="flop")  state.board = dealUniqueCards(3, taken);
      if(state.startStreet==="turn")  state.board = [...dealUniqueCards(3,taken), ...dealUniqueCards(1,taken)];
      if(state.startStreet==="river") state.board = [...dealUniqueCards(3,taken), ...dealUniqueCards(2,taken)];

      renderAll();

      // Preflop opponents act before Hero
      if(state.street==="preflop"){
        await preflopRoundBeforeBTN();
      }

      // Now hero options
      offerActions();
      snapshotCurrent();
    }

    async function replayHand(){
      if(!state.lastSnapshot){ return reset(); }

      // Clear floating reveals
      floatLayer.innerHTML = "";

      const snap = state.lastSnapshot;
      // Restore selectors visually
      gameTypeSel.value = snap.gameType;
      startStreetSel.value = snap.startStreet;

      // Reset state to snapshot
      state.gameType = snap.gameType;
      state.startStreet = snap.startStreet;
      state.stackBB = snap.stackBB;
      state.street = state.startStreet;
      state.pot = 0;
      state.history = [];
      state.evLoss = 0;
      state.board = [];
      state.folded = { BTN:false, SB:false, BB:false, UTG:false, HJ:false, CO:false };
      state.stacks = { BTN:state.stackBB, SB:state.stackBB, BB:state.stackBB, UTG:state.stackBB, HJ:state.stackBB, CO:state.stackBB };

      await seedFromAPI(snap.seedSalt);

      const taken = new Set();
      state.hero = dealUniqueCards(2, taken);
      state.villains = {
        UTG: dealUniqueCards(2,taken),
        HJ:  dealUniqueCards(2,taken),
        CO:  dealUniqueCards(2,taken),
        SB:  dealUniqueCards(2,taken),
        BB:  dealUniqueCards(2,taken),
      };

      if(state.street==="preflop"){
        spend("SB", 0.5);
        spend("BB", 1.0);
      } else {
        state.pot = 6.0;
      }

      if(state.startStreet==="flop")  state.board = dealUniqueCards(3, taken);
      if(state.startStreet==="turn")  state.board = [...dealUniqueCards(3,taken), ...dealUniqueCards(1,taken)];
      if(state.startStreet==="river") state.board = [...dealUniqueCards(3,taken), ...dealUniqueCards(2,taken)];

      renderAll();
      if(state.street==="preflop"){ await preflopRoundBeforeBTN(); }
      offerActions();
    }

    /**********************
     * WIRE CONTROLS + BOOT
     **********************/
    newBtn.addEventListener("click", reset);
    againBtn.addEventListener("click", reset);
    replayBtn.addEventListener("click", replayHand);

    // First load
    reset();
  </script>
</body>
</html>



