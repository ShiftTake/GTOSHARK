<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>GTO Shark • Live Practice v9.3</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
  <style>
    /* === CINEMATIC INDIGO/TEAL FELT THEME === */
    body {
      font-family: 'Inter', sans-serif;
      background: radial-gradient(circle at center, #0c1c2b 0%, #03080e 90%);
      background-image: url('https://upload.wikimedia.org/wikipedia/commons/f/f0/Billiard_table_close-up_2.jpg');
      background-size: cover;
      background-blend-mode: multiply;
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow-x: hidden;
      overflow-y: auto;
    }
    h1 {
      font-size: 1.25rem;
      font-weight: 800;
      background: linear-gradient(90deg,#00e0ff,#6f00ff);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      margin-top:1rem;
    }
    .felt {
      width: 90vmin;
      height: 90vmin;
      border-radius: 50%;
      position: relative;
      background: radial-gradient(circle at center,#1a2633 0%,#091019 85%);
      box-shadow: inset 0 0 50px rgba(0,0,0,0.6),0 0 60px rgba(0,255,255,0.1);
      margin-top: 2rem;
    }
    .seat {
      position: absolute;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: rgba(0,0,0,0.55);
      border: 2px solid rgba(255,255,255,0.1);
      color: #d1d5db;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      transition: all 0.3s ease;
    }
    .seat.hero {
      border-color: #00ffa2;
      box-shadow: 0 0 20px #00ffa2a0;
      color: #00ffa2;
    }
    .seat.acting {
      border-color: #ffae00;
      box-shadow: 0 0 20px #ffae0090;
      color: #ffae00;
    }
    .seat.folded {
      opacity: 0.25;
    }
    .card {
      width: 46px;
      height: 64px;
      border-radius: 6px;
      background: #fff;
      color: #000;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
    }
    .card.red { color:#c00; }
    .card.black { color:#000; }

    .hud {
      position: absolute;
      top: 48%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: rgba(0,0,0,0.5);
      border-radius: 8px;
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      display: flex;
      gap: 0.6rem;
      color:#e5e7eb;
    }

    .actions {
      margin-top: 1.2rem;
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    .a-btn {
      padding: 0.5rem 0.9rem;
      border-radius: 6px;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }
    .a-primary { background:#007aff; color:white; }
    .a-ghost   { background:#2a3744; color:#e5e7eb; }
    .a-danger  { background:#7a1a1a; color:white; }
    .a-btn:hover { filter: brightness(1.15); }

    .prompt {
      margin-top: 1rem;
      background: rgba(0,0,0,0.4);
      border-radius: 8px;
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
    }

    .result {
      margin-top: 1rem;
      display: none;
      text-align: center;
    }
    .score { font-size:1.8rem; font-weight:900; }
    .score-good { color:#00ffa2; }
    .score-bad { color:#ff3b3b; }

    .log {
      position:absolute;
      top:2rem;
      right:2rem;
      width:200px;
      background:rgba(0,0,0,0.5);
      border-radius:8px;
      padding:0.5rem 0.8rem;
      font-size:0.8rem;
      box-shadow:0 0 8px rgba(0,0,0,0.4);
    }
    .log-item {
      display:flex;
      justify-content:space-between;
      padding:2px 0;
    }

    .controls {
      position:absolute;
      top:1rem;
      right:1rem;
      display:flex;
      gap:0.4rem;
      flex-wrap:wrap;
      align-items:center;
    }
    select,button {
      background:#1e293b;
      color:#e5e7eb;
      border:none;
      border-radius:4px;
      padding:0.3rem 0.6rem;
      font-size:0.8rem;
    }
    button:hover,select:hover {
      background:#334155;
    }

    .float-layer {
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:visible;
    }
    .bubble {
      position:absolute;
      background:rgba(0,0,0,0.7);
      color:white;
      padding:2px 6px;
      border-radius:4px;
      font-size:0.7rem;
      opacity:0;
      transform:translate(-50%,-50%) scale(0.8);
      transition:all 0.3s ease;
    }
    .bubble.show {
      opacity:1;
      transform:translate(-50%,-50%) scale(1);
    }
  </style>
</head>
<body>
  <h1>GTO Shark • Live Practice</h1>
  <p style="font-size:0.75rem;opacity:0.8;">Cinematic indigo/teal felt • Hero-centric end • GTO mixed-freq decisions</p>

  <div class="felt" id="felt">
    <div class="hud" id="hud">| Pot |  SPR |</div>
    <div class="float-layer" id="floatLayer"></div>
    <div class="board" id="board"></div>
  </div>

  <div class="actions" id="actions"></div>
  <div class="prompt" id="prompt">Your move. Engine ready. Loading action logic…</div>

  <div class="result" id="resultPanel">
    <div id="resultScore" class="score"></div>
    <div id="resultVerdict"></div>
  </div>

  <div class="controls">
    <label>Players <select id="numPlayers"><option>6-max</option><option selected>9-max</option></select></label>
    <label>Hero Position <select id="heroPos"></select></label>
    <label>Play-Through Range <select id="sequenceMode"><option>Play to Flop</option><option>Play to Turn</option><option selected>Play to River</option></select></label>
    <label>Start Street <select id="startStreet"><option selected>Preflop</option><option>Flop</option><option>Turn</option><option>River</option></select></label>
    <label>Scenario <select id="scenario"><option selected>None (Normal)</option><option>Standard</option><option>Blind vs Blind</option><option>BTN vs BB</option><option>CO vs BB</option><option>UTG vs BB</option><option>SB vs BTN</option><option>HJ vs BTN</option></select></label>
    <button id="newHand">New Hand</button>
  </div>

  <div class="log" id="handLog">
    <div style="font-weight:700;margin-bottom:4px;">Hand Log</div>
    <div id="logList"></div>
    <button id="clearLog" style="margin-top:4px;">Clear</button>
  </div>
  <!-- =========================
       SCRIPT — v9.3 (Part 2 / 4)
       Core Engine & Game State
       ========================= -->
  <script>
  window.__GTO__ = (() => {
    const state = {
      seats: [],
      players: 9,
      hero: 'BTN',
      street: 'preflop',
      sequence: 'Play to River',
      startStreet: 'preflop',
      scenario: 'None (Normal)',
      stacks: {},
      committed: {},
      folded: {},
      allin: {},
      hands: {},
      board: [],
      pot: 0,
      rngSeed: 0,
      chipPlates: {},
      lockedFolds: new Set(),
      _scenarioPreset: {},
    };

    /**************************************
     * Utility & DOM Helpers
     **************************************/
    const $ = (id) => document.getElementById(id);

    function sleep(ms) {
      return new Promise(r => setTimeout(r, ms));
    }

    function xsRand() {
      state.rngSeed = (1664525 * state.rngSeed + 1013904223) % 4294967296;
      return state.rngSeed / 4294967296;
    }

    async function seedFromAPI() {
      // fallback PRNG seed
      state.rngSeed = Math.floor(Math.random() * 1e9);
    }

    /**************************************
     * Table Templates
     **************************************/
    const TEMPLATES = {
      6: ['SB','BB','UTG','HJ','CO','BTN'],
      9: ['SB','BB','UTG','UTG+1','MP','LJ','HJ','CO','BTN']
    };

    const POS_ANGLE = {
      'SB': 300, 'BB': 0, 'UTG': 40, 'UTG+1': 80, 'MP': 120,
      'LJ': 160, 'HJ': 200, 'CO': 240, 'BTN': 270
    };

    /**************************************
     * Card Utilities
     **************************************/
    const RANKS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];
    const SUITS = ['♠','♥','♦','♣'];

    function randCard(exclude=new Set()) {
      while(true){
        const r = RANKS[Math.floor(xsRand()*RANKS.length)];
        const s = SUITS[Math.floor(xsRand()*SUITS.length)];
        const c = r+s;
        if(!exclude.has(c)) return c;
      }
    }

    function deal(num, exclude) {
      const cards = [];
      for(let i=0;i<num;i++){
        const c = randCard(exclude);
        exclude.add(c);
        cards.push(c);
      }
      return cards;
    }

    /**************************************
     * Seat Rendering
     **************************************/
    function setPlayers(n){
      const felt = $('felt');
      const oldSeats = felt.querySelectorAll('.seat');
      oldSeats.forEach(x=>x.remove());
      state.seats = TEMPLATES[n];
      const radius = 0.42 * felt.offsetWidth;
      const cx = felt.offsetWidth/2;
      const cy = felt.offsetHeight/2;
      state.nodes = {};
      for(let i=0;i<state.seats.length;i++){
        const seatName = state.seats[i];
        const angle = (POS_ANGLE[seatName]|| (360/state.seats.length)*i) * Math.PI/180;
        const x = cx + radius*Math.cos(angle) - 36;
        const y = cy - radius*Math.sin(angle) - 36;
        const d = document.createElement('div');
        d.className = 'seat';
        d.textContent = seatName;
        d.style.left = x+'px';
        d.style.top = y+'px';
        const stack = document.createElement('div');
        stack.style.position='absolute';
        stack.style.bottom='-1.2rem';
        stack.style.width='100%';
        stack.style.textAlign='center';
        stack.style.fontSize='0.7rem';
        stack.textContent='100.0 BB';
        felt.appendChild(d);
        felt.appendChild(stack);
        state.nodes[seatName] = {seat:d,stack:stack,label:seatName};
      }
    }

    function setHero(name){
      for(const s of Object.values(state.nodes)){
        s.seat.classList.remove('hero');
      }
      if(state.nodes[name]){
        state.nodes[name].seat.classList.add('hero');
      }
      state.hero = name;
    }

    /**************************************
     * Board Rendering
     **************************************/
    function renderBoard(){
      const b = $('board');
      b.innerHTML='';
      const startX = b.parentElement.offsetWidth/2 - (state.board.length*40)/2;
      const y = b.parentElement.offsetHeight/2 - 30;
      for(let i=0;i<state.board.length;i++){
        const c = state.board[i];
        const rank=c[0];
        const suit=c[1];
        const div=document.createElement('div');
        div.className='card '+(suit==='♥'||suit==='♦'?'red':'black');
        div.textContent=rank+suit;
        div.style.position='absolute';
        div.style.left=(startX+i*42)+'px';
        div.style.top=y+'px';
        b.appendChild(div);
      }
    }

    function renderHeroCards(){
      const hero=state.hero;
      if(!hero||!state.hands[hero])return;
      const hand=state.hands[hero];
      const h1=hand[0],h2=hand[1];
      const node=state.nodes[hero];
      const seat=node.seat;
      let offx=0;
      [h1,h2].forEach((c,idx)=>{
        const rank=c[0],suit=c[1];
        const div=document.createElement('div');
        div.className='card '+(suit==='♥'||suit==='♦'?'red':'black');
        div.textContent=rank+suit;
        div.style.position='absolute';
        div.style.left=(seat.offsetLeft+10+idx*26)+'px';
        div.style.top=(seat.offsetTop-80)+'px';
        $('felt').appendChild(div);
      });
    }

    /**************************************
     * HUD & Pot Info
     **************************************/
    function renderHUD(){
      const hud=$('hud');
      hud.textContent=`${state.street.toUpperCase()} | Pot ${state.pot.toFixed(1)} BB | SPR ${(state.spr||0).toFixed(1)}`;
    }

    function updateStacksUI(){
      for(const s of Object.keys(state.nodes)){
        state.nodes[s].stack.textContent=`${state.stacks[s].toFixed(1)} BB`;
      }
    }

    /**************************************
     * Prompts
     **************************************/
    function setPrompt(msg){
      $('prompt').textContent=msg;
    }

    /**************************************
     * Betting + Pot Handling
     **************************************/
    function initStreetAccounting(){
      state.currentBet=0;
      state.lastRaiseSize=1;
      state.committed={};
      state.seats.forEach(s=>{
        state.committed[s]=0;
      });
      if(state.street==='preflop'){
        payTo('SB',0.5);
        payTo('BB',1);
      }
    }

    function payTo(seat,amt){
      const diff=amt-(state.committed[seat]||0);
      if(diff<=0)return;
      state.stacks[seat]-=diff;
      state.committed[seat]=amt;
      state.pot+=diff;
      updateStacksUI();
      renderHUD();
    }

    function toCall(seat){
      return Math.max(0,state.currentBet-(state.committed[seat]||0));
    }

    function resetCommitted(){
      state.seats.forEach(s=>state.committed[s]=0);
    }

    function equalized(){
      let target=0;
      for(const s of state.seats){
        if(!state.folded[s] && !state.allin[s])
          target=Math.max(target,state.committed[s]);
      }
      return state.seats.every(s=>state.folded[s]||state.allin[s]||state.committed[s]===target);
    }

    /**************************************
     * Chip Plates
     **************************************/
    function ensurePlate(seat){
      if(!state.chipPlates[seat]){
        const p=document.createElement('div');
        p.className='bubble show';
        p.textContent='0 BB';
        const n=state.nodes[seat].seat;
        p.style.left=(n.offsetLeft+36)+'px';
        p.style.top=(n.offsetTop+70)+'px';
        $('floatLayer').appendChild(p);
        state.chipPlates[seat]=p;
      }
      return state.chipPlates[seat];
    }
    function updatePlate(seat,amt){
      const p=ensurePlate(seat);
      p.textContent=`${amt.toFixed(1)} BB`;
    }
    function removePlate(seat){
      if(state.chipPlates[seat]){
        state.chipPlates[seat].remove();
        delete state.chipPlates[seat];
      }
    }
    function clearPlatesForNextStreet(){
      for(const s of Object.keys(state.chipPlates)){
        removePlate(s);
      }
    }

    /**************************************
     * Bubbles / Action Labels
     **************************************/
    function bubble(seat,text){
      const n=state.nodes[seat].seat;
      const b=document.createElement('div');
      b.className='bubble show';
      b.textContent=text;
      b.style.left=(n.offsetLeft+36)+'px';
      b.style.top=(n.offsetTop-20)+'px';
      $('floatLayer').appendChild(b);
      setTimeout(()=>b.remove(),1300);
    }

    /**************************************
     * Acting Markers
     **************************************/
    function setActing(seat){
      for(const s of Object.keys(state.nodes)){
        state.nodes[s].seat.classList.remove('acting');
      }
      const node=state.nodes[seat];
      if(node)node.seat.classList.add('acting');
    }
    function markFolded(seat){
      const node=state.nodes[seat];
      if(node)node.seat.classList.add('folded');
    }

    /**************************************
     * Expose API
     **************************************/
    return {
      state,$,sleep,xsRand,seedFromAPI,
      TEMPLATES,POS_ANGLE,setPlayers,setHero,
      deal,dealFlop:()=>{state.board=[...state.board,...deal(3,new Set(state.board))];state.street='flop';renderBoard();},
      dealTurn:()=>{state.board=[...state.board,...deal(1,new Set(state.board))];state.street='turn';renderBoard();},
      dealRiver:()=>{state.board=[...state.board,...deal(1,new Set(state.board))];state.street='river';renderBoard();},
      renderBoard,renderHeroCards,renderHUD,updateStacksUI,
      setPrompt,initStreetAccounting,payTo,toCall,resetCommitted,equalized,
      ensurePlate,updatePlate,removePlate,clearPlatesForNextStreet,
      bubble,setActing,markFolded
    };
  })();
  </script>
  <!-- =========================
       SCRIPT — v9.3 (Part 3 / 4)
       Gameplay Logic & AI
       ========================= -->
  <script>
  (() => {
    const G = window.__GTO__;
    const S = G.state;

    /**************************************
     * GTO Policy Functions
     **************************************/
    function handStrength(cards, board = []) {
      // Simplified "strength" metric for demonstration (0-100)
      const ranks = '23456789TJQKA';
      const v1 = ranks.indexOf(cards[0][0]);
      const v2 = ranks.indexOf(cards[1][0]);
      let s = (v1 + v2) / 2;
      if (cards[0][1] === cards[1][1]) s += 3; // suited bonus
      if (cards[0][0] === cards[1][0]) s += 10; // pair bonus
      if (board.length) s += Math.random() * 5; // minor variance postflop
      return Math.min(100, Math.max(0, s * 5));
    }

    function gtoDecision(strength, street) {
      const r = Math.random();
      if (street === 'preflop') {
        if (strength > 85) return r < 0.7 ? 'raise' : 'call';
        if (strength > 70) return r < 0.5 ? 'raise' : 'call';
        if (strength > 50) return r < 0.4 ? 'call' : 'fold';
        return 'fold';
      }
      if (strength > 80) return r < 0.7 ? 'bet' : 'check';
      if (strength > 60) return r < 0.5 ? 'bet' : 'check';
      if (strength > 40) return r < 0.3 ? 'bet' : 'check';
      return 'check';
    }

    /**************************************
     * Round and Sequence Control
     **************************************/
    async function nextStreet() {
      G.clearPlatesForNextStreet();
      if (S.street === 'preflop') {
        await G.sleep(500);
        S.board = G.deal(3, new Set());
        S.street = 'flop';
      } else if (S.street === 'flop') {
        await G.sleep(500);
        S.board.push(...G.deal(1, new Set(S.board)));
        S.street = 'turn';
      } else if (S.street === 'turn') {
        await G.sleep(500);
        S.board.push(...G.deal(1, new Set(S.board)));
        S.street = 'river';
      } else if (S.street === 'river') {
        return finishHand();
      }
      G.renderBoard();
      G.renderHUD();
    }

    function finishHand() {
      const score = computeHeroScore();
      showResult(score);
      logHand(score);
      G.setPrompt('Hand complete. Press "New Hand" to play again.');
      clearActions();
      return;
    }

    /**************************************
     * Hero Actions
     **************************************/
    function clearActions() {
      G.$('actions').innerHTML = '';
    }

    function addAction(label, cls, cb) {
      const b = document.createElement('button');
      b.textContent = label;
      b.className = 'a-btn ' + cls;
      b.onclick = cb;
      G.$('actions').appendChild(b);
    }

    function offerHeroActions() {
      clearActions();
      const need = G.toCall(S.hero);
      addAction('Fold', 'a-ghost', () => heroActs('fold'));
      if (need > 0) addAction(`Call ${need.toFixed(1)} BB`, 'a-primary', () => heroActs('call'));
      addAction('Raise', 'a-primary', () => heroActs('raise'));
      if (S.street !== 'preflop') addAction('Check', 'a-ghost', () => heroActs('check'));
      addAction('All-in', 'a-danger', () => heroActs('allin'));
    }

    async function heroActs(action) {
      G.setActing(S.hero);
      const heroHand = S.hands[S.hero];
      const str = handStrength(heroHand, S.board);
      const optimal = gtoDecision(str, S.street);
      let evPenalty = 0;
      if (action !== optimal) evPenalty = Math.abs(action.charCodeAt(0) - optimal.charCodeAt(0)) / 2;
      S.heroScorePenalty = (S.heroScorePenalty || 0) + evPenalty / 10;

      // Display bubble + update plate
      if (action === 'fold') {
        S.folded[S.hero] = true;
        G.markFolded(S.hero);
        G.bubble(S.hero, 'Fold');
        return finishHand();
      } else if (action === 'check') {
        G.bubble(S.hero, 'Check');
      } else if (action === 'call') {
        const callAmt = G.toCall(S.hero) || 1;
        G.payTo(S.hero, (S.committed[S.hero] || 0) + callAmt);
        G.updatePlate(S.hero, callAmt);
        G.bubble(S.hero, `Call ${callAmt.toFixed(1)} BB`);
      } else if (action === 'raise') {
        const raiseTo = (S.currentBet || 1) * 2;
        S.currentBet = raiseTo;
        G.payTo(S.hero, raiseTo);
        G.updatePlate(S.hero, raiseTo);
        G.bubble(S.hero, `Raise ${raiseTo.toFixed(1)} BB`);
      } else if (action === 'allin') {
        const amt = S.stacks[S.hero];
        G.payTo(S.hero, (S.committed[S.hero] || 0) + amt);
        G.updatePlate(S.hero, S.stacks[S.hero]);
        G.bubble(S.hero, 'All-in');
      }

      await villainRound();
      if (S.sequence.includes('Flop') && S.street === 'preflop') return nextStreet();
      if (S.sequence.includes('Turn') && S.street === 'flop') return nextStreet();
      if (S.sequence.includes('River') && S.street === 'turn') return nextStreet();
      if (S.sequence.includes('River') && S.street === 'river') return finishHand();
      return finishHand();
    }

    /**************************************
     * Villain AI Logic
     **************************************/
    async function villainRound() {
      for (const seat of S.seats) {
        if (seat === S.hero) continue;
        if (S.folded[seat]) continue;
        G.setActing(seat);
        await G.sleep(600 + Math.random() * 500);
        const h = S.hands[seat];
        const str = handStrength(h, S.board);
        const act = gtoDecision(str, S.street);
        if (act === 'fold') {
          S.folded[seat] = true;
          G.markFolded(seat);
          G.bubble(seat, 'Fold');
        } else if (act === 'call') {
          const amt = G.toCall(seat) || 1;
          G.payTo(seat, (S.committed[seat] || 0) + amt);
          G.updatePlate(seat, amt);
          G.bubble(seat, `Call ${amt.toFixed(1)} BB`);
        } else if (act === 'raise' || act === 'bet') {
          const raiseAmt = (S.currentBet || 1) * 2 + 0.5;
          S.currentBet = raiseAmt;
          G.payTo(seat, raiseAmt);
          G.updatePlate(seat, raiseAmt);
          G.bubble(seat, `${act === 'raise' ? 'Raise' : 'Bet'} ${raiseAmt.toFixed(1)} BB`);
        }
      }
    }

    /**************************************
     * Scoring
     **************************************/
    function computeHeroScore() {
      const penalty = S.heroScorePenalty || 0;
      const pct = Math.max(0, Math.min(100, 100 - penalty * 100));
      return Math.round(pct);
    }

    function showResult(score) {
      const p = G.$('resultPanel');
      const sc = G.$('resultScore');
      const v = G.$('resultVerdict');
      p.style.display = 'block';
      sc.textContent = score + '%';
      sc.className = 'score ' + (score >= 50 ? 'score-good' : 'score-bad');
      v.textContent = score >= 85 ? 'Excellent GTO' :
                      score >= 70 ? 'Strong Play' :
                      score >= 50 ? 'Decent Line' : 'Needs Work';
    }

    function logHand(score) {
      const list = G.$('logList');
      const row = document.createElement('div');
      row.className = 'log-item';
      row.innerHTML = `<span>${S.hero}</span><span>${score}%</span>`;
      list.prepend(row);
    }

    /**************************************
     * New Hand Bootstrap
     **************************************/
    async function startNewHand() {
      G.$('resultPanel').style.display = 'none';
      G.$('floatLayer').innerHTML = '';
      G.$('board').innerHTML = '';
      S.board = [];
      S.folded = {};
      S.allin = {};
      S.committed = {};
      S.hands = {};
      S.pot = 0;
      S.heroScorePenalty = 0;
      G.$('prompt').textContent = 'Shuffling...';
      await G.seedFromAPI();
      G.setPlayers(S.players === 6 ? 6 : 9);
      G.setHero(S.hero);
      const taken = new Set();
      S.seats.forEach(s => {
        S.hands[s] = G.deal(2, taken);
        S.stacks[s] = 100;
        S.folded[s] = false;
      });
      G.renderHeroCards();
      G.renderHUD();
      G.initStreetAccounting();
      G.updateStacksUI();
      G.setPrompt(`${S.street.toUpperCase()}: Your action as ${S.hero}`);
      offerHeroActions();
    }

    /**************************************
     * Wiring
     **************************************/
    G.$('newHand').onclick = startNewHand;
    G.$('clearLog').onclick = () => { G.$('logList').innerHTML = ''; };
    G.$('numPlayers').onchange = (e) => { S.players = e.target.value === '6-max' ? 6 : 9; };
    G.$('heroPos').onchange = (e) => { S.hero = e.target.value; G.setHero(S.hero); };
    G.$('sequenceMode').onchange = (e) => { S.sequence = e.target.value; };
    G.$('startStreet').onchange = (e) => { S.startStreet = e.target.value.toLowerCase(); S.street = S.startStreet; };
    G.$('scenario').onchange = (e) => { S.scenario = e.target.value; };

    // Populate heroPos dropdown
    function populateHeroSelect() {
      const sel = G.$('heroPos');
      sel.innerHTML = '';
      const seats = S.players === 6 ? G.TEMPLATES[6] : G.TEMPLATES[9];
      seats.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s;
        if (s === 'BTN') opt.selected = true;
        sel.appendChild(opt);
      });
      S.hero = 'BTN';
    }

    populateHeroSelect();
    startNewHand();
  })();
  </script>
  <!-- =========================
       SCRIPT — v9.3 (Part 4 / 4)
       Resize helper & close
       ========================= -->
  <script>
    // Keep seat layout crisp on resize
    (function () {
      const G = window.__GTO__;
      if (!G) return;

      let rafId = null;
      function relayout() {
        rafId = null;
        // Recompute seat positions by re-setting players and hero
        const players = G.state.players;
        const hero = G.state.hero;
        G.setPlayers(players);
        G.setHero(hero);
        G.renderHeroCards();
        G.renderHUD();
      }
      window.addEventListener('resize', () => {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(relayout);
      });
    })();
  </script>
</body>
</html>














