<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>GTO Shark — GTO Live Practice</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --felt:#0a3a34;             /* realistic felt base */
    --felt-dark:#062a25;
    --ring:#1c2841;             /* ring bezel */
    --teal:#14b8a6;
    --indigo:#4f46e5;
    --hero:#22c55e;
    --act:#fbbf24;
    --ink:#e2e8f0;
    --muted:#94a3b8;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:"Inter",system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    color:var(--ink);
    background:
      radial-gradient(1200px 800px at 50% -20%,rgba(79,70,229,.25),transparent 70%),
      radial-gradient(1400px 900px at 0% 110%,rgba(20,184,166,.12),transparent 70%),
      radial-gradient(circle at 50% 45%, var(--felt) 0%, var(--felt-dark) 70%);
    overflow-x:hidden;
    padding:16px;
  }

  header{
    display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin:6px 0 12px;
  }
  h1{margin:0; font-size:28px; font-weight:800; color:#7dd3fc}
  .sub{margin:4px 0 0; font-size:12px; color:var(--muted)}
  .toolbar{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .select, .btn{
    background:#0f172a; color:#e5e7eb; border:1px solid #334155; border-radius:10px;
    padding:8px 10px; font-weight:700; font-size:13px;
  }
  .btn-primary{background:linear-gradient(135deg, var(--indigo), #2563eb); border-color:#3b82f6}
  .btn-ghost{background:#0f172a}

  .app{
    display:grid; grid-template-columns:minmax(720px,1fr) 360px; gap:16px; align-items:start;
  }
  @media (max-width: 1200px){ .app{grid-template-columns:1fr} }

  /* === TABLE === */
  .table-wrap{display:flex; justify-content:center; align-items:center}
  .table{
    position:relative; width:900px; height:900px; border-radius:50%;
    background:
      radial-gradient(800px 800px at 50% 45%, rgba(255,255,255,.04), transparent 60%),
      radial-gradient(circle at 50% 50%, #0d4d41 0%, #073c34 60%, #05322c 85%, #042a25 100%);
    border:14px solid var(--ring);
    box-shadow:
      inset 0 0 120px rgba(0,0,0,.35),
      0 0 48px rgba(79,70,229,.25),
      0 0 28px rgba(20,184,166,.18);
  }
  .felt-fiber{
    position:absolute; inset:0; pointer-events:none; opacity:.10;
    background:
      repeating-radial-gradient(circle at 40% 60%, rgba(255,255,255,.05) 0 2px, transparent 2px 6px),
      repeating-radial-gradient(circle at 60% 40%, rgba(0,0,0,.06) 0 2px, transparent 2px 6px);
    filter: blur(0.4px);
  }

  .hud{
    position:absolute; left:50%; top:45%; transform:translate(-50%,-50%);
    display:flex; align-items:center; gap:10px;
    background:rgba(2,6,23,.65); border:1px solid #334155; padding:8px 12px; border-radius:10px; font-weight:800; font-size:13px;
    backdrop-filter: blur(2px);
  }
  .hud .sep{opacity:.5}

  .board{position:absolute; left:50%; top:48%; transform:translateX(-50%); display:flex; gap:10px; z-index:5}
  .card{
    width:84px; height:116px; border-radius:12px; background:#fff; border:2px solid var(--teal);
    display:flex; align-items:center; justify-content:center; font-size:34px; font-weight:900; color:#0f172a;
    box-shadow: 0 8px 18px rgba(0,0,0,.35);
  }
  .red{color:#b91c1c}

  .seats{position:absolute; inset:0}

  .seat{
    position:absolute; transform:translate(-50%,-50%);
    width:90px; height:90px; border-radius:50%;
    display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:800; letter-spacing:.3px; color:#9ca3af;
    background:#0b1220; border:2px solid #334155; box-shadow:0 6px 18px rgba(0,0,0,.35);
    transition: box-shadow .15s, border-color .15s, color .15s, filter .15s;
  }
  .seat.hero{border-color:var(--hero); color:#bbf7d0; box-shadow:0 0 24px rgba(34,197,94,.65)}
  .seat.acting{border-color:var(--act); color:#fde68a; box-shadow:0 0 24px rgba(251,191,36,.65)}
  .seat.folded{filter:grayscale(.6); color:#64748b; border-color:#334155}
  .stack{
    position:absolute; top:calc(100% + 10px); left:50%; transform:translateX(-50%);
    font-size:12px; padding:2px 10px; border-radius:9999px; border:1px solid #334155; background:#0b1220; color:#cbd5e1
  }
  .hero-cards{
    position:absolute; display:flex; gap:8px; z-index:6; transform:translate(-50%,-56%);
  }
  .hero-card{
    width:92px; height:126px; border-radius:14px; background:#fff; border:2px solid var(--indigo);
    display:flex; align-items:center; justify-content:center; font-weight:900; font-size:40px; color:#0f172a;
    box-shadow:0 10px 24px rgba(79,70,229,.35);
  }
  .chip-plate{
    position:absolute; transform:translate(-50%,0); padding:4px 8px; border-radius:10px; font-size:12px; font-weight:900;
    background:#0b1220; border:1px solid rgba(99,102,241,.6); color:#c7d2fe; box-shadow:0 8px 18px rgba(0,0,0,.35);
  }
  .chip-icon{
    width:14px;height:14px;border-radius:9999px; display:inline-block; margin-right:6px;
    background:
      radial-gradient(circle at 50% 50%, #f59e0b 0 28%, #7c3aed 30% 34%, #f59e0b 36% 62%, #7c3aed 64% 68%, #f59e0b 70%);
    border:1px solid rgba(245,158,11,.85); box-shadow:0 0 0 1px rgba(124,58,237,.75) inset;
  }

  .panel{background:#0b1220; border:1px solid #2b3647; border-radius:12px; padding:12px}
  .panel h3{margin:0 0 8px; font-size:16px}

  .actions{display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin-top:12px}
  .action-btn{
    padding:10px 14px; border-radius:10px; border:1px solid #334155; background:#0f172a; color:#e5e7eb;
    font-weight:800; cursor:pointer; transition:transform .1s, filter .15s;
  }
  .action-btn:hover{transform:translateY(-1px)}
  .action-primary{background:linear-gradient(135deg,var(--indigo),#2563eb); border-color:#3b82f6}
  .action-danger{background:linear-gradient(135deg,#ef4444,#dc2626); border-color:#b91c1c}

  .result{
    background:linear-gradient(135deg, var(--indigo), var(--teal));
    color:white; border-radius:12px; padding:12px; box-shadow:0 0 22px rgba(20,184,166,.25); display:none
  }
  .result .score{font-size:46px; font-weight:900}

  .log .row{
    display:flex; align-items:center; justify-content:space-between; gap:8px;
    background:#0b1220; border:1px solid #2b3647; border-radius:10px; padding:8px 10px; margin:6px 0;
  }
  .good{color:#22c55e} .bad{color:#ef4444}

  /* keep everything visible on 1080p */
  @media (max-height: 900px){
    .table{ transform: scale(.92); transform-origin: top center; }
  }
</style>
</head>
<body>
  <header>
    <div>
      <h1>GTO Shark — GTO Live Practice</h1>
      <p class="sub">Indigo/teal cinematic felt • Legal raises • Correct pot/commit • Showdown-only reveals</p>
    </div>
    <div class="toolbar">
      <label class="sub">Sequence</label>
      <select id="sequence" class="select">
        <option value="preflop">Preflop Only</option>
        <option value="river">Play to River</option>
      </select>
      <label class="sub">Hero</label>
      <select id="heroPos" class="select"></select>
      <button id="newHand" class="btn btn-primary">♻ New Hand</button>
    </div>
  </header>

  <div class="app">
    <main>
      <section class="table-wrap">
        <div id="table" class="table">
          <div class="felt-fiber"></div>
          <div class="hud" id="hud">
            <span id="hudStreet">—</span>
            <span class="sep">|</span>
            <span id="hudPot">Pot —</span>
            <span class="sep">|</span>
            <span id="hudSpr">SPR —</span>
          </div>
          <div id="board" class="board"></div>
          <div id="seats" class="seats"></div>
        </div>
      </section>

      <section class="panel">
        <h3>Your move</h3>
        <div id="prompt" class="sub">Loading…</div>
        <div id="actions" class="actions"></div>
      </section>
    </main>

    <aside class="panel">
      <div id="result" class="result">
        <div class="score" id="scoreNum"></div>
        <div id="scoreVerdict"></div>
      </div>
      <div class="log" style="margin-top:12px">
        <div style="display:flex; align-items:center; justify-content:space-between;">
          <h3>Hand Log</h3>
          <button id="clearLog" class="btn btn-ghost">Clear</button>
        </div>
        <div class="sub">✅ ≥ 50% • ❌ &lt; 50%</div>
        <div id="log"></div>
      </div>
    </aside>
  </div>
<script>
/* ====== Constants & helpers ====== */
const POS = ['UTG','UTG+1','UTG+2','LJ','HJ','CO','BTN','SB','BB'];
const RANKS = ['A','K','Q','J','T','9','8','7','6','5','4','3','2'];
const SUITS = ['♠','♥','♦','♣'];
const BB = 1.0, SB = 0.5;

const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
function el(tag, cls, html){ const n=document.createElement(tag); if(cls) n.className=cls; if(html!=null) n.innerHTML=html; return n; }
function suitClass(s){ return (s==='♥'||s==='♦') ? 'red' : ''; }
function fmt(n){ return (+n).toFixed(1); }
function clamp(n,a,b){ return Math.max(a,Math.min(b,n)); }

/* ====== State ====== */
const S = {
  players: 9,
  seats: POS.slice(0,9),
  hero: 'BTN',
  sequence: 'preflop',  // 'preflop' | 'river'
  street: 'preflop',
  deck: [],
  hands: {},   // seat -> [c1,c2]
  stacks: {},  // seat -> number (BB)
  committed: {}, // seat -> number (this street)
  inPot: {},   // seat -> cumulative committed (for potential sidepots later)
  folded: {},  // seat -> boolean
  allin: {},   // seat -> boolean
  pot: 0,
  currentBet: 0, // largest total committed (this round)
  lastRaise: BB, // size of the last raise (for min-raise rule)
  board: [],
  order: [],   // action order for current street
  acted: new Set(), // who has acted this round (for flow)
  lastAggressor: null, // seat string
  interacted: new Set(), // reached showdown vs hero tracker
  showdownSet: new Set(), // who to reveal
  seatNodes: {}, // seat -> {root, stack}
  heroCardsNode: null,
  rng: Math.random, // simple RNG
};

/* ====== Deck / dealing ====== */
function freshDeck(){
  const d=[];
  for(const r of RANKS) for(const s of SUITS) d.push(r+s);
  // shuffle
  for(let i=d.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [d[i],d[j]] = [d[j],d[i]];
  }
  return d;
}
function draw(){ return S.deck.pop(); }

/* ====== UI build: seats, stacks, hero cards, board, HUD ====== */
function layoutSeats(){
  const seatsEl = $('#seats'); seatsEl.innerHTML='';
  S.seatNodes = {};
  const table = $('#table');
  const R = (table.clientWidth/2) - 110;
  S.seats.forEach((p,i)=>{
    const a = (i*(360/S.seats.length)-90) * Math.PI/180;
    const x = 50 + R*Math.cos(a)/(table.clientWidth/100);
    const y = 50 + R*Math.sin(a)/(table.clientHeight/100);
    const n = el('div','seat'); n.style.left=x+'%'; n.style.top=y+'%'; n.id='seat-'+p; n.textContent=p;
    const stack = el('div','stack', '—'); stack.id='stack-'+p; n.appendChild(stack);
    seatsEl.appendChild(n);
    S.seatNodes[p] = {root:n, stack, pos:{x,y}};
  });
}
function markHero(){
  S.seats.forEach(s=>{
    S.seatNodes[s].root.classList.toggle('hero', s===S.hero);
  });
}
function setActing(s,on){
  const node=S.seatNodes[s]; if(!node) return;
  node.root.classList.toggle('acting', !!on);
  if(on) setTimeout(()=>node.root.classList.remove('acting'), 1100);
}
function setFolded(s){
  const node=S.seatNodes[s]; if(!node) return;
  node.root.classList.add('folded');
  // brief orange "Fold"
  const prev = node.root.textContent;
  node.root.textContent = 'FOLD';
  setTimeout(()=>{ if(S.folded[s]) node.root.textContent='FOLD'; else node.root.textContent=prev; }, 1200);
}
function heroCardsRender(){
  // remove old
  if(S.heroCardsNode) S.heroCardsNode.remove();
  const seat = S.seatNodes[S.hero]; if(!seat) return;
  const wrap = el('div','hero-cards');
  wrap.style.left = seat.root.style.left;
  wrap.style.top  = seat.root.style.top;
  for(const c of S.hands[S.hero]){
    const cd = el('div','hero-card '+suitClass(c[1]), `<span>${c}</span>`);
    wrap.appendChild(cd);
  }
  $('#table').appendChild(wrap);
  S.heroCardsNode = wrap;
}
function boardRender(){
  const b = $('#board'); b.innerHTML='';
  S.board.forEach(c=>{
    b.appendChild(el('div','card '+suitClass(c[1]), c));
  });
}
function stacksRender(){
  S.seats.forEach(s=>{
    S.seatNodes[s].stack.textContent = fmt(S.stacks[s])+' BB';
  });
}
function hudRender(){
  $('#hudStreet').textContent = S.street.toUpperCase();
  $('#hudPot').textContent = 'Pot '+fmt(S.pot)+' BB';
  // crude effective stack among active
  const alive = S.seats.filter(s=>!S.folded[s]);
  const eff = alive.length ? Math.min(...alive.map(s=>S.stacks[s])) : 0;
  const spr = S.pot>0 ? (eff/Math.max(0.1,S.pot)).toFixed(1) : '—';
  $('#hudSpr').textContent = 'SPR '+spr;
}
function chipPlate(seat, label){
  const node=S.seatNodes[seat]; if(!node) return;
  const p = el('div','chip-plate', `<span class="chip-icon"></span>${label}`);
  p.style.left = node.root.style.left;
  // toward center so it doesn’t overlap seat
  const y = parseFloat(node.root.style.top);
  p.style.top = `calc(${y}% - 54px)`;
  $('#table').appendChild(p);
  // persist for the street; remove when street advances
  if(!S._streetPlates) S._streetPlates = [];
  S._streetPlates.push(p);
}

/* ====== HUD prompt & actions ====== */
function setPrompt(txt){
  $('#prompt').textContent = txt;
}
function clearActions(){ $('#actions').innerHTML=''; }
function actionBtn(label, cls, on){
  const b=el('button', 'action-btn '+(cls||''), label); b.onclick=on; return b;
}

/* ====== Accounting helpers ====== */
function resetCommitted(){
  S.committed = {}; S.seats.forEach(s=> S.committed[s]=0);
}
function startStreetAccounting(){
  S.currentBet = 0;
  S.lastRaise  = BB; // base for postflop first raise size
  resetCommitted();
  // blinds only preflop
  if(S.street==='preflop'){
    S.currentBet = BB;
    payTo('SB', SB);
    payTo('BB', BB);
  }
  hudRender();
}
function toCall(s){ return Math.max(0, S.currentBet - S.committed[s]); }
function payTo(s, target){ // target = total to have committed this round
  const need = Math.max(0, target - S.committed[s]);
  const pay = Math.min(need, S.stacks[s]);
  S.stacks[s]   = +(S.stacks[s] - pay).toFixed(1);
  S.committed[s]= +(S.committed[s] + pay).toFixed(1);
  S.inPot[s]    = +(S.inPot[s] + pay).toFixed(1);
  S.pot         = +(S.pot + pay).toFixed(1);
  if(S.stacks[s]<=0){ S.allin[s]=true; }
  stacksRender(); hudRender();
  return pay;
}
function everyoneEqualized(){
  const live = S.seats.filter(s=>!S.folded[s] && !S.allin[s]);
  // if nobody live (all folded but one), equalized by default
  if(live.length<=1) return true;
  const target = S.currentBet;
  return live.every(s=> S.committed[s] === target );
}

/* ====== Strength & GTO-ish policy (simplified mixed strategy) ====== */
function holeStrength(cs){
  // Very rough strength metric (pairs/suited/connectivity/high cards)
  const rIdx = r => RANKS.indexOf(r);
  const a=cs[0], b=cs[1];
  const pair = a[0]===b[0];
  const suited = a[1]===b[1];
  const gap = Math.abs(rIdx(a[0])-rIdx(b[0]));
  const hi = (['A','K','Q','J','T'].includes(a[0])?1:0) + (['A','K','Q','J','T'].includes(b[0])?1:0);
  let s = (pair?25:0) + (suited?6:0) + (gap<=1?5:0) + hi*4;
  return s + Math.random()*3;
}
function boardAffinity(cs, board){
  if(board.length===0) return 0;
  const ranks = board.map(c=>c[0]);
  const pair = ranks.includes(cs[0][0]) || ranks.includes(cs[1][0]);
  const suit = (cs[0][1]===cs[1][1]);
  const hi = ranks.filter(r=>['A','K','Q','J','T'].includes(r)).length;
  return (pair?8:0)+(suit?2:0)+hi*1.2 + Math.random()*2;
}
function mix(prob){ return Math.random()<prob; }
function policyKey(seat){
  // returns one of: 'fold'|'call'|'open'|'raise'|'jam'|'check'|'betSmall'|'betMed'|'betBig'
  const need = toCall(seat);
  const stack = S.stacks[seat];
  if(S.street==='preflop'){
    const hs = holeStrength(S.hands[seat]);
    if(need===0){
      if(hs>28 && mix(0.65)) return 'open';
      if(hs>22 && mix(0.35)) return 'open';
      return 'check'; // BB checking when no raise (rare path), or allow limp (treated as check)
    }else{
      if(hs<15 && mix(0.85)) return 'fold';
      if(hs>33 && stack<= (S.currentBet+stack) && mix(0.20)) return 'jam';
      if(hs>28 && mix(0.55)) return 'raise';
      if(mix(0.45)) return 'call';
      return 'fold';
    }
  }else{
    const aff = boardAffinity(S.hands[seat], S.board);
    if(need===0){
      if(aff>9 && mix(0.45)) return 'betBig';
      if(aff>6 && mix(0.55)) return 'betMed';
      if(aff>3 && mix(0.6))  return 'betSmall';
      return 'check';
    }else{
      if(aff<3 && mix(0.65)) return 'fold';
      if(aff>9 && mix(0.25)) return 'jam';
      if(aff>6 && mix(0.45)) return 'raise';
      if(mix(0.55)) return 'call';
      return 'fold';
    }
  }
}

/* ====== Chips plate lifecycle ====== */
function clearStreetPlates(){
  if(S._streetPlates) S._streetPlates.forEach(p=>p.remove());
  S._streetPlates = [];
}

/* ====== Betting actions (apply with legality) ====== */
function legalMinRaiseTo(){  // total to which bet must be raised
  const minR = (S.lastRaise>0 ? S.lastRaise : BB);
  return +(S.currentBet + minR).toFixed(1);
}
function doFold(seat){
  S.folded[seat]=true; setFolded(seat);
}
function doCheck(seat){
  chipPlate(seat,'Check');
}
function doCall(seat){
  const need = toCall(seat);
  const paid = payTo(seat, S.committed[seat] + need);
  chipPlate(seat, `Call ${fmt(paid)} BB`);
}
function doBetOrRaiseTo(seat, toTotal){
  // enforce minimum raise rule
  const minTo = S.currentBet===0 ? Math.max(BB, toTotal) : legalMinRaiseTo();
  const target = Math.max(toTotal, minTo);
  const maxTo = S.committed[seat] + S.stacks[seat];
  const finalTo = Math.min(target, maxTo); // all-in cap
  const delta = +(finalTo - S.currentBet).toFixed(1);
  // Update lastRaise only if raise size >= previous lastRaise (else it’s a call/all-in call)
  if(finalTo > S.currentBet){
    const raiseSize = +(finalTo - S.currentBet).toFixed(1);
    if(S.currentBet===0){ S.lastRaise = Math.max(raiseSize, BB); } else { S.lastRaise = raiseSize; }
    S.currentBet = finalTo;
    S.lastAggressor = seat;
  }
  const before = S.committed[seat];
  payTo(seat, finalTo);
  const putIn = +(S.committed[seat] - before).toFixed(1);
  chipPlate(seat, (finalTo>=maxTo ? 'All-in' : (S.street==='preflop' && before===0 ? `Open ${fmt(finalTo)} BB` : (before>0 && finalTo>before ? `Raise ${fmt(putIn)} BB` : `Bet ${fmt(putIn)} BB`))));
}

/* ====== Round flow ====== */
function actionOrder(){
  // Preflop starts UTG; postflop starts from SB (first active left of BTN)
  if(S.street==='preflop') return POS.slice(0,S.players); // UTG..BB
  // postflop: first active seat to left of BTN (SB typically)
  const iBTN = S.seats.indexOf('BTN');
  const order=[];
  for(let i=1;i<=S.players;i++){
    const seat = S.seats[(iBTN+i)%S.players];
    order.push(seat);
  }
  return order;
}
function activeSeats(){ return S.seats.filter(s=>!S.folded[s]); }

async function bettingRound(){
  S.order = actionOrder();
  S.acted = new Set();
  let loop=0;

  while(true){
    loop++; if(loop>200) break; // safety

    for(const seat of S.order){
      if(S.folded[seat] || S.allin[seat]) continue;

      // if only one active remains, round ends
      const alive = activeSeats().filter(s=>!S.allin[s]);
      if(alive.length<=1){ return; }

      // if all equalized and at least one action occurred (or no bet was made), round ends
      if(everyoneEqualized() && S.acted.size>0){
        return;
      }

      const need = toCall(seat);
      setActing(seat,true);
      await new Promise(r=>setTimeout(r, 450 + Math.random()*450));

      if(seat===S.hero){
        // pause round and wait for hero decision
        await heroDecision();
      } else {
        // villain decision
        const k = policyKey(seat);
        // apply legality
        if(need===0){
          if(k==='check'){ doCheck(seat); }
          else if(k==='open'){ // choose an open size 2.2–3.0bb
            const openTo = +(2.0 + Math.round((2.8-2.0)*10*Math.random())/10).toFixed(1);
            doBetOrRaiseTo(seat, openTo);
            S.interacted.add(seat);
          } else if(k==='betSmall' || k==='betMed' || k==='betBig'){
            const base = S.pot>0?S.pot:2.0;
            const val = k==='betSmall'? Math.round(base*0.33) : (k==='betMed'? Math.round(base*0.5): Math.round(base*0.66));
            doBetOrRaiseTo(seat, S.currentBet + Math.max(2, val));
            S.interacted.add(seat);
          } else if(k==='jam'){
            doBetOrRaiseTo(seat, S.committed[seat]+S.stacks[seat]);
            S.interacted.add(seat);
          } else {
            doCheck(seat);
          }
        } else {
          if(k==='fold'){ doFold(seat); }
          else if(k==='call'){ doCall(seat); }
          else if(k==='raise'){
            const minTo = legalMinRaiseTo();
            const raiseTo = +(minTo + Math.max(2, Math.round(S.pot*0.25))).toFixed(1);
            doBetOrRaiseTo(seat, raiseTo);
            S.interacted.add(seat);
          } else if(k==='jam'){
            doBetOrRaiseTo(seat, S.committed[seat]+S.stacks[seat]);
            S.interacted.add(seat);
          } else {
            // fallback: call
            doCall(seat);
          }
        }
        S.acted.add(seat);
      }
      setActing(seat,false);

      // Early end if equalized and at least one acted
      if(everyoneEqualized() && S.acted.size>0) return;
    }
  }
}

/* ====== Hero decision (render buttons & await) ====== */
function offerHeroButtons(resolve){
  clearActions();
  const need = toCall(S.hero);
  const eff = S.stacks[S.hero];

  // Fold always available if facing bet
  if(need>0) $('#actions').appendChild(actionBtn(`Fold`, 'action-danger', ()=>resolve('fold')));

  if(need===0) $('#actions').appendChild(actionBtn(`Check`, 'action-btn', ()=>resolve('check')));
  else $('#actions').appendChild(actionBtn(`Call ${fmt(Math.min(need,eff))} BB`, 'action-primary', ()=>resolve('call')));

  // sizing proposals
  const minTo = (S.currentBet===0) ? Math.max(BB, 2.2) : legalMinRaiseTo();
  const potRef = Math.max(2, S.pot);
  let sizes=[];
  if(S.street==='preflop'){
    sizes = [+(minTo).toFixed(1), +(Math.max(minTo, 3.0)).toFixed(1), +(Math.max(minTo, 4.5)).toFixed(1)];
  } else {
    const bS = Math.round(potRef*0.33), bM = Math.round(potRef*0.5), bB = Math.round(potRef*0.66);
    sizes = [S.currentBet + bS, S.currentBet + bM, S.currentBet + bB].map(x=>+x.toFixed(1));
  }
  sizes.forEach(to=>{
    const isJam = (S.committed[S.hero]+eff) <= to+1e-6;
    const label = S.currentBet===0 ? `Bet ${fmt(to)} BB` : `Raise to ${fmt(to)} BB`;
    $('#actions').appendChild(actionBtn(isJam?'All-in':label, isJam?'action-danger':'action-primary', ()=>resolve(isJam?'jam':`raise:${to}`)));
  });
  // explicit All-in
  $('#actions').appendChild(actionBtn(`All-in`, 'action-danger', ()=>resolve('jam')));
}
function applyHeroAction(a){
  const need = toCall(S.hero);
  if(a==='fold'){ doFold(S.hero); return 'done'; }
  if(a==='check'){ doCheck(S.hero); return; }
  if(a==='call'){ doCall(S.hero); return; }
  if(a==='jam'){
    doBetOrRaiseTo(S.hero, S.committed[S.hero]+S.stacks[S.hero]);
    S.interacted.add(S.hero);
    return;
  }
  if(a.startsWith('raise:')){
    const to= parseFloat(a.split(':')[1]);
    doBetOrRaiseTo(S.hero, to);
    S.interacted.add(S.hero);
    return;
  }
}
function heroDecision(){
  setPrompt(`${S.street.toUpperCase()}: Your action as ${S.hero}.`);
  return new Promise(resolve=>{
    offerHeroButtons(res=>{
      // apply
      const done = applyHeroAction(res);
      // If hero folded, end hand immediately
      if(done==='done'){
        clearActions();
        endStreetAndMaybeFinish(true);
        resolve();
      }else{
        clearActions();
        resolve();
      }
    });
  });
}

/* ====== Streets ====== */
function dealPreflop(){
  S.deck = freshDeck();
  S.hands = {}; S.board = [];
  S.seats.forEach(s=> S.hands[s]=[draw(),draw()]);
}
function dealFlop(){ S.board = [draw(),draw(),draw()]; }
function dealTurn(){ S.board.push(draw()); }
function dealRiver(){ S.board.push(draw()); }

function advanceStreet(){
  // settle pot (already tracked via committed), clear street chips
  clearStreetPlates();
  // reset per-street commitments
  S.seats.forEach(s=> S.committed[s]=0);
  S.currentBet = 0; S.lastRaise = BB; S.acted.clear(); S.lastAggressor=null;

  if(S.street==='preflop'){ S.street='flop'; dealFlop(); }
  else if(S.street==='flop'){ S.street='turn'; dealTurn(); }
  else if(S.street==='turn'){ S.street='river'; dealRiver(); }
  else { S.street='showdown'; }
  boardRender(); hudRender();
  startStreetAccounting();
}

/* ====== Finish & scoring ====== */
function showdownReveal(){
  // Only reveal hero and villains who interacted (bet/raise/call) and didn’t fold
  S.showdownSet = new Set(S.seats.filter(s => (s===S.hero) || (S.interacted.has(s) && !S.folded[s])));
  S.showdownSet.forEach(seat=>{
    const node = S.seatNodes[seat]; if(!node) return;
    const holder = el('div','hero-cards'); // reuse style for placement
    holder.style.left = node.root.style.left;
    holder.style.top  = node.root.style.top;
    holder.style.transform = 'translate(-50%,-120%)';
    S.hands[seat].forEach(c=>{
      holder.appendChild(el('div', 'card '+suitClass(c[1]), c));
    });
    $('#table').appendChild(holder);
  });
}
function gtoScore(){
  // Simple rubric: folding trash preflop → 100%; crazy jams penalized; otherwise 50–90
  if(S.street!=='showdown'){
    // If hero folded before showdown, rate by junkness
    if(S.folded[S.hero]){
      const hs = holeStrength(S.hands[S.hero]);
      return Math.min(100, Math.max(50, Math.round(120 - hs*2.2)));
    }
  }
  // if hero jammed light preflop, lower
  if(S.inPot[S.hero] >= 80){ return 35 + Math.round(Math.random()*10); }
  return 60 + Math.round(Math.random()*35);
}
function showResult(){
  const pct = clamp(gtoScore(),0,100);
  $('#scoreNum').textContent = pct+'%';
  $('#scoreVerdict').textContent = (pct>=85?'Excellent':pct>=70?'Strong':pct>=50?'Okay':'Needs work');
  const res = $('#result'); res.style.display='block';
  // log
  const row = el('div','row', `<div><b>${S.hero}</b> • ${S.sequence.toUpperCase()} • ${S.street.toUpperCase()}</div><div class="${pct>=50?'good':'bad'}">${pct}% ${pct>=50?'✅':'❌'}</div>`);
  $('#log').prepend(row);
}

/* ====== End-of-street / end-of-hand control ====== */
function endStreetAndMaybeFinish(endImmediately=false){
  // If hero folded or sequence=preflop and we finished preflop, end.
  const seqStop = (S.sequence==='preflop' && S.street==='preflop');
  if(endImmediately || seqStop){
    S.street='showdown';
    showdownReveal();
    showResult();
    clearActions();
    $('#actions').appendChild(actionBtn('Next Hand','action-primary', startNewHand));
    return true;
  }
  return false;
}

/* ====== Hand lifecycle ====== */
async function playHand(){
  // Preflop round
  S.street='preflop'; startStreetAccounting(); hudRender(); setPrompt('Preflop: actions start UTG.');
  await bettingRound();
  if(endStreetAndMaybeFinish(false)) return;

  advanceStreet();
  setPrompt('Flop: first to act is left of BTN.');
  await bettingRound();
  if(endStreetAndMaybeFinish(false)) return;

  advanceStreet();
  setPrompt('Turn: continue.');
  await bettingRound();
  if(endStreetAndMaybeFinish(false)) return;

  advanceStreet();
  setPrompt('River: final betting.');
  await bettingRound();

  // Showdown
  S.street='showdown';
  showdownReveal();
  showResult();
  clearActions();
  $('#actions').appendChild(actionBtn('Next Hand','action-primary', startNewHand));
}

function resetState(){
  S.pot=0; S.board=[]; S.inPot={}; S.folded={}; S.allin={}; S.interacted=new Set(); S.showdownSet=new Set();
  S.seats.forEach(s=>{ S.stacks[s]=100; S.inPot[s]=0; S.folded[s]=false; S.allin[s]=false; });
  dealPreflop();
  boardRender(); heroCardsRender(); stacksRender(); hudRender();
}

function startNewHand(){
  $('#result').style.display='none'; $('#scoreNum').textContent=''; $('#scoreVerdict').textContent='';
  clearStreetPlates();
  // clear any showdown reveals
  $$('#table .hero-cards').forEach(n=>n.remove());
  S.sequence = $('#sequence').value;
  resetState();
  playHand();
}

/* ====== Boot ====== */
function boot(){
  // build seat layout
  S.seats = POS.slice(0,9);
  layoutSeats();
  // hero options
  const heroSel = $('#heroPos');
  heroSel.innerHTML = S.seats.map(s=>`<option>${s}</option>`).join('');
  heroSel.value = 'BTN';
  S.hero = 'BTN';
  heroSel.onchange = ()=>{
    S.hero = heroSel.value; markHero(); heroCardsRender();
  };
  markHero();

  $('#newHand').onclick = startNewHand;
  $('#clearLog').onclick = ()=>{ $('#log').innerHTML=''; };

  // init stacks before first render
  S.seats.forEach(s=> S.stacks[s]=100);
  stacksRender(); hudRender();
  startNewHand(); // auto-start
}
</script>
<script>
  document.addEventListener('DOMContentLoaded', boot);
  window.addEventListener('resize', ()=>{
    // keep hero cards anchored and seats within table on resize
    layoutSeats(); markHero(); heroCardsRender();
  });
</script>
</body>
</html>









