<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>GTO Shark • Live Practice (Indigo/Teal Felt)</title>
  <style>
    :root{
      --bg:#0c1324;          /* page */
      --felt:#0e172a;        /* table center */
      --felt2:#0a1222;       /* table edge */
      --ring:#5960ff28;      /* outer glow */
      --indigo:#4f46e5;
      --teal:#14b8a6;
      --ink:#e5e7eb;
      --ink-d:#94a3b8;
      --good:#22c55e;
      --bad:#ef4444;
      --warn:#f59e0b;
      --seat:#132139;
      --seat-br:#2b3b59;
      --hero-br:#22c55e;
      --act-br:#fbbf24;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;background:
        radial-gradient(1200px 900px at 50% -200px, #0f1e3a 0%, transparent 60%),
        linear-gradient(180deg,#0b1020 0%, #0a0f1d 100%);
      color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
    }

    /* ---------- Layout ---------- */
    .app{
      display:grid;
      grid-template-columns:minmax(820px,1fr) 360px;
      gap:18px; padding:18px;
      align-items:start;
    }
    @media (max-width:1200px){ .app{ grid-template-columns:1fr; } .sidebar{order:3} }

    header{display:flex;gap:14px;align-items:center;justify-content:space-between;padding:14px 18px}
    .title{font-weight:900;font-size:22px;letter-spacing:.3px}
    .subtitle{color:var(--ink-d);font-size:12px}

    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{
      background:#0f1a31;border:1px solid #24324f;color:#cbd5e1;
      padding:6px 10px;border-radius:10px;font-size:12px;min-height:32px
    }
    select,button{font:inherit}
    select{
      background:#0e172b;color:#cbd5e1;border:1px solid #2a3b5e;border-radius:10px;padding:6px 10px
    }
    .btn{
      border:0;border-radius:12px;padding:10px 14px;font-weight:800;cursor:pointer;
      transition:.15s transform ease, .2s filter ease;
    }
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .btn-primary{background:var(--indigo);color:white;box-shadow:0 10px 20px #4f46e533}
    .btn-primary:hover{filter:brightness(1.06);transform:translateY(-1px)}
    .btn-ghost{background:#122538;border:1px solid #24425f;color:#9bd7ef}
    .btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);color:#fff}

    /* ---------- Table ---------- */
    .table-wrap{display:flex;justify-content:center}
    .table{
      --size:860px;
      position:relative;width:var(--size);height:var(--size);border-radius:9999px;
      background:radial-gradient(70% 70% at 50% 45%, var(--felt) 0%, var(--felt2) 100%);
      box-shadow:inset 0 0 90px #000a, 0 0 30px var(--ring), 0 0 70px #13c6b366;
      border:10px solid #3946a31f;
      overflow:hidden;
    }
    .rim{
      position:absolute;inset:12px;border-radius:9999px;
      box-shadow:inset 0 0 80px #4f46e52a, inset 0 0 200px #14b8a617;
    }

    /* Center HUD (street/pot/SPR) */
    .hud{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      display:flex;gap:10px;align-items:center;
      background:#0a1326cc;border:1px solid #314062;
      padding:6px 10px;border-radius:10px;font-weight:800;font-size:12px;color:#c7d2fe;
      backdrop-filter: blur(2px);
      z-index:30;
    }
    .hud .tag{opacity:.75}

    /* Seats */
    .seat{
      position:absolute;transform:translate(-50%,-50%);
      width:80px;height:80px;border-radius:9999px;background:var(--seat);
      border:2px solid var(--seat-br); display:flex;align-items:center;justify-content:center;
      color:#a9bdd6; font-weight:900; font-size:12px; text-transform:uppercase;
      box-shadow:0 12px 24px #0008;
      transition:.2s filter ease, .25s box-shadow ease, .2s border-color ease, .2s color ease;
      z-index:3;
    }
    .seat.hero{border-color:var(--hero-br); color:#c8facc; box-shadow:0 0 24px #22c55e66, 0 14px 26px #0008;}
    .seat.acting{border-color:var(--act-br); color:#fde68a; box-shadow:0 0 26px #f59e0b66, 0 14px 26px #0008;}
    .seat.folded{filter:grayscale(.7) brightness(.8); color:#7b879a;border-color:#314259}

    .stack{
      position:absolute; left:50%; top:calc(100% + 16px); transform:translateX(-50%);
      background:#0b1326; border:1px solid #38496a; color:#c7d2fe; padding:2px 8px; border-radius:999px;
      font-size:11px; white-space:nowrap; z-index:2;
    }

    /* Hero cards above seat */
    .cards{
      position:absolute; transform:translate(-50%,-110%); display:flex; gap:8px; z-index:40;
    }

    /* Cards */
    .card{
      width:72px;height:100px;border-radius:14px;display:flex;flex-direction:column;align-items:center;justify-content:center;
      background:linear-gradient(160deg,#ffffff 0%, #f5f7ff 55%, #e8ecff 100%);
      border:2px solid #5660ff; box-shadow:0 10px 22px #0008;
    }
    .rank{font-size:34px;font-weight:1000;line-height:1;margin-top:3px}
    .suit{font-size:26px;line-height:1}
    .red{color:#ef4444} .black{color:#0f172a}

    /* Board */
    .board{position:absolute;left:50%;top:48%;transform:translate(-50%,-50%);display:flex;gap:10px;z-index:25}
    .board .card{width:68px;height:92px;border-radius:12px}

    /* Floating bet chips/labels that persist per street */
    .float-layer{position:absolute;inset:0;pointer-events:none;z-index:35}
    .betplate{
      position:absolute;transform:translate(-50%,-58px); display:flex;align-items:center;gap:6px;
      background:linear-gradient(135deg,#16243e,#0e1930); border:1px solid #495a84; color:#dbeafe;
      padding:6px 10px;border-radius:10px;font-weight:900;font-size:12px; box-shadow:0 10px 20px #0008;
      animation:rise 1.1s ease-out both;
    }
    .chip{width:14px;height:14px;border-radius:999px;background:
      radial-gradient(circle at 50% 50%, #f59e0b 0 26%, #7c3aed 28% 32%, #f59e0b 35% 60%, #7c3aed 63% 67%, #f59e0b 70%);
      border:1px solid #f59e0b; box-shadow:0 0 0 1px #7c3aed inset;
    }
    @keyframes rise { from{opacity:0; transform:translate(-50%,-46px)} to{opacity:1; transform:translate(-50%,-58px)} }

    /* Action bar (always below table) */
    .actionbar-wrap{display:flex;justify-content:center}
    .actionbar{
      width:min(980px,92vw); margin-top:18px; padding:12px; border-radius:14px;
      background:#0b1326; border:1px solid #2b3b59; box-shadow:0 10px 20px #0008;
      display:flex;justify-content:center;gap:10px;flex-wrap:wrap; min-height:58px;
    }

    /* Panels */
    .panel{background:#0b1326;border:1px solid #2a3a58;border-radius:16px;padding:14px}
    .panel h3{margin:0 0 6px 0}
    .muted{color:var(--ink-d)}

    .result{background:linear-gradient(135deg,var(--indigo),var(--teal));color:white;border-radius:16px;padding:14px;box-shadow:0 0 24px #14b8a633}
    .big{font-size:44px;font-weight:1000}
    .good{color:var(--good)} .bad{color:var(--bad)}

    .log-item{display:flex;justify-content:space-between;align-items:center;gap:6px;padding:10px;border-radius:12px;
      border:1px solid #2a3b58;background:#0a1226;margin-bottom:8px}
    .log-item .score{font-weight:900}
  </style>
</head>
<body>
  <header>
    <div>
      <div class="title">GTO Shark • Live Practice</div>
      <div class="subtitle">Cinematic indigo/teal felt • Hero-gated streets • GTO-style villains</div>
    </div>
    <div class="controls">
      <label class="pill">Players
        <select id="playersSel">
          <option>9-max</option><option>8-max</option><option>7-max</option><option>6-max</option><option>5-max</option>
        </select>
      </label>
      <label class="pill">Hero Position
        <select id="heroSel"></select>
      </label>
      <label class="pill">Play-Through Range
        <select id="rangeSel">
          <option value="preflop">Play Preflop only</option>
          <option value="turn">Play to Turn</option>
          <option value="river" selected>Play to River</option>
        </select>
      </label>
      <label class="pill">Start Street
        <select id="startSel">
          <option value="preflop" selected>Preflop</option>
          <option value="flop">Flop</option>
          <option value="turn">Turn</option>
          <option value="river">River</option>
        </select>
      </label>
      <button id="newBtn" class="btn btn-primary">♠ New Hand</button>
    </div>
  </header>

  <div class="app">
    <!-- TABLE + ACTION BAR -->
    <main>
      <div class="table-wrap">
        <div id="table" class="table">
          <div class="rim"></div>

          <!-- Center HUD -->
          <div id="hud" class="hud">
            <span id="hudStreet" class="tag">—</span>
            <span>•</span>
            <span id="hudPot">Pot —</span>
            <span>•</span>
            <span id="hudSPR">SPR —</span>
          </div>

          <!-- Board + seating layers -->
          <div id="board" class="board"></div>
          <div id="seatsLayer"></div>
          <div id="floatLayer" class="float-layer"></div>
        </div>
      </div>

      <!-- ACTIONS (always below the table) -->
      <div class="actionbar-wrap">
        <div id="actions" class="actionbar"></div>
      </div>

      <!-- Prompt -->
      <div class="panel" style="margin-top:12px">
        <h3>Your move</h3>
        <div id="prompt" class="muted">Engine ready.</div>
      </div>
    </main>

    <!-- SIDEBAR -->
    <aside class="sidebar" style="display:flex;flex-direction:column;gap:14px">
      <div id="resultPanel" class="result" style="display:none">
        <div id="scorePct" class="big">—%</div>
        <div id="scoreVerdict" style="font-weight:800;opacity:.95"></div>
        <div style="margin-top:10px;display:flex;gap:8px">
          <button id="nextBtn" class="btn btn-primary">Next Hand</button>
          <button id="replayBtn" class="btn btn-ghost">Replay</button>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <h3>Hand Log</h3>
          <button id="clearLog" class="btn btn-ghost" style="padding:6px 10px">Clear</button>
        </div>
        <div class="muted" style="font-size:12px;margin:.3rem 0 .6rem">✅ ≥ 50% ❌ &lt; 50%</div>
        <div id="logList"></div>
      </div>
    </aside>
  </div>

  <!-- ======== SCRIPT ======== -->
  <script>
  /***********************
   * Utility / RNG
   ***********************/
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  let _seed = Date.now()|0;
  function srand(n){ _seed = (n>>>0)||0x12345678; }
  function rnd(){ _seed^=_seed<<13; _seed^=_seed>>>17; _seed^=_seed<<5; return ((_seed>>>0)%1e6)/1e6; }

  /***********************
   * DOM refs
   ***********************/
  const tableEl     = document.getElementById('table');
  const seatsLayer  = document.getElementById('seatsLayer');
  const boardEl     = document.getElementById('board');
  const floatLayer  = document.getElementById('floatLayer');
  const actionsEl   = document.getElementById('actions');
  const hudStreet   = document.getElementById('hudStreet');
  const hudPot      = document.getElementById('hudPot');
  const hudSPR      = document.getElementById('hudSPR');
  const promptEl    = document.getElementById('prompt');

  const playersSel  = document.getElementById('playersSel');
  const heroSel     = document.getElementById('heroSel');
  const rangeSel    = document.getElementById('rangeSel');
  const startSel    = document.getElementById('startSel');
  const newBtn      = document.getElementById('newBtn');

  const resultPanel = document.getElementById('resultPanel');
  const scorePctEl  = document.getElementById('scorePct');
  const scoreVerdEl = document.getElementById('scoreVerdict');
  const nextBtn     = document.getElementById('nextBtn');
  const replayBtn   = document.getElementById('replayBtn');
  const clearLogBtn = document.getElementById('clearLog');
  const logList     = document.getElementById('logList');

  /***********************
   * Cards helpers
   ***********************/
  const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
  const SUITS = ["♠","♥","♦","♣"];
  const suitClass = s => (s==="♥"||s==="♦") ? "red" : "black";

  function dealUnique(n, taken=new Set()){
    const out=[];
    while(out.length<n){
      const c = RANKS[Math.floor(rnd()*13)] + SUITS[Math.floor(rnd()*4)];
      if(!taken.has(c)){ taken.add(c); out.push(c); }
    }
    return out;
  }
  function cardEl(card, small=false){
    const el = document.createElement('div');
    el.className = 'card';
    if(small) el.style.cssText = 'width:68px;height:92px;border-radius:12px';
    const r=card[0], s=card[1];
    el.innerHTML = `<div class="rank ${suitClass(s)}">${r}</div><div class="suit ${suitClass(s)}">${s}</div>`;
    return el;
  }

  /***********************
   * Seats templates
   ***********************/
  const TEMPLATES = {
    '9-max': ["SB","BB","UTG","UTG+1","MP","LJ","HJ","CO","BTN"],
    '8-max': ["SB","BB","UTG","UTG+1","LJ","HJ","CO","BTN"],
    '7-max': ["SB","BB","UTG","HJ","CO","BTN","LJ"],
    '6-max': ["SB","BB","UTG","HJ","CO","BTN"],
    '5-max': ["SB","BB","UTG","CO","BTN"],
  };

  /***********************
   * State
   ***********************/
  const S = {
    seats: [], hero:"BTN", players:"9-max",
    street:"preflop", startStreet:"preflop", playThrough:"river",
    stacks:{}, committed:{}, folded:{}, allin:{}, hands:{},
    board:[], pot:0, currentTo:0, lastRaise:1, interacted:new Set(),
    perStreetPlates:[], // chip plates to clear each new street
    log:[], snapshot:null
  };

  /***********************
   * Layout seats + hero cards
   ***********************/
  function layoutSeats(){
    seatsLayer.innerHTML = '';
    S.nodes = {};
    const N = S.seats.length;
    const R = (tableEl.clientWidth/2) - 90;
    const offset = -90; // deg start
    for(let i=0;i<N;i++){
      const label = S.seats[i];
      const a = (offset + i*(360/N)) * Math.PI/180;
      const x = 50 + (R*Math.cos(a))/(tableEl.clientWidth/100);
      const y = 50 + (R*Math.sin(a))/(tableEl.clientHeight/100);
      const seat = document.createElement('div');
      seat.className = 'seat';
      seat.style.left = x+'%'; seat.style.top = y+'%';
      seat.textContent = label;
      const stack = document.createElement('div');
      stack.className = 'stack'; stack.id = `stack-${label}`; stack.textContent = '—';
      seat.appendChild(stack);
      seatsLayer.appendChild(seat);
      S.nodes[label] = {seat, stack, pos:{x,y}, label};
    }
    setHeroHighlight();
  }
  function setHeroHighlight(){
    S.seats.forEach(p=>{
      const n=S.nodes[p]; if(!n) return;
      n.seat.classList.toggle('hero', p===S.hero);
    });
  }
  function heroCards(){
    // remove any existing
    document.querySelectorAll('.cards').forEach(n=>n.remove());
    const pos=S.nodes[S.hero]; if(!pos) return;
    const holder=document.createElement('div');
    holder.className='cards'; holder.style.left=pos.pos.x+'%'; holder.style.top=pos.pos.y+'%';
    S.hands[S.hero]?.forEach(c=> holder.appendChild(cardEl(c,false)));
    tableEl.appendChild(holder);
  }

  /***********************
   * HUD / Chips / Board
   ***********************/
  function updateStacksUI(){
    for(const p of S.seats){
      const el=S.nodes[p]?.stack; if(!el) continue;
      el.textContent = `${S.stacks[p].toFixed(1)} BB`;
    }
  }
  function updateHUD(){
    const live = S.seats.filter(p=>!S.folded[p]);
    const eff = live.length ? Math.min(...live.map(p=>Math.max(0.1,S.stacks[p]))) : 0.1;
    const spr = S.pot ? (eff/S.pot).toFixed(1) : '∞';
    hudStreet.textContent = S.street.toUpperCase();
    hudPot.textContent    = `Pot ${S.pot.toFixed(1)} BB`;
    hudSPR.textContent    = `SPR ${spr}`;
  }
  function clearBoard(){ boardEl.innerHTML=''; }
  function renderBoard(){
    boardEl.innerHTML='';
    S.board.forEach(c=> boardEl.appendChild(cardEl(c,true)));
  }
  function clearStreetPlates(){
    S.perStreetPlates.forEach(el=>el.remove());
    S.perStreetPlates=[];
  }
  function putPlate(seat, text){
    const node=S.nodes[seat]; if(!node) return;
    const p=document.createElement('div');
    p.className='betplate';
    p.style.left = node.seat.style.left;
    p.style.top  = `calc(${node.seat.style.top} - 0px)`; // anchored in front
    p.innerHTML = `<span class="chip"></span><span>${text}</span>`;
    floatLayer.appendChild(p);
    S.perStreetPlates.push(p);
  }
  function setActing(seat,on){
    const n=S.nodes[seat]; if(!n) return;
    n.seat.classList.toggle('acting', !!on);
    if(on){ setTimeout(()=>n.seat?.classList.remove('acting'), 1400); }
  }
  function setFolded(seat){
    const n=S.nodes[seat]; if(!n) return;
    n.seat.classList.add('folded'); n.seat.textContent='FOLD'; n.stack.style.opacity=.6;
  }

  /***********************
   * Betting accounting
   ***********************/
  function resetCommitted(){ S.committed={}; S.seats.forEach(p=>S.committed[p]=0); }
  function initStreet(){
    clearStreetPlates();
    S.currentTo = 0;
    resetCommitted();
    if(S.street==='preflop'){
      S.committed.SB = 0.5; S.stacks.SB -= 0.5; S.pot += 0.5;
      S.committed.BB = 1.0; S.stacks.BB -= 1.0; S.pot += 1.0;
      S.currentTo = 1.0; S.lastRaise = 1.0;
    }
    updateStacksUI(); updateHUD();
  }
  const toCall = (p)=> Math.max(0, S.currentTo - S.committed[p]);
  function payTo(p, target){
    const need=Math.max(0, target - S.committed[p]);
    const pay = Math.min(need, S.stacks[p]);
    S.stacks[p] = +(S.stacks[p]-pay).toFixed(1);
    S.committed[p] = +(S.committed[p]+pay).toFixed(1);
    S.pot = +(S.pot+pay).toFixed(1);
    updateStacksUI(); updateHUD();
    return pay;
  }
  function everyoneMatched(){
    const active = S.seats.filter(p=>!S.folded[p]);
    return active.every(p=> S.committed[p]===S.currentTo );
  }

  /***********************
   * Strength & (simplified) GTO policy
   ***********************/
  function pfStrength([a,b]){
    const r1=RANKS.indexOf(a[0]), r2=RANKS.indexOf(b[0]);
    const pair=a[0]===b[0], suited=a[1]===b[1], gap=Math.abs(r1-r2);
    let s = pair ? (100 - r1*3)
                 : (100 - Math.min(r1,r2)*4) + (suited?6:0) + (gap<=1?6:0);
    return s + rnd()*1.5;
  }
  function postStrength(cards,board){
    const ranks=board.map(c=>c[0]);
    const high=ranks.filter(r=>["A","K","Q","J","T"].includes(r)).length*2;
    const pair=ranks.some(r=>r===cards[0][0]||r===cards[1][0])?8:0;
    const suit=(cards[0][1]===cards[1][1])?3:0;
    return high+pair+suit + rnd()*2;
  }
  function policy(street, seat){
    if(street==='preflop'){
      const s=pfStrength(S.hands[seat]);
      if(s>92) return mix({raise:0.65, call:0.25, fold:0.10});
      if(s>82) return mix({raise:0.45, call:0.45, fold:0.10});
      if(s>70) return 'call';
      return mix({fold:0.8, call:0.2});
    }
    // Postflop policy considers simple strength vs board
    const s=postStrength(S.hands[seat],S.board);
    if(s>16) return mix({bet_big:0.45, bet_med:0.4, check:0.15});
    if(s>12) return mix({bet_med:0.45, bet_small:0.35, check:0.2});
    if(s>8)  return mix({bet_small:0.35, check:0.65});
    return 'check';
  }
  function mix(obj){ // roulette selection
    const r=rnd(); let acc=0;
    for(const k in obj){ acc+=obj[k]; if(r<=acc) return k; }
    return Object.keys(obj)[0];
  }

  /***********************
   * Score / EV-penalty
   ***********************/
  function evPenalty(street, act, optimal){
    if(act===optimal) return 0;
    const fam = a => a.startsWith('bet')||a.startsWith('raise') ? (a.includes('big')?'BetBig': a.includes('med')?'BetMed':'BetSmall')
               : a==='allin' ? 'Jam' : a[0].toUpperCase()+a.slice(1);
    const W = {
      preflop:{Fold:.85, Call:.55, BetSmall:.6, BetMed:.7, BetBig:.8, Jam:1.25, Raise:.7},
      flop:{Check:.25, BetSmall:.38, BetMed:.5, BetBig:.7, Jam:.9},
      turn:{Check:.3, BetSmall:.42, BetMed:.56, BetBig:.78, Jam:1.0},
      river:{Check:.38, BetSmall:.58, BetMed:.72, BetBig:.9, Jam:1.1}
    };
    const key=fam(act); let w=(W[street][key]??.55) + rnd()*0.1;

    // perfect credit for junk preflop folds
    if(street==='preflop' && act==='fold' && pfStrength(S.hands[S.hero])<66) return 0;
    return +w.toFixed(2);
  }
  function verdict(p){ return p>=85?'Excellent':p>=70?'Strong':p>=50?'Okay':'Needs Work'; }

  /***********************
   * Action buttons (hero gate)
   ***********************/
  function clearActions(){ actionsEl.innerHTML=''; }
  function addBtn(text, cls, fn, disabled=false){
    const b=document.createElement('button'); b.className=`btn ${cls}`; b.textContent=text; b.onclick=fn; b.disabled=!!disabled;
    actionsEl.appendChild(b); return b;
  }
  function heroSizes(){
    // bet/raise suggestions (BB amounts)
    const eff=S.stacks[S.hero];
    if(S.street==='preflop'){
      const base = Math.max(2, S.currentTo ? S.currentTo*1.7 : 2.5);
      return [base, base+1.5, base+3].map(v=>+v.toFixed(1));
    }
    const pot=Math.max(2,S.pot);
    return [Math.round(pot*0.33), Math.round(pot*0.5), Math.round(pot*0.66)];
  }
  function offerHero(){
    clearActions();
    const need = toCall(S.hero);
    // Fold always available
    addBtn('Fold','btn-ghost', ()=>heroAct('fold'));
    if(S.stacks[S.hero]<=0){
      addBtn('All-in (no chips)','btn-danger', ()=>{}, true);
      promptEl.textContent = `${S.street.toUpperCase()}: You are all-in. Awaiting runout…`;
      return;
    }
    if(need===0) addBtn('Check','btn-ghost', ()=>heroAct('check'));
    if(need>0)   addBtn(`Call ${Math.min(need,S.stacks[S.hero]).toFixed(1)} BB`,'btn-primary', ()=>heroAct('call'));

    const sizes=heroSizes();
    sizes.forEach(bb=>{
      if(S.street==='preflop'){
        addBtn(`Raise to ${bb.toFixed(1)} BB`,'btn-primary', ()=>heroAct(`raise_to:${bb}`));
      }else{
        const label = need>0? `Raise to ${bb} BB` : `Bet ${bb} BB`;
        addBtn(label,'btn-primary', ()=>heroAct(need>0?`raise_to:${bb}`:`bet:${bb}`));
      }
    });
    addBtn('All-in','btn-danger', ()=>heroAct('allin'));
  }

  /***********************
   * Villain action (pre/post)
   ***********************/
  async function vPre(seat){
    if(S.folded[seat]) return;
    setActing(seat,true); await sleep(450 + Math.floor(rnd()*550));
    const need=toCall(seat);
    const pol=policy('preflop',seat);

    if(pol==='fold' && need>0 && rnd()<0.8){
      S.folded[seat]=true; setFolded(seat); setActing(seat,false); return;
    }
    if((pol==='raise' || pol==='raise' || pol==='call') && rnd()<0.08 && need>0 && S.stacks[seat]<need){
      // short-stack call all-in
      const paid=payTo(seat, S.committed[seat]+S.stacks[seat]);
      putPlate(seat, `Call all-in`); S.interacted.add(seat); setActing(seat,false); return 'jam';
    }
    if((pol==='raise') || ((pfStrength(S.hands[seat])>90) && rnd()<0.55)){
      // size = max(currentTo + lastRaise, 2.2x open)
      const minRaise = S.lastRaise || 1.0;
      let to = Math.max(S.currentTo + minRaise, S.currentTo? S.currentTo + 2 : 2.5);
      to = Math.min(S.committed[seat] + S.stacks[seat], +to.toFixed(1));
      const add = Math.max(0, to - S.currentTo);
      S.lastRaise = Math.max(minRaise, add);
      S.currentTo = to; payTo(seat, S.currentTo);
      putPlate(seat, add>=S.stacks[seat]+S.committed[seat] ? 'All-in' : `Raise +${add.toFixed(1)} BB`);
      S.interacted.add(seat); setActing(seat,false); return;
    }
    if(need>0){
      const paid=payTo(seat, S.currentTo);
      putPlate(seat, paid>=S.stacks[seat]+paid ? 'Call all-in' : `Call ${paid.toFixed(1)} BB`);
      if(paid>0) S.interacted.add(seat);
    } else {
      putPlate(seat,'Check');
    }
    setActing(seat,false);
  }

  async function vPost(seat){
    if(S.folded[seat]) return;
    setActing(seat,true); await sleep(450 + Math.floor(rnd()*550));
    const need=toCall(seat);
    const pol=policy(S.street,seat);

    // Raise over bet sometimes
    if(need>0 && (pol.startsWith('bet') && rnd()<0.25) && S.stacks[seat]>need){
      const raiseTo = Math.min(S.committed[seat]+S.stacks[seat], S.currentTo + Math.max(2, Math.round(S.pot*0.45)));
      const add = raiseTo - S.currentTo;
      S.lastRaise = add; S.currentTo=raiseTo; payTo(seat, S.currentTo);
      putPlate(seat, add>=S.stacks[seat]+S.committed[seat] ? 'All-in' : `Raise +${add.toFixed(1)} BB`);
      S.interacted.add(seat); setActing(seat,false); return;
    }

    if(need>0){
      // call or fold
      if(rnd()<0.78 || S.stacks[seat]<=need){
        const paid=payTo(seat,S.currentTo);
        putPlate(seat, paid>=S.stacks[seat]+paid ? 'Call all-in' : `Call ${paid.toFixed(1)} BB`);
        if(paid>0) S.interacted.add(seat);
      } else {
        S.folded[seat]=true; setFolded(seat); putPlate(seat,'Fold');
      }
      setActing(seat,false); return;
    }

    // lead a bet sometimes when unchecked
    if(pol.startsWith('bet') && rnd()<0.36 && S.stacks[seat]>0){
      const pot=Math.max(2,S.pot);
      const add = pol==='bet_big' ? Math.round(pot*0.66) : pol==='bet_med' ? Math.round(pot*0.5) : Math.round(pot*0.33);
      const to  = Math.min(S.committed[seat]+S.stacks[seat], S.currentTo + add);
      S.lastRaise = to - S.currentTo; S.currentTo = to; payTo(seat, S.currentTo);
      putPlate(seat, to>=S.committed[seat]+S.stacks[seat] ? 'All-in' : `Bet ${Math.max(1,(to - S.committed[seat])).toFixed(1)} BB`);
      S.interacted.add(seat);
    } else {
      putPlate(seat,'Check');
    }
    setActing(seat,false);
  }

  /***********************
   * Streets & progression
   ***********************/
  function streetFirstActor(){
    if(S.street==='preflop'){
      // UTG first (left of BB)
      const iBB = S.seats.indexOf('BB');
      return S.seats[(iBB+1)%S.seats.length];
    }
    // Postflop: first left of BTN among active players (SB normally)
    const iBTN=S.seats.indexOf('BTN');
    for(let k=1;k<=S.seats.length;k++){
      const p=S.seats[(iBTN+k)%S.seats.length];
      if(!S.folded[p]) return p;
    }
    return S.hero;
  }

  function seatOrderFrom(seat){
    const i=S.seats.indexOf(seat); const out=[];
    for(let k=0;k<S.seats.length;k++){ out.push(S.seats[(i+k)%S.seats.length]); }
    return out.filter(p=>!S.folded[p]);
  }

  async function villainsToHero(){
    // villains act until hero turn encountered
    const order = seatOrderFrom(streetFirstActor());
    for(const p of order){
      if(p===S.hero) break;
      if(S.street==='preflop') { const r=await vPre(p); if(r==='jam') return; }
      else { const r=await vPost(p); if(r==='jam') return; }
    }
    // gate
    offerHero();
    promptEl.textContent = `${S.street.toUpperCase()}: Your action as ${S.hero}.`;
  }

  async function afterHeroContinue(){
    // everyone else finish the round
    const order = seatOrderFrom(S.hero).slice(1); // after hero
    for(const p of order){
      if(S.street==='preflop') { const r=await vPre(p); if(r==='jam') break; }
      else { const r=await vPost(p); if(r==='jam') break; }
    }
    if(!everyoneMatched()){ offerHero(); return; } // reopen hero if raises occurred after him

    // Street completed — move next or finish based on playThrough
    if(S.playThrough==='preflop' && S.street==='preflop') return finish();
    if(S.street==='preflop'){ await dealFlop(); return villainsToHero(); }
    if(S.playThrough==='turn' && S.street==='turn') return finish();
    if(S.street==='flop'){ await dealTurn(); return villainsToHero(); }
    if(S.street==='turn'){ await dealRiver(); return villainsToHero(); }
    if(S.street==='river') return finish();
  }

  async function dealFlop(){
    S.street='flop';
    const taken=new Set(Object.values(S.hands).flat().concat(S.board));
    S.board = dealUnique(3, taken);
    initStreet(); renderBoard(); updateHUD(); await sleep(350);
  }
  async function dealTurn(){
    S.street='turn';
    const taken=new Set(Object.values(S.hands).flat().concat(S.board));
    S.board.push(...dealUnique(1, taken));
    initStreet(); renderBoard(); updateHUD(); await sleep(350);
  }
  async function dealRiver(){
    S.street='river';
    const taken=new Set(Object.values(S.hands).flat().concat(S.board));
    S.board.push(...dealUnique(1, taken));
    initStreet(); renderBoard(); updateHUD(); await sleep(350);
  }

  /***********************
   * Hero acts (gate)
   ***********************/
  async function heroAct(action){
    // scoring
    const opt = (function(){
      const pol = policy(S.street, S.hero);
      if(S.street==='preflop' && pol==='call' && toCall(S.hero)===0) return 'check';
      if(pol==='bet_small'||pol==='bet_med'||pol==='bet_big') return pol;
      if(pol==='raise') return 'raise';
      return pol;
    })();
    S.ev = (S.ev||0) + evPenalty(S.street, action.startsWith('bet')||action.startsWith('raise_to') ? (action.includes('bet')?action:(toCall(S.hero)>0?'raise':'bet_med')) : action, opt);

    // execute
    if(action==='fold'){
      S.folded[S.hero]=true; setFolded(S.hero); putPlate(S.hero,'Fold');
      return finish(); // hand ends on hero fold
    }
    if(action==='check'){
      putPlate(S.hero,'Check');
    }
    if(action==='call'){
      const need=toCall(S.hero); const paid=payTo(S.hero,S.currentTo);
      putPlate(S.hero, paid>=S.stacks[S.hero]+paid ? 'Call all-in' : `Call ${Math.min(need,paid).toFixed(1)} BB`);
    }
    if(action.startsWith('bet:') || action.startsWith('raise_to:')){
      let to=parseFloat(action.split(':')[1]);
      if(action.startsWith('bet:')){ // open postflop bet sets currentTo
        const myTo = Math.max(S.currentTo, S.committed[S.hero]+to);
        S.lastRaise = myTo - S.currentTo; S.currentTo=myTo;
      }else{ // raise_to
        const minRaise = S.lastRaise||1;
        if(to < S.currentTo + minRaise) to = S.currentTo + minRaise;
        to = Math.min(S.committed[S.hero]+S.stacks[S.hero], +to.toFixed(1));
        S.lastRaise = to - S.currentTo;
        S.currentTo = to;
      }
      payTo(S.hero,S.currentTo);
      const add = S.currentTo - S.committed[S.hero] + (S.committed[S.hero]-S.committed[S.hero]); // label below:
      const facing = toCall(S.hero)>0;
      putPlate(S.hero, facing ? `Raise` : `Bet ${Math.max(1,(S.currentTo - (S.committed[S.hero]- (S.currentTo - S.lastRaise)))).toFixed(1)} BB`);
      S.interacted.add(S.hero);
    }
    if(action==='allin'){
      const to = S.committed[S.hero]+S.stacks[S.hero];
      S.lastRaise = Math.max(S.lastRaise, to - S.currentTo);
      S.currentTo = Math.max(S.currentTo, to);
      payTo(S.hero,S.currentTo);
      putPlate(S.hero,'All-in'); S.interacted.add(S.hero);
    }

    // After hero acts, others complete the round (or reopen hero if raised)
    return afterHeroContinue();
  }

  /***********************
   * Showdown / scoring / result
   ***********************/
  function showdownReveal(){
    // reveal hero + villains who interacted and haven't folded
    revealSeat(S.hero);
    S.seats.forEach(p=>{
      if(p!==S.hero && !S.folded[p] && S.interacted.has(p)) revealSeat(p);
    });
  }
  function revealSeat(p){
    const node=S.nodes[p]; if(!node) return;
    const holder=document.createElement('div');
    holder.className='cards';
    holder.style.left=node.seat.style.left;
    holder.style.top=node.seat.style.top;
    S.hands[p].forEach(c=> holder.appendChild(cardEl(c,false)));
    tableEl.appendChild(holder);
  }

  function computeScore(){
    // Junk preflop fold max credit handled in evPenalty (0 added)
    const ev=S.ev||0;
    const pct = Math.max(0, Math.min(100, Math.round(100 - ev*25)));
    return pct;
  }
  function finish(){
    clearActions();
    showdownReveal();
    const pct = computeScore();
    scorePctEl.textContent = `${pct}%`;
    scorePctEl.classList.toggle('good', pct>=50);
    scorePctEl.classList.toggle('bad', pct<50);
    scoreVerdEl.textContent = verdict(pct);
    resultPanel.style.display='block';

    // log
    const row=document.createElement('div'); row.className='log-item';
    row.innerHTML = `<div><b>${S.hero}</b> • ${S.players} • ${S.playThrough.toUpperCase()}</div>
                     <div class="score ${pct>=50?'good':'bad'}">${pct}% ${pct>=50?'✅':'❌'}</div>`;
    logList.prepend(row);

    // snapshot for replay
    S.snapshot = {
      seed:_seed, players:S.players, seats:[...S.seats], hero:S.hero,
      start:S.startStreet, through:S.playThrough
    };
  }

  /***********************
   * New hand
   ***********************/
  async function newHand(){
    // reset visuals
    resultPanel.style.display='none';
    scorePctEl.textContent='—%'; scoreVerdEl.textContent='';
    floatLayer.innerHTML=''; clearBoard(); document.querySelectorAll('.cards').forEach(n=>n.remove());
    for(const p of S.seats){ const n=S.nodes[p]; if(n){ n.seat.classList.remove('folded','acting'); n.seat.textContent=n.label; n.stack.style.opacity=1; } }
    S.ev=0; S.interacted=new Set();

    // params
    S.players = playersSel.value;
    S.seats = TEMPLATES[S.players].slice();
    layoutSeats();

    // hero
    if(!S.seats.includes(heroSel.value)) heroSel.value='BTN';
    S.hero = heroSel.value||'BTN'; setHeroHighlight();

    S.playThrough = rangeSel.value;
    S.startStreet = startSel.value;

    // stacks/hands
    S.stacks={}; S.folded={}; S.allin={}; S.hands={}; S.board=[]; S.pot=0; S.currentTo=0; S.lastRaise=1;
    S.seats.forEach(p=>{ S.stacks[p]=100; S.folded[p]=false; S.allin[p]=false; });
    const taken=new Set(); S.seats.forEach(p=> S.hands[p]=dealUnique(2, taken));
    heroCards(); renderBoard(); updateStacksUI();

    // streets
    S.street = S.startStreet;
    if(S.startStreet==='flop'){ S.board=dealUnique(3, taken); }
    if(S.startStreet==='turn'){ S.board=[...dealUnique(3,taken), ...dealUnique(1,taken)]; }
    if(S.startStreet==='river'){ S.board=[...dealUnique(3,taken), ...dealUnique(2,taken)]; }
    renderBoard();

    // init betting stage + villains to hero
    initStreet();
    promptEl.textContent = 'Shuffling …'; await sleep(250);
    await villainsToHero();
  }

  /***********************
   * Wiring
   ***********************/
  playersSel.onchange = ()=>{ // rebuild hero list
    const seats=TEMPLATES[playersSel.value]; heroSel.innerHTML=seats.map(s=>`<option>${s}</option>`).join('');
    if(!seats.includes(heroSel.value)) heroSel.value='BTN';
  };
  heroSel.onchange = ()=> setHeroHighlight();
  newBtn.onclick = ()=> newHand();
  nextBtn.onclick = ()=> newHand();
  replayBtn.onclick = ()=> S.snapshot && (srand(S.snapshot.seed), newHand());
  clearLogBtn.onclick = ()=>{ logList.innerHTML=''; };

  // Build hero list first time
  (function boot(){
    const seats=TEMPLATES[playersSel.value]; heroSel.innerHTML=seats.map(s=>`<option>${s}</option>`).join('');
    heroSel.value='BTN';
    srand(Date.now()^0x9e3779b9);
    newHand(); // auto-start first hand
  })();
  </script>
</body>
</html>















