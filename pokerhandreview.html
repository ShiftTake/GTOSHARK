<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>GTO Shark AI Solver</title>
    <!-- Tailwind for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Dark, professional solver aesthetic */
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --muted-border: #30363d;
            --card-face: #f7f7f7;
            --card-text: #1a202c;
            --accent: #2e8b57;
            --accent-2: #3cb371;
            --danger: #dc2626;
        }
        html, body {
            height: 100%;
            margin: 0;
        }
        body {
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            background-color: var(--bg);
            color: #e5e7eb;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 2rem;
        }

        .container {
            max-width: 1100px;
            width: 100%;
        }

        .card-panel {
            background-color: var(--panel);
            border: 1px solid var(--muted-border);
            box-shadow: 0 10px 15px rgba(0,0,0,0.35);
            transition: all 0.25s ease;
        }

        /* Grid for card pickers: responsive and flows nicely */
        .card-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(56px, 1fr));
            gap: 8px;
            align-items: stretch;
        }

        /* Poker card core styles */
        .poker-card {
            background: var(--card-face);
            color: var(--card-text);
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            border: 1px solid #888;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            aspect-ratio: 2 / 3;
            user-select: none;
            transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
            overflow: hidden;
        }

        /* Hover and active states */
        .poker-card:hover:not(.selected):not(.disabled) {
            transform: translateY(-4px) scale(1.03);
            box-shadow: 0 8px 18px rgba(0,0,0,0.45);
            border-color: #aaa;
        }
        .poker-card:active:not(.disabled) {
            transform: translateY(0) scale(0.99);
        }

        /* Selected & disabled */
        .poker-card.selected {
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
            transform: scale(1.02);
            border-color: var(--accent);
        }
        .poker-card.selected.red-suit {
            border-color: var(--danger);
            box-shadow: 0 6px 20px rgba(220,38,38,0.2);
        }
        .poker-card.disabled {
            opacity: 0.24;
            filter: grayscale(70%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Rank small corner labels */
        .rank-top, .rank-bottom {
            position: absolute;
            font-weight: 700;
            font-size: 0.78rem;
            line-height: 1;
            color: inherit;
            pointer-events: none;
        }
        .rank-top {
            top: 6px;
            left: 8px;
        }
        .rank-bottom {
            bottom: 6px;
            right: 8px;
            transform: rotate(180deg);
        }

        /* Large central suit symbol: centered and visually dominant */
        .suit-center {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 54px; /* much larger central symbol */
            line-height: 1;
            margin: 0;
            pointer-events: none;
            transform: translateY(-4px); /* visually balance vertically */
        }

        /* Suit color classes */
        .suit-black { color: #0f1723; } /* dark near-black */
        .suit-red { color: var(--danger); }

        /* Ensure selected cards' suit color becomes white for contrast */
        .poker-card.selected .suit-center,
        .poker-card.selected .rank-top,
        .poker-card.selected .rank-bottom {
            color: #fff !important;
        }

        /* Buttons */
        .button-primary {
            background-color: var(--accent);
            color: white;
            transition: background-color 150ms ease;
        }
        .button-primary:hover:not(:disabled) {
            background-color: var(--accent-2);
        }
        .loading-ring {
            border: 4px solid rgba(255,255,255,0.18);
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }
        @keyframes spin { 0%{ transform: rotate(0deg)} 100%{ transform: rotate(360deg)} }

        /* Input grid */
        .input-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 1rem;
        }

        @media (max-width: 880px) {
            .input-grid { grid-template-columns: 1fr; }
            .suit-center { font-size: 42px; }
        }
        @media (max-width: 480px) {
            .suit-center { font-size: 36px; }
            .rank-top, .rank-bottom { font-size: 0.64rem; }
        }

        /* LLM content visual styles */
        .gto-block {
            background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
            border-radius: 12px;
            padding: 14px;
            border-left: 4px solid var(--accent);
        }
        .exploit-block {
            border-left-color: #ef4444;
        }
        .keyconcept-block {
            border-left-color: #60a5fa;
        }

        .llm-heading {
            font-weight: 700;
            color: #cbd5e1;
            display: block;
            margin-top: 0.25rem;
            margin-bottom: 8px;
        }

        .small-muted {
            color: #9ca3af;
            font-size: 0.92rem;
        }

        /* Error message */
        .error-message {
            background-color: #3f0f0f;
            color: #fecaca;
            border: 1px solid #7f1d1d;
            padding: 10px;
            border-radius: 8px;
        }

        /* Inline pill for action */
        .action-pill {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 999px;
            font-weight: 700;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.04);
        }

        /* Small monospace block for numbers or code fragments */
        .inline-code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
            background: rgba(255,255,255,0.02);
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 0.92rem;
        }
    </style>
</head>
<body>
<div class="container">
    <header class="text-center mb-8">
        <h1 class="text-4xl font-extrabold" style="color: var(--accent);">GTO Shark AI Solver</h1>
        <p class="text-gray-400 mt-2">Mathematically Verified Analysis from 100 Million Simulated Scenarios.</p>
    </header>

    <!-- Scenario Input Form -->
    <div id="input-section" class="card-panel p-6 rounded-xl mb-8">
        <h2 class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2">Set Up Scenario</h2>

        <form id="solver-form" class="space-y-4">
            <div class="input-grid">
                <div>
                    <label for="format" class="block text-sm font-medium text-gray-300">Format & Stacks</label>
                    <select id="format" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-white p-2 focus:ring-[#2e8b57] focus:border-[#2e8b57]">
                        <optgroup label="No-Limit Hold'em Cash">
                            <option value="NLHE_6_MAX_100BB">NLHE 6-Max (100BB)</option>
                            <option value="NLHE_7_MAX_100BB">NLHE 7-Max (100BB)</option>
                            <option value="NLHE_8_MAX_100BB">NLHE 8-Max (100BB)</option>
                            <option value="NLHE_9_MAX_100BB">NLHE 9-Max (100BB)</option>
                            <option value="NLHE_10_MAX_100BB">NLHE 10-Max (100BB)</option>
                        </optgroup>
                        <optgroup label="Pot-Limit Omaha Cash">
                            <option value="PLO_4_6_MAX_100BB">PLO 4-Card 6-Max (100BB)</option>
                            <option value="PLO_4_9_MAX_100BB">PLO 4-Card 9-Max (100BB)</option>
                            <option value="PLO_5_6_MAX_100BB">PLO 5-Card 6-Max (100BB)</option>
                            <option value="PLO_6_6_MAX_100BB">PLO 6-Card 6-Max (100BB)</option>
                        </optgroup>
                        <optgroup label="Tournament Formats (NLHE)">
                            <option value="MTT_40BB_ICM">NLHE MTT (40BB ICM)</option>
                            <option value="SNG_25BB">NLHE Spin & Go (25BB)</option>
                        </optgroup>
                    </select>
                </div>
                <div>
                    <label for="street" class="block text-sm font-medium text-gray-300">Current Street</label>
                    <select id="street" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-white p-2 focus:ring-[#2e8b57] focus:border-[#2e8e57]">
                        <option value="PREFLOP">Preflop</option>
                        <option value="FLOP" selected>Flop</option>
                        <option value="TURN">Turn</option>
                        <option value="RIVER">River</option>
                    </select>
                </div>
            </div>

            <div class="input-grid">
                <div>
                    <label for="hero-stack" class="block text-sm font-medium text-gray-300">Your Stack (BB)</label>
                    <input type="number" id="hero-stack" value="100" min="5" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-white p-2 focus:ring-[#2e8b57] focus:border-[#2e8b57]" required>
                </div>
                <div>
                    <label for="opponent-stack" class="block text-sm font-medium text-gray-300">Opponent Stack (BB)</label>
                    <input type="number" id="opponent-stack" value="100" min="5" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-white p-2 focus:ring-[#2e8b57] focus:border-[#2e8b57]" required>
                </div>
            </div>

            <div class="input-grid">
                <div>
                    <label for="pot-size" class="block text-sm font-medium text-gray-300">Current Pot Size (BB)</label>
                    <input type="number" id="pot-size" value="20" min="1" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-white p-2 focus:ring-[#2e8b57] focus:border-[#2e8b57]" required>
                </div>
                <div>
                    <label for="bet-size" class="block text-sm font-medium text-gray-300">Villain Bet Size (% Pot)</label>
                    <input type="number" id="bet-size" value="50" min="1" max="300" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-white p-2 focus:ring-[#2e8b57] focus:border-[#2e8b57]" required>
                </div>
            </div>

            <input type="hidden" id="hero-hand-input" value="">
            <input type="hidden" id="board-cards-input" value="">

            <div class="space-y-6 pt-4">
                <div id="card-message-box" class="hidden p-3 rounded-lg text-sm font-semibold transition-opacity duration-300" role="alert"></div>

                <div class="border-t border-gray-700 pt-4">
                    <label class="block text-sm font-medium text-gray-300 mb-2">Your Hand (Selected: <span id="hero-hand-display" class="font-mono text-[#2e8b57]">9s Ts</span>)</label>
                    <div id="hero-hand-picker" class="card-panel p-3 rounded-lg">
                        <!-- Hero picker rendered here -->
                    </div>
                </div>

                <div id="board-selection-area" class="border-t border-gray-700 pt-4">
                    <label class="block text-sm font-medium text-gray-300 mb-2">Board Cards (Selected: <span id="board-cards-display" class="font-mono text-[#2e8b57]">Js 8h 3d</span>)</label>
                    <p id="board-required-count" class="text-xs text-gray-500 mb-3"></p>
                    <div id="board-cards-picker" class="card-panel p-3 rounded-lg">
                        <!-- Board picker rendered here -->
                    </div>
                </div>
            </div>

            <button type="submit" id="analyze-button" class="w-full py-3 rounded-md font-bold button-primary flex items-center justify-center disabled:opacity-50">
                <span id="button-text">Submit Spot for Analysis</span>
                <div id="loading-spinner" class="loading-ring ml-3 hidden"></div>
            </button>
        </form>
    </div>

    <!-- Analysis Output -->
    <div id="analysis-output" class="hidden">
        <div id="analysis-title" class="text-3xl font-bold text-white mb-6 p-4 rounded-lg bg-gray-800 border-l-4 border-[#2e8b57]">
            GTO Shark AI Analysis: Flop Defense
        </div>

        <!-- A. GTO Line -->
        <div class="card-panel p-5 rounded-xl mb-6">
            <h3 class="text-xl font-bold text-[#2e8b57] mb-3">A. ðŸ§  The GTO Line (Pure Balance)</h3>
            <div id="gto-action" class="mb-3 text-lg font-mono gto-block" style="font-size:1.05rem"></div>
            <p id="gto-rationale" class="mb-2 small-muted"></p>
            <p id="gto-context" class="text-sm italic text-gray-400"></p>
        </div>

        <!-- B. Exploitative Adjustment -->
        <div class="card-panel p-5 rounded-xl mb-6">
            <h3 class="text-xl font-bold text-red-400 mb-3">B. ðŸ”¨ The Exploitative Adjustment</h3>
            <div id="exploitative-output" class="gto-block exploit-block">
                <div id="exploitative-profile" class="llm-heading"></div>
                <div id="exploitative-action" class="action-pill mb-3"></div>
                <div id="exploitative-rationale" class="small-muted"></div>
            </div>
        </div>

        <!-- C. Key Concept Translation -->
        <div class="card-panel p-5 rounded-xl mb-6">
            <h3 class="text-xl font-bold text-blue-400 mb-3">C. ðŸ”‘ Key Concept Translation</h3>
            <div id="key-concept-output" class="gto-block keyconcept-block">
                <div id="key-concept-title" class="text-lg font-semibold mb-2"></div>
                <div id="key-concept-text" class="small-muted"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // ------------------------------
    // Global constants and state
    // ------------------------------
    const RANKS = ['A','K','Q','J','T','9','8','7','6','5','4','3','2'];
    const SUITS = ['s','h','d','c']; // s = spades, h = hearts, d = diamonds, c = clubs

    // **IMPORTANT**: Use the API key you provided
    const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025";
    const apiKey = "AIzaSyBZh4GD0KX691kfF3eU45a71o1IHf5iL4U";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;

    // Build 52-card array (rank + suit)
    let allCards = [];
    SUITS.forEach(suit => RANKS.forEach(rank => allCards.push(rank + suit)));

    // Default selections
    let selectedHeroCards = ['9s','Ts'];
    let selectedBoardCards = ['Js','8h','3d'];

    // DOM refs
    const form = document.getElementById('solver-form');
    const analyzeButton = document.getElementById('analyze-button');
    const buttonText = document.getElementById('button-text');
    const loadingSpinner = document.getElementById('loading-spinner');
    const outputSection = document.getElementById('analysis-output');
    const formatSelect = document.getElementById('format');
    const streetSelect = document.getElementById('street');
    const boardSelectionArea = document.getElementById('board-selection-area');
    const boardRequiredCount = document.getElementById('board-required-count');
    const heroHandDisplay = document.getElementById('hero-hand-display');
    const boardCardsDisplay = document.getElementById('board-cards-display');
    const cardMessageBox = document.getElementById('card-message-box');

    // ------------------------------
    // Utilities: suit mapping, element creation
    // ------------------------------
    function getSuitInfo(suitCode) {
        switch(suitCode) {
            case 's': return { symbol: 'â™ ', colorClass: 'suit-black' };
            case 'h': return { symbol: 'â™¥', colorClass: 'suit-red' };
            case 'd': return { symbol: 'â™¦', colorClass: 'suit-red' };
            case 'c': return { symbol: 'â™£', colorClass: 'suit-black' };
            default: return { symbol: '?', colorClass: '' };
        }
    }

    function createCardElement(card) {
        const rank = card.substring(0, card.length - 1);
        const suitCode = card.slice(-1);
        const suitInfo = getSuitInfo(suitCode);

        const cardDiv = document.createElement('div');
        cardDiv.className = 'poker-card';
        cardDiv.dataset.card = card;

        // Add red-suit class for selected red coloration
        if (suitCode === 'h' || suitCode === 'd') cardDiv.classList.add('red-suit');

        // inner HTML â€“ small ranks in corners and massively larger suit center
        cardDiv.innerHTML = `
            <span class="rank-top ${suitInfo.colorClass}">${rank}</span>
            <div class="suit-center ${suitInfo.colorClass}">${suitInfo.symbol}</div>
            <span class="rank-bottom ${suitInfo.colorClass}">${rank}</span>
        `;
        return cardDiv;
    }

    // ------------------------------
    // Card Picker rendering
    // ------------------------------
    function renderCardPicker(containerId, currentSelectedCards, isHeroHand) {
        const container = document.getElementById(containerId);
        container.innerHTML = ''; // clear

        const cardGrid = document.createElement('div');
        cardGrid.className = 'card-container';
        container.appendChild(cardGrid);

        allCards.forEach(card => {
            const el = createCardElement(card);
            const isHeroSelected = selectedHeroCards.includes(card);
            const isBoardSelected = selectedBoardCards.includes(card);

            const isDisabled = (isHeroHand && isBoardSelected) || (!isHeroHand && isHeroSelected);

            if (currentSelectedCards.includes(card)) el.classList.add('selected');
            if (isDisabled) el.classList.add('disabled');

            el.addEventListener('click', () => handleCardClick(card, isHeroHand, el));
            cardGrid.appendChild(el);
        });
    }

    // transient error display above pickers
    function showCardError(message) {
        cardMessageBox.textContent = message;
        cardMessageBox.classList.remove('hidden');
        cardMessageBox.classList.add('error-message');

        clearTimeout(window.cardErrorTimeout);
        window.cardErrorTimeout = setTimeout(() => {
            cardMessageBox.classList.add('hidden');
        }, 4500);
    }

    // click handler
    function handleCardClick(card, isHeroHand, cardEl) {
        if (cardEl.classList.contains('disabled')) return;
        let selectedArray = isHeroHand ? selectedHeroCards : selectedBoardCards;
        let maxCount = isHeroHand ? getMaxHeroCards() : getMaxBoardCards();
        const slotName = isHeroHand ? 'Hero Hand' : 'Board Cards';
        const streetOrFormat = isHeroHand ? formatSelect.options[formatSelect.selectedIndex].text : streetSelect.options[streetSelect.selectedIndex].text;

        const index = selectedArray.indexOf(card);

        if (index > -1) {
            selectedArray.splice(index, 1);
        } else {
            if (selectedArray.length < maxCount) {
                selectedArray.push(card);
            } else {
                const msg = `Cannot select card. Maximum limit reached for ${slotName} (${maxCount} for ${streetOrFormat}). Deselect an existing card first.`;
                console.error(msg);
                showCardError(msg);
                return;
            }
        }

        updateHiddenInputs();
        updateDisplayCards();
        renderPickers();
        checkFormValidity();
    }

    function renderPickers() {
        renderCardPicker('hero-hand-picker', selectedHeroCards, true);
        renderCardPicker('board-cards-picker', selectedBoardCards, false);
    }

    // ------------------------------
    // Card & form helpers
    // ------------------------------
    function getMaxHeroCards() {
        const format = formatSelect.value;
        if (format.startsWith('NLHE') || format.startsWith('MTT') || format.startsWith('SNG')) return 2;
        if (format.includes('_4_')) return 4;
        if (format.includes('_5_')) return 5;
        if (format.includes('_6_')) return 6;
        return 2;
    }
    function getMaxBoardCards() {
        switch(streetSelect.value) {
            case 'FLOP': return 3;
            case 'TURN': return 4;
            case 'RIVER': return 5;
            default: return 0;
        }
    }
    function updateHiddenInputs() {
        document.getElementById('hero-hand-input').value = selectedHeroCards.join(' ');
        document.getElementById('board-cards-input').value = selectedBoardCards.join(' ');
    }
    function updateDisplayCards() {
        heroHandDisplay.textContent = selectedHeroCards.length ? selectedHeroCards.join(' ') : 'None';
        boardCardsDisplay.textContent = selectedBoardCards.length ? selectedBoardCards.join(' ') : 'None';
    }

    function checkFormValidity() {
        const requiredInputsValid = Array.from(document.querySelectorAll('#solver-form input[required], #solver-form select')).every(input => {
            const val = (input.value || '').toString().trim();
            if (val === '') return false;
            if (input.type === 'number') return parseFloat(val) > 0;
            return true;
        });

        const maxHero = getMaxHeroCards();
        const maxBoard = getMaxBoardCards();
        const heroCountValid = selectedHeroCards.length === maxHero;
        const boardCountValid = (streetSelect.value === 'PREFLOP') ? true : selectedBoardCards.length === maxBoard;

        boardRequiredCount.textContent = (streetSelect.value === 'PREFLOP') ? 'Board hidden for preflop' : `Select exactly ${maxBoard} cards for the ${streetSelect.value} board.`;

        let allValid = requiredInputsValid && heroCountValid && boardCountValid;
        analyzeButton.disabled = !allValid;
        return allValid;
    }

    // ------------------------------
    // Initialize pickers and listeners
    // ------------------------------
    (function initialize() {
        renderPickers();
        updateHiddenInputs();
        updateDisplayCards();
        boardSelectionArea.classList.toggle('hidden', streetSelect.value === 'PREFLOP');
        formatSelect.dispatchEvent(new Event('change'));
        checkFormValidity();
    })();

    streetSelect.addEventListener('change', () => {
        const street = streetSelect.value;
        boardSelectionArea.classList.toggle('hidden', street === 'PREFLOP');

        const max = getMaxBoardCards();
        if (street === 'PREFLOP') {
            selectedBoardCards = [];
        } else if (selectedBoardCards.length > max) {
            selectedBoardCards = selectedBoardCards.slice(0, max);
        }

        updateHiddenInputs();
        updateDisplayCards();
        renderPickers();
        checkFormValidity();
    });

    formatSelect.addEventListener('change', () => {
        const maxHero = getMaxHeroCards();
        if (selectedHeroCards.length > maxHero) selectedHeroCards = selectedHeroCards.slice(0, maxHero);
        updateHiddenInputs();
        updateDisplayCards();
        renderPickers();
        checkFormValidity();
    });

    document.querySelectorAll('#solver-form input, #solver-form select').forEach(el => el.addEventListener('input', checkFormValidity));

    // ------------------------------
    // Simple hand classifier (NLHE) - kept as fallback
    // ------------------------------
    function classifyHeroHand(heroCards, boardCards) {
        if (!heroCards || heroCards.length < 2 || !boardCards || boardCards.length < 3) return 'WEAK_AIR';

        const all = heroCards.concat(boardCards);
        const ranks = all.map(c => c[0]);
        const suits = all.map(c => c[c.length - 1]);

        function rankToValue(r) {
            if (r === 'A') return 14;
            if (r === 'K') return 13;
            if (r === 'Q') return 12;
            if (r === 'J') return 11;
            if (r === 'T') return 10;
            return parseInt(r, 10);
        }

        const heroSuits = heroCards.map(c => c[c.length - 1]);
        const suitCounts = {};
        suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
        for (const s in suitCounts) {
            if (suitCounts[s] >= 5 && heroSuits.includes(s)) return 'STRONG_MADE';
            if (suitCounts[s] >= 4 && heroSuits.includes(s)) return 'MEDIUM_DRAW';
        }

        const rankCounts = {};
        ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);

        let pairCount = 0;
        let isTopPair = false;
        const boardRankValues = boardCards.map(c => rankToValue(c[0])).sort((a,b) => b-a);

        for (const r of new Set(ranks)) {
            if (rankCounts[r] >= 2) {
                const heroHasRank = heroCards.some(c => c[0] === r);
                if (heroHasRank) {
                    pairCount++;
                    if (boardRankValues.length > 0 && rankToValue(r) === boardRankValues[0]) isTopPair = true;
                }
            }
        }

        if (pairCount >= 2) return 'STRONG_MADE';
        if (isTopPair) return 'MEDIUM_PAIR';
        if (pairCount === 1) return 'WEAK_PAIR';

        // Straight-draw-ish simplified
        const uniqueRanks = Array.from(new Set(ranks)).map(rankToValue).sort((a,b) => a-b);
        let hasDraw = false;
        for (let i=0;i<uniqueRanks.length-3;i++){
            if (uniqueRanks[i+3] - uniqueRanks[i] <= 4) hasDraw = true;
        }
        if (hasDraw) return 'MEDIUM_DRAW';

        return 'WEAK_AIR';
    }

    // ------------------------------
    // GTO database fallback (client-side)
    // ------------------------------
    const database = {
        'STRONG_MADE': {
            title: 'Flop Defense: Top Two Pair / Set / Flush',
            gto: {
                action: 'Raise 45%, Call 55%',
                rationale: 'With a premium made hand, GTO demands a mixed strategy to protect your entire range. Raising maximizes value against worse hands and denies equity, while calling keeps weaker hands and bluffs in the pot.'
            },
            llm_prompt_seed: {
                hand_strength: 'premium made hand (e.g., top two pair, set, or flush)',
                focus: 'Exploit a passive opponent (too sticky/calling too often) and explain Value Density and Range Protection.'
            }
        },
        'MEDIUM_PAIR': {
            title: 'Flop Defense: Top Pair Weak Kicker / Middle Pair',
            gto: {
                action: 'Call 90%, Raise 10%',
                rationale: 'Your hand has showdown value and is too strong to fold, but too weak to raise purely for value. Calling is the primary GTO action.'
            },
            llm_prompt_seed: {
                hand_strength: 'marginal made hand (e.g., top pair weak kicker or middle pair)',
                focus: 'Exploit an aggressive opponent (over-bluffing post-flop) and explain Pot Odds and Showdown Value (SDV).'
            }
        },
        'MEDIUM_DRAW': {
            title: 'Flop Defense: Strong Combo Draw (OESD/Flush)',
            gto: {
                action: 'Call 78%, Raise 22%',
                rationale: 'Your hand has sufficient equity to continue but is vulnerable. Calling realizes equity and keeps the pot small while raising provides balance.'
            },
            llm_prompt_seed: {
                hand_strength: 'strong drawing hand (e.g., straight/flush draw, or combo draw)',
                focus: 'Exploit a very tight opponent (folds too often) and explain Minimum Defense Frequency (MDF).'
            }
        },
        'WEAK_PAIR': {
            title: 'Flop Defense: Bottom Pair / Weak Pair',
            gto: {
                action: 'Fold 60%, Call 40%',
                rationale: 'This hand is borderline. GTO reserves a small calling frequency to prevent the opponent from over-bluffing.'
            },
            llm_prompt_seed: {
                hand_strength: 'marginal defending hand (e.g., bottom pair or weak pair)',
                focus: 'Exploit a passive opponent and explain Equity Realization (ER).'
            }
        },
        'WEAK_AIR': {
            title: 'Flop Defense: Pure Air / Weak Backdoor Draw',
            gto: {
                action: 'Fold 100%',
                rationale: 'This hand has insufficient equity and poor realization against the opponentâ€™s continuation range. Folding is the pure GTO play.'
            },
            llm_prompt_seed: {
                hand_strength: 'mandatory folding hand (e.g., pure air or weak backdoor draw)',
                focus: 'Exploit a very aggressive opponent and explain Blocking Bets and Range Construction.'
            }
        }
    };

    // ------------------------------
    // LLM call routine (Gemini API) with retry/backoff
    // ------------------------------
    async function callLLM(payload) {
        const MAX_RETRIES = 3;
        for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
            const delay = Math.pow(2, attempt) * 500; // 0.5s, 1s, 2s
            if (attempt > 0) await new Promise(r => setTimeout(r, delay));
            try {
                const resp = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                if (resp.ok) {
                    const json = await resp.json();
                    // Some Gemini-style responses include candidates.content.parts
                    const text = json?.candidates?.[0]?.content?.parts?.[0]?.text || json?.candidates?.[0]?.content?.text || null;
                    if (text) return text;
                    // Some other shapes
                    return JSON.stringify(json);
                } else if (resp.status === 429) {
                    console.warn('Rate-limited, retrying...');
                    continue;
                } else {
                    // attempt to parse error body
                    let errBody;
                    try { errBody = await resp.json(); } catch(e) { errBody = await resp.text(); }
                    throw new Error(`LLM API error ${resp.status}: ${JSON.stringify(errBody)}`);
                }
            } catch (err) {
                console.error('LLM attempt failed', err);
                if (attempt === MAX_RETRIES - 1) throw err;
            }
        }
        throw new Error('LLM failed after retries');
    }

    // ------------------------------
    // Convert light markdown-like content to safe-ish HTML for display:
    // - **bold** -> <strong>
    // - $...$ -> <code>...</code>
    // - newlines -> <br>
    // NOTE: This is intentionally small & conservative.
    // ------------------------------
    function simpleMarkupToHTML(text) {
        if (!text) return '';
        // Escape HTML first
        const escapeHtml = (s) => s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c]));
        let safe = escapeHtml(text);

        // Convert **bold** (non-greedy)
        safe = safe.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

        // Convert inline $...$ to code
        safe = safe.replace(/\$(.+?)\$/g, '<code class="inline-code">$1</code>');

        // Preserve paragraph breaks: double newlines -> <p>, single newline -> <br>
        safe = safe.replace(/\r\n/g, '\n');
        safe = safe.replace(/\n{2,}/g, '</p><p>');
        safe = safe.replace(/\n/g, '<br>');
        safe = '<p>' + safe + '</p>';
        return safe;
    }

    // ------------------------------
    // Parse LLM response markers for B and C (and A if desired)
    // Expected marker format the prompt requests:
    // **EXPLOITATIVE_PROFILE:** ...
    // **EXPLOITATIVE_ACTION:** ...
    // **EXPLOITATIVE_RATIONALE:** ...
    // ---
    // **KEY_CONCEPT_TITLE:** ...
    // **KEY_CONCEPT_TEXT:** ...
    // ------------------------------
    function processLLMResponse(llmText) {
        const markers = ['EXPLOITATIVE_PROFILE','EXPLOITATIVE_ACTION','EXPLOITATIVE_RATIONALE','KEY_CONCEPT_TITLE','KEY_CONCEPT_TEXT'];
        const data = {};
        let currentKey = null;
        const lines = llmText.split('\n');

        for (let rawLine of lines) {
            const line = rawLine.trim();
            if (!line) {
                if (currentKey) data[currentKey] += '\n';
                continue;
            }

            let matched = false;
            for (const marker of markers) {
                const markerTag = `**${marker}:**`;
                if (line.startsWith(markerTag)) {
                    currentKey = marker.toLowerCase().replace(/_(.)/g, (m,p)=>p.toUpperCase());
                    data[currentKey] = line.substring(markerTag.length).trim();
                    matched = true;
                    break;
                }
            }
            if (!matched && currentKey) {
                data[currentKey] = (data[currentKey] || '') + '\n' + line;
            }
        }
        return data;
    }

    // ------------------------------
    // API call wrapper to ask Gemini for Sections A, B, C
    // We'll first ask for a short structured GTO line (A) and then the exploit/key-concept (B & C).
    // If any API call fails, we fallback to the local `database`.
    // ------------------------------
    async function askLLMForSpotA(format, street, heroHandStr, boardCardsStr, heroStack, betSize, fallbackKey) {
        // Compose a short instruction to produce a concise GTO line and rationale.
        const prompt = `
Provide a compact GTO recommendation for the following poker spot. Output only two labeled markers exactly:

**GTO_ACTION:** [Short frequency style action, e.g., "Call 78%, Raise 22%"]
**GTO_RATIONALE:** [One short paragraph explaining why that mixed action is balanced for the hero's range given the spot]

Spot details:
Format: ${format.replace(/_/g,' ')}
Street: ${street}
Hero hole cards: ${heroHandStr}
Board cards: ${boardCardsStr}
Hero stack: ${heroStack} BB
Villain bet size: ${betSize}% pot

Use plain text, no extra commentary.
        `.trim();

        const systemInstruction = 'You are a world-class poker GTO engine that outputs only the markers requested. Do not include anything else outside the markers.';

        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            systemInstruction: { parts: [{ text: systemInstruction }] },
            // no tools to simplify request (your original code included google_search)
        };

        try {
            const respText = await callLLM(payload);
            // Try to parse GTO_ACTION and GTO_RATIONALE from the returned text
            const lines = respText.split('\n').map(l => l.trim()).filter(l => l.length);
            let gtoAction = null, gtoRationale = null;
            for (const l of lines) {
                if (l.startsWith('**GTO_ACTION:**')) gtoAction = l.substring('**GTO_ACTION:**'.length).trim();
                if (l.startsWith('**GTO_RATIONALE:**')) gtoRationale = l.substring('**GTO_RATIONALE:**'.length).trim();
            }
            // Sometimes models return without the exact markers; try a fallback parse
            if (!gtoAction || !gtoRationale) {
                // fallback: try to find "Call", "Raise", "Fold" patterns
                const joined = respText;
                const actionMatch = joined.match(/(Call\s*\d+%|Raise\s*\d+%|Fold\s*\d+%|Fold\s*100%|Call\s*\d+,\s*Raise\s*\d+%|[A-Za-z]+\s*\d+%)/i);
                if (!gtoAction && actionMatch) gtoAction = actionMatch[0];
                const rationaleMatch = joined.split(/\n/).slice(1).join(' ').trim();
                if (!gtoRationale && rationaleMatch) gtoRationale = rationaleMatch;
            }

            if (gtoAction && gtoRationale) {
                return { action: gtoAction, rationale: gtoRationale };
            }
            // If parsing fails, throw and fallback
            throw new Error('Could not parse LLM output for A.');
        } catch (err) {
            console.warn('LLM for A failed, using fallback DB. Error:', err.message);
            const fallback = database[fallbackKey] || database['MEDIUM_DRAW'];
            return { action: fallback.gto.action, rationale: fallback.gto.rationale };
        }
    }

    async function askLLMForBAndC(format, street, heroHandStr, boardCardsStr, heroStack, betSize, dbSeed) {
        // Constructs a long-form prompt asking for the exact markers structure
        const userQuery = `
Analyze a poker spot where the core GTO action is "${dbSeed.gto.action}" and the hero hand strength is "${dbSeed.llm_prompt_seed.hand_strength}".
Hero: ${heroHandStr}. Board: ${boardCardsStr}. Street: ${street}. Format: ${format.replace(/_/g,' ')}. Hero stack: ${heroStack} BB. Villain bet: ${betSize}% pot.

Task: ${dbSeed.llm_prompt_seed.focus}

Provide the response using the exact structure below, filling in the content. Do not include any text outside these markers.

**EXPLOITATIVE_PROFILE:** [Create a short profile of the exploitable villain]
**EXPLOITATIVE_ACTION:** [Recommend a single, pure action, e.g., 'Pure 100% Raise (Max Value)']
**EXPLOITATIVE_RATIONALE:** [Explain the 'why' behind the exploitative action in a single paragraph]
---
**KEY_CONCEPT_TITLE:** [Name the key poker concept]
**KEY_CONCEPT_TEXT:** [Explain the concept and how it relates to this hand/spot, referencing the scenario specifics (e.g., stack sizes, pot odds, ICM, etc.)]
        `.trim();

        const systemInstruction = 'You are a world-class poker GTO and exploitative analyst. Strictly follow the output markers above and nothing else.';

        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            systemInstruction: { parts: [{ text: systemInstruction }] },
        };

        try {
            const llmText = await callLLM(payload);
            const parsed = processLLMResponse(llmText);
            return parsed;
        } catch (err) {
            console.warn('LLM for B/C failed, using fallback DB:', err.message);
            // Use fallback db seed to generate simple B/C
            const fallback = {
                exploitativeProfile: `Opponent is a ${dbSeed.llm_prompt_seed.hand_strength} exploitable profile.`,
                exploitativeAction: `${dbSeed.gto.action.split(',')[0].trim()} (Adjusted)`,
                exploitativeRationale: dbSeed.gto.rationale + ' (Client-side fallback explanation.)',
                keyConceptTitle: 'Minimum Defense Frequency (Fallback)',
                keyConceptText: 'Fallback explanation using pot odds and MDF.'
            };
            return fallback;
        }
    }

    // ------------------------------
    // Main orchestration: runGTOAnalysis
    // ------------------------------
    async function runGTOAnalysis(format, potSize, heroStack, oppStack, street, heroHandStr, boardCardsStr, betSize) {
        const heroHand = heroHandStr.split(' ').filter(Boolean);
        const board = boardCardsStr.split(' ').filter(Boolean);

        // Decide analysis key
        let analysisKey;
        if (street === 'PREFLOP') {
            analysisKey = 'MEDIUM_DRAW';
        } else {
            analysisKey = classifyHeroHand(heroHand, board);
        }
        const dbSeed = database[analysisKey] || database['MEDIUM_DRAW'];

        // 1) Ask LLM for A (GTO_ACTION and GTO_RATIONALE). Use DB fallback if API doesn't return.
        const aAnswer = await askLLMForSpotA(format, street, heroHandStr, boardCardsStr, heroStack, betSize, analysisKey);
        document.getElementById('analysis-title').innerHTML = `GTO Shark AI Analysis: ${street} - ${dbSeed.title}`;
        document.getElementById('gto-action').innerHTML = `<div class="action-pill">${simpleMarkupToHTML(aAnswer.action)}</div>`;
        document.getElementById('gto-rationale').innerHTML = simpleMarkupToHTML(aAnswer.rationale);
        let contextMessage = `This spot is representative of solutions in ${format.replace(/_/g,' ')}.`;
        if (format.startsWith('PLO')) contextMessage = `In Pot-Limit Omaha, range equities change due to extra hole cards.`;
        if (format.includes('MTT') || format.includes('SNG')) contextMessage = `Tournament/ICM context influences tighter lines.`;

        document.getElementById('gto-context').textContent = `Cross-Format Context: ${contextMessage}`;

        // 2) Ask LLM for B & C
        const bcParsed = await askLLMForBAndC(format, street, heroHandStr, boardCardsStr, heroStack, betSize, dbSeed);

        // Prepare safe HTML for B & C from parsed content
        const exploitProfileHtml = simpleMarkupToHTML(bcParsed.exploitativeProfile || '[AI PARSING ERROR: missing exploitativeProfile]');
        const exploitActionHtml = simpleMarkupToHTML(bcParsed.exploitativeAction || '[AI PARSING ERROR: missing exploitiveAction]');
        const exploitRationaleHtml = simpleMarkupToHTML(bcParsed.exploitativeRationale || '[AI PARSING ERROR: missing exploitativeRationale]');
        const keyTitleHtml = (bcParsed.keyConceptTitle || '[AI PARSING ERROR: missing keyConceptTitle]');
        const keyTextHtml = simpleMarkupToHTML(bcParsed.keyConceptText || '[AI PARSING ERROR: missing keyConceptText]');

        document.getElementById('exploitative-profile').innerHTML = exploitProfileHtml;
        document.getElementById('exploitative-action').innerHTML = exploitActionHtml;
        document.getElementById('exploitative-rationale').innerHTML = exploitRationaleHtml;
        document.getElementById('key-concept-title').innerText = keyTitleHtml;
        document.getElementById('key-concept-text').innerHTML = keyTextHtml;
    }

    // ------------------------------
    // Form submission handler
    // ------------------------------
    form.addEventListener('submit', async function(e) {
        e.preventDefault();
        if (!checkFormValidity()) {
            console.error('Form invalid.');
            return;
        }

        // Set loading UI
        document.getElementById('exploitative-profile').textContent = 'Loading AI Analysis...';
        document.getElementById('exploitative-action').textContent = '...';
        document.getElementById('exploitative-rationale').textContent = '...';
        document.getElementById('key-concept-title').textContent = '...';
        document.getElementById('key-concept-text').textContent = '...';
        document.querySelectorAll('.text-red-500').forEach(el => el.classList.remove('text-red-500'));

        analyzeButton.disabled = true;
        buttonText.textContent = 'Solving with GTO & AI...';
        loadingSpinner.classList.remove('hidden');
        outputSection.classList.add('hidden');

        const format = document.getElementById('format').value;
        const street = document.getElementById('street').value;
        const heroStack = parseFloat(document.getElementById('hero-stack').value);
        const opponentStack = parseFloat(document.getElementById('opponent-stack').value);
        const potSize = parseFloat(document.getElementById('pot-size').value);
        const betSize = parseFloat(document.getElementById('bet-size').value);
        const heroHand = document.getElementById('hero-hand-input').value;
        const boardCards = document.getElementById('board-cards-input').value;

        try {
            const start = Date.now();
            await runGTOAnalysis(format, potSize, heroStack, opponentStack, street, heroHand, boardCards, betSize);
            const elapsed = Date.now() - start;
            if (elapsed < 1500) await new Promise(r => setTimeout(r, 1500 - elapsed)); // brief UI pause for feel
            outputSection.classList.remove('hidden');
        } catch (err) {
            console.error('GTO Shark AI Error (API or Network Failure):', err);
            document.getElementById('analysis-title').innerHTML = `<span style="color:#ef4444">GTO Shark AI Error:</span> Content Generation Failed`;
            document.getElementById('exploitative-profile').textContent = 'Error: The AI content generation API request failed or timed out. Please check your network connection and try again.';
            document.getElementById('exploitative-action').textContent = 'RETRY';
            document.getElementById('exploitative-rationale').textContent = 'The model failed to produce a response. This could be due to a network issue or an API rate limit.';
            document.getElementById('key-concept-title').textContent = 'Service Unreachable';
            document.getElementById('key-concept-text').textContent = 'Sections B and C rely on the Gemini API for dynamic, contextual explanations. This content could not be loaded.';
            outputSection.classList.remove('hidden');
        } finally {
            analyzeButton.disabled = false;
            buttonText.textContent = 'Submit Spot for Analysis';
            loadingSpinner.classList.add('hidden');
        }
    });

    // Expose renderPickers to global in case you want to call from console
    window.renderPickers = renderPickers;
</script>
</body>
</html>

